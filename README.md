# ASIC-Design
---
<details>
  <summary><strong>Lab 1:Cprogram compilation.</strong> </summary>
  
# Lab 1A:Create a simple C program to find the sum of the numbers from 1 to n.
### Step 1:
Use the Leafpad editor to write the C code. You can install Leafpad using the following command:<br>
``sudo snap install leafpad``<br>
Create a file named ``sum1ton.c``<br>
![Screenshot 2024-08-07 144122](https://github.com/user-attachments/assets/dd646c7a-636a-45bc-9097-cfe4378df4a9)
### Step 2:
Write c program to find the sum of the numbers from 1 to n.<br>
For an example set the value of n to 45.<br>
Save the file in Leafpad and return to the terminal.
```
#include<stdio.h>
int main(){
  int sum=0;
  int n=100;
  for(int i=1;i<=n;i++){
    sum=sum+i;
  }
  printf("sum of the numbers form 1 to %d is %d",n,sum);
  return 0;
}
```
![Screenshot 2024-08-07 215530](https://github.com/user-attachments/assets/b390cc4f-aa0e-4121-9597-f53345261c88)

### Step 3:
For the compilation of the code, use the following command:<br>
``GCC sum1ton.c``<br>
Make sure there are no errors.<br>
After compilation, an executable file is generated. Run this executable in the terminal to get the final output using the following command:<br>
``./a.out``<br>
![Screenshot 2024-08-07 215759](https://github.com/user-attachments/assets/66bd1819-3ec7-4192-99f0-54b03fa1e782)

The final output will be:<br>
`` Sum of the numbers form 1 to 100 is 5050.``
Check the output using a calculator to verify the result.

# Lab 1B:Compile the same C program using the RISC-V GCC compiler.
### Step 1:
To run the same C program file use the below command:<br>
`` riscv64-unknown-elf-gcc -O1 -mabi=lp64 -march=rv64i -o Lab1.o Lab1.c`` <br>
After compilation it will generate a file named sum1ton.o<br>
![Screenshot 2024-08-07 154120](https://github.com/user-attachments/assets/11f8bea0-3719-4b5b-9c91-446d28cef16d)
### step 2:
To get the aasembly code run the following command:<br>
``riscv64-unkown-elf-objdump -d Lab1.o ``
We will get a large output of code, but we are only interested in the main section. To view just the main section, add | less to the previous command.
`` riscv64-unkown-elf-objdump -d Lab1.o |less``
![Screenshot 2024-08-07 154806](https://github.com/user-attachments/assets/9fcef9a3-4598-479b-9efa-09ab9e3ea56b)<br>

After running the second command, we will get some output. Since we are interested in the main section, search for "main." We will see a bunch of instructions in the main snippet. To count the number of instructions, subtract the address of the first instruction from that of the next section, then divide by 4 (as the increment at each step is 4). This method reveals that there are 15 instructions when we are using O1. We can recheck this using a calculator as well.<br>
![Screenshot 2024-08-07 160155](https://github.com/user-attachments/assets/39208124-f050-4b7c-82f2-f789259dd133)<br>

Now, move back to the first terminal. Here, change the optimization level from `-O1` to `-Ofast` and follow the same procedure as above.<br>
![Screenshot 2024-08-07 160617](https://github.com/user-attachments/assets/dc9393fe-82fe-4a1c-a19f-8b45debbcb6d)<br>

Here, if we use `-Ofast` instead of `-O1`, we get only 12 instructions. Therefore, the number of instructions changes with the optimization level.<br>
![Screenshot 2024-08-07 160729](https://github.com/user-attachments/assets/73b6bcaa-2ca8-4330-b5aa-4f5a1ff4257b)<br>
For `O2`, the number of instructions are 12.<br>
Using `-Ofast` reduces our set of instructions because this optimization level applies a broader range of aggressive optimizations. These optimizations streamline the code, eliminate redundancies, and leverage parallelism, resulting in a lower instruction count compared to `-O1`.<br>
</details>

---

<details>
  <summary><strong>Lab2 :RISC-V Spike simulator.</strong></summary>
  
# Lab 2:Running the Object File Generated by the RISC-V GCC Compiler with the Spike Simulator.
We will compile the object dump file using the RISC-V GCC compiler and check the output against the GCC results from Lab 1. This includes debugging the main part of the program and watching the register values after each step. By looking closely at these values, we can understand how the program behaves and how different compilation stages affect it. This helps make sure the compiled output is accurate and consistent across different compiler settings.<br>
1. For executing an object file created by RISC-V compiler use the below command in the terminal.<br>
```spike pk sum1ton.o```<br>
![Screenshot 2024-08-07 181544](https://github.com/user-attachments/assets/f145ba38-f692-426f-b639-862219a9da23)<br>
2. The following command will help us enter debugging mode using the Spike simulator:<br>
```spike -d pk sum1ton.o```<br>
Use the following command to jump to the beginning of the main section:<br>
``` until pc 0 0x100b0```<br>
![Screenshot 2024-08-07 182238](https://github.com/user-attachments/assets/c0c1d00d-f2ea-481b-8111-2e21f3fe2823)<br>
![Screenshot 2024-08-07 184013](https://github.com/user-attachments/assets/cb1696fb-0d6f-4017-a3ad-a7e51376a026)<br>

3. To check any register value the following command is used:
   ```reg 0 a0```<br>
   Press enter to run the next instruction.
   Here the next instruction is ``lui a2 0x1``, which load upper bits of a2 by 01.<br>
   Intially value of a2 register is 0x0000000000000000.<br>
   After the first instruction it has changed to 0x0000000000001000.<br>
![Screenshot 2024-08-07 183148](https://github.com/user-attachments/assets/1021f417-9713-4e2c-bb46-ee4d9c1c7149)
4. The next instructions are:<br>
   ``lui a0 0x21`` which updates the a0 register value<br>
   ``addi sp sp -16`` This updates the content of the stack pointer 'sp' by -16 (or -10 in hexadecimal).<br>
   ![Screenshot 2024-08-07 185218](https://github.com/user-attachments/assets/dd1798a5-9fdc-44e0-8bfc-d82f64d3793c)<br>
   In the above image we can see that intially sp value is 0x0000003ffffffb50.<br
   After the addi instruction sp value is 0x0000003ffffffb40.<br>
  We can recheck using the calculator. <br>
![Screenshot 2024-08-07 185623](https://github.com/user-attachments/assets/d5b753c4-3ee7-4f0c-9eaf-66802fb67ec1)<br>
</details>

---

<details>
  <summary><strong>Lab 3:RISC-V Instructions</strong></summary>
  
# Lab 3: Overview of RISC-V Instruction Formats.
The RISC-V architecture employs six distinct instruction formats—R-Type, I-Type, S-Type, B-Type, U-Type, and J-Type—each designed for particular operations such as arithmetic and logic processing, immediate value handling, branching, memory access, and jumps. These formats are crucial in specifying the 32-bit instruction codes that drive the RISC-V system.These formats differ in their structure and the kind of operations they facilitate. Below is a detailed breakdown of each format:<br>
![WhatsApp Image 2024-08-10 at 23 31 46_35a88ac2](https://github.com/user-attachments/assets/63377927-7d1a-4f39-8c51-250e2d3f3a42)


### 1) R-Type (Register Type)
**Purpose:** The R-Type format is used for operations like arithmetic and logic that only involve register values. These operations don’t need immediate values or memory access, making them direct and efficient.

**Structure:**
- **Opcode (7 bits):** Instructs the processor on what operation to carry out, such as arithmetic or logic tasks.
- **funct3 (3 bits):** Works with `funct7` to specify the exact operation (e.g., add, subtract, AND, OR).
- **rs1 (5 bits):** The first source register that holds the first operand.
- **rs2 (5 bits):** The second source register that holds the second operand.
- **rd (5 bits):** The destination register where the result is stored.
- **funct7 (7 bits):** Used together with `funct3` to define the operation more accurately, especially to differentiate between similar tasks.

### 2) I-Type (Immediate Type)
**Purpose:** The I-Type format is used for operations that involve an immediate value (a constant within the instruction), loading from memory, and certain arithmetic tasks.

**Structure:**
- **Opcode (7 bits):** Defines the type of operation, such as arithmetic with an immediate value or loading from memory.
- **funct3 (3 bits):** Further specifies the operation, like adding with an immediate value or loading a byte from memory.
- **rs1 (5 bits):** The source register that provides the operand for arithmetic tasks.
- **rd (5 bits):** The destination register where the result is stored.
- **Immediate (12 bits):** The signed immediate value used in the operation, often for offset calculation or as an operand.

### 3) S-Type (Store Type)
**Purpose:** The S-Type format is used for store operations, where data is written from a register to a memory location. This is crucial for storing data in RAM or other memory areas.

**Structure:**
- **Opcode (7 bits):** Specifies the type of store operation, such as storing a word (32-bit) or a byte.
- **funct3 (3 bits):** Further defines the store operation, indicating whether it’s a byte, half-word, or word store.
- **rs1 (5 bits):** The base register that holds the address where the data will be stored.
- **rs2 (5 bits):** The source register that contains the data to be stored.
- **Immediate (12 bits):** The immediate value, split into two parts, that provides the offset to the base address for the store operation.

### 4) B-Type (Branch Type)
**Purpose:** The B-Type format handles conditional branch operations, allowing the program to jump to a different part of the code based on a comparison between two registers. This is key for control flow structures like loops and conditional statements.

**Structure:**
- **Opcode (7 bits):** Specifies the branch operation.
- **funct3 (3 bits):** Indicates the type of comparison (e.g., equal, not equal, less than).
- **rs1 (5 bits):** The first source register involved in the comparison.
- **rs2 (5 bits):** The second source register involved in the comparison.
- **Immediate (12 bits):** A signed offset used to calculate the branch target address. The immediate is split across the instruction fields and combined to compute the jump destination.

### 5) U-Type (Upper Immediate Type)
**Purpose:** The U-Type format is used for operations that require a large immediate value to be loaded into a register, often for constructing addresses or large constants. It allows loading a 20-bit immediate value into the upper 20 bits of a register.

**Structure:**
- **Opcode (7 bits):** Specifies the operation, such as loading an upper immediate value.
- **rd (5 bits):** The destination register where the upper immediate value will be stored.
- **Immediate (20 bits):** The upper immediate value that will be loaded into the register. The lower 12 bits of the register are typically zeroed out or combined with other operations.

### 6) J-Type (Jump Type)
**Purpose:** The J-Type format is used for jump operations, enabling the program to jump to a specific address unconditionally. This is essential for function calls, jump tables, and other control flow changes that require an absolute change in program flow.

**Structure:**
- **Opcode (7 bits):** Specifies the jump operation.
- **rd (5 bits):** The destination register where the return address will be stored, allowing the program to return to the point after the jump.
- **Immediate (20 bits):** A signed offset used to calculate the target address for the jump. The immediate is spread across multiple fields in the instruction and combined to form the jump target.

<img width="772" alt="3808 1535301636" src="https://github.com/user-attachments/assets/d0f05dac-2191-4ade-89f6-8b371a1e3a29">

## Identifying RISC-V Instruction Types (R, I, S, B, U, J) and Determining the Exact 32-bit Instruction Encoding.
```
ADD r5, r4, r5
SUB r5, r5, r4
AND r4, r5, r5
OR r8, r4, r5
XOR r8, r5, r4
SLT r10, r2, r4
ADDI r12, r3, 5
SW r3, r1, 4
SRL r16, r11, r2
BNE r0, r1, 20
BEQ r0, r0, 15
LW r13, r11, 2
SLL r15, r11, r2
```

### 1. `ADD r5, r4, r5`
- **Opcode:** `0110011`
- **rd:** `r5 = 00101`
- **rs1:** `r4 = 00100`
- **rs2:** `r5 = 00101`
- **funct3:** `000`
- **funct7:** `0000000`
- **Instruction Type:** R-Type
- **32-bit Instruction:** `0000000_00101_00100_000_00101_0110011`
- **Hexadecimal Representation:** `0x005202B3`

### 2. `SUB r5, r5, r4`
- **Opcode:** `0110011`
- **rd:** `r5 = 00101`
- **rs1:** `r5 = 00101`
- **rs2:** `r4 = 00100`
- **funct3:** `000`
- **funct7:** `0100000`
- **Instruction Type:** R-Type
- **32-bit Instruction:** `0100000_00100_00101_000_00101_0110011`
- **Hexadecimal Representation:** `0x404282B3`

### 3. `AND r4, r5, r5`
- **Opcode:** `0110011`
- **rd:** `r4 = 00100`
- **rs1:** `r5 = 00101`
- **rs2:** `r5 = 00101`
- **funct3:** `111`
- **funct7:** `0000000`
- **Instruction Type:** R-Type
- **32-bit Instruction:** `0000000_00101_00101_111_00100_0110011`
- **Hexadecimal Representation:** `0x0052F233`

### 4. `OR r8, r4, r5`
- **Opcode:** `0110011`
- **rd:** `r8 = 01000`
- **rs1:** `r4 = 00100`
- **rs2:** `r5 = 00101`
- **funct3:** `110`
- **funct7:** `0000000`
- **Instruction Type:** R-Type
- **32-bit Instruction:** `0000000_00101_00100_110_01000_0110011`
- **Hexadecimal Representation:** `0x00526433`

### 5. `XOR r8, r5, r4`
- **Opcode:** `0110011`
- **rd:** `r8 = 01000`
- **rs1:** `r5 = 00101`
- **rs2:** `r4 = 00100`
- **funct3:** `100`
- **funct7:** `0000000`
- **Instruction Type:** R-Type
- **32-bit Instruction:** `0000000_00100_00101_100_01000_0110011`
- **Hexadecimal Representation:** `0x0042C433`

### 6. `SLT r10, r2, r4`
- **Opcode:** `0110011`
- **rd:** `r10 = 01010`
- **rs1:** `r2 = 00010`
- **rs2:** `r4 = 00100`
- **funct3:** `010`
- **funct7:** `0000000`
- **Instruction Type:** R-Type
- **32-bit Instruction:** `0000000_00100_00010_010_01010_0110011`
- **Hexadecimal Representation:** `0x00412533`

### 7. `ADDI r12, r3, 5`
- **Opcode:** `0010011`
- **rd:** `r12 = 01100`
- **rs1:** `r3 = 00011`
- **Immediate:** `000000000101`
- **funct3:** `000`
- **Instruction Type:** I-Type
- **32-bit Instruction:** `000000000101_00011_000_01100_0010011`
- **Hexadecimal Representation:** `0x00518613`

### 8. `SW r3, r1, 4`
- **Opcode:** `0100011`
- **rs1:** `r1 = 00001`
- **rs2:** `r3 = 00011`
- **Immediate:** `000000000100`
- **funct3:** `010`
- **Instruction Type:** S-Type
- **32-bit Instruction:** `0000000_00011_00001_010_00100_0100011`
- **Hexadecimal Representation:** `0x0030A223`

### 9. `SRL r16, r11, r2`
- **Opcode:** `0110011`
- **rd:** `r16 = 10000`
- **rs1:** `r11 = 01011`
- **rs2:** `r2 = 00010`
- **funct3:** `101`
- **funct7:** `0000000`
- **Instruction Type:** R-Type
- **32-bit Instruction:** `0000000_00010_01011_101_10000_0110011`
- **Hexadecimal Representation:** `0x0025D833`

### 10. `BNE r0, r1, 20`
- **Opcode:** `1100011`
- **rs1:** `r1 = 00001`
- **rs2:** `r0 = 00000`
- **Immediate:** `000000000101`
- **funct3:** `001`
- **Instruction Type:** B-Type
- **32-bit Instruction:** `0_000001_00001_00000_001_0100_0_1100011`
- **Hexadecimal Representation:** `0x02101463`

### 11. `BEQ r0, r0, 15`
- **Opcode:** `1100011`
- **rs1:** `r0 = 00000`
- **rs2:** `r0 = 00000`
- **Immediate:** `000000000111`
- **funct3:** `000`
- **Instruction Type:** B-Type
- **32-bit Instruction:** `0_000000_00000_00000_000_1111_0_1100011`
- **Hexadecimal Representation:** `0x00000F63`

### 12. `LW r13, r11, 2`
- **Opcode:** `0000011`
- **rd:** `r13 = 01101`
- **rs1:** `r11 = 01011`
- **Immediate:** `000000000010`
- **funct3:** `010`
- **Instruction Type:** I-Type
- **32-bit Instruction:** `000000000010_01011_010_01101_0000011`
- **Hexadecimal Representation:** `0x0025A683`

### 13. `SLL r15, r11, r2`
- **Opcode:** `0110011`
- **rd:** `r15 = 01111`
- **rs1:** `r11 = 01011`
- **rs2:** `r2 = 00010`
- **funct3:** `001`
- **funct7:** `0000000`
- **Instruction Type:** R-Type
- **32-bit Instruction:** `0000000_00010_01011_001_01111_0110011`
- **Hexadecimal Representation:** `0x002597B3`

## Summary of RISC-V Instructions

| Instruction        | Type   | 32-bit Representation                       | Hexadecimal Representation |
|--------------------|--------|---------------------------------------------|----------------------------|
| `ADD r5, r4, r5`   | R-Type | `0000000_00101_00100_000_00101_0110011`     | `0x005202B3`               |
| `SUB r5, r5, r4`   | R-Type | `0100000_00100_00101_000_00101_0110011`     | `0x404282B3`               |
| `AND r4, r5, r5`   | R-Type | `0000000_00101_00101_111_00100_0110011`     | `0x0052F233`               |
| `OR r8, r4, r5`    | R-Type | `0000000_00101_00100_110_01000_0110011`     | `0x00526433`               |
| `XOR r8, r5, r4`   | R-Type | `0000000_00100_00101_100_01000_0110011`     | `0x0042C433`               |
| `SLT r10, r2, r4`  | R-Type | `0000000_00100_00010_010_01010_0110011`     | `0x00412533`               |
| `ADDI r12, r3, 5`  | I-Type | `000000000101_00011_000_01100_0010011`      | `0x00518613`               |
| `SW r3, r1, 4`     | S-Type | `0000000_00011_00001_010_00100_0100011`     | `0x0030A223`               |
| `SRL r16, r11, r2` | R-Type | `0000000_00010_01011_101_10000_0110011`     | `0x0025D833`               |
| `BNE r0, r1, 20`   | B-Type | `0_000001_00001_00000_001_0100_0_1100011`     | `0x02101463`               |
| `BEQ r0, r0, 15`   | B-Type | `0_000000_00000_00000_000_1111_0_1100011`     | `0x00000F63`               |
| `LW r13, r11, 2`   | I-Type | `000000000010_01011_010_01101_0000011`      | `0x0025A683`               |
| `SLL r15, r11, r2` | R-Type | `0000000_00010_01011_001_01111_0110011`     | `0x002597B3`               |


</details>

---

<details>
  <summary><strong> Lab 4:Results with GTKWave</strong></summary>
  
#  Lab 4:Visualizing Functional Simulation Results with GTKWave
In the provided Verilog code, the RISC-V instructions are represented with some variations compared to the standard RISC-V ISA. Specifically, each instruction type is assigned a unique opcode in the Verilog implementation. The `func3` and `func7` values, which are used to identify the specific operation, also differ from the standard RISC-V ISA. Notably, `func7` is employed to differentiate between operations involving immediate values and other arithmetic functions; if `func7` is not required for this distinction, it is set to 0 in the Verilog code. The table below illustrates how the 32-bit instruction patterns are hardcoded using these opcodes, `func3`, and `func7` values as defined in the Verilog code.<br>

## Hardcoded table based on the provided Verilog code
| Instruction     | Hardcoded 32bit pattern | Hardcoded hexadecimal pattern| 32bit pattern   | Hexadecimal pattern |
|-----------------|-------------------------|------------------------------|---------------------|---------------|
| ADD r5, r4, r5  | 0000001_00101_00100_000_00101_0000000 | 0x02520280 | 0000000_00101_00100_000_00101_0110011  | 0x005202B3 |
| SUB r5, r5, r4  | 0000001_00100_00101_001_00101_0000000 | 0x02429280  | 0100000_00100_00101_000_00101_0110011  | 0x404282B3      |
| AND r4, r5, r5  | 0000001_00101_00101_010_00100_0000000 | 0x0252A200 |0000000_00101_00101_111_00100_0110011  | 0x0052F233     |
| OR r8, r4, r5  | 0000001_00101_00100_011_01000_0000000  | 0x02523400 |0000000_00101_00100_110_01000_0110011  | 0x00526433      |
| XOR r8, r5, r4  | 0000001_00100_00101_100_01000_0000000 | 0x0242C400 |0000000_00100_00101_100_01000_0110011  | 0x0042C433      |
| SLT r10, r2, r4  | 0000001_00100_00010_101_01010_0000000| 0x02415500 | 0000000_00100_00010_010_01010_0110011  | 0x00412533      |
| ADDI r12, r3, 5  | 000000000101_00011_000_01100_0000000 | 0x00518600 |000000000101_00011_000_01100_0010011  | 0x00518613      |
| SW r3, r1, 4  | 0000000_00011_00001_001_00100_0000001   | 0X00309201| 0000000_00011_00001_010_00100_0100011  | 0x0030A223     |
| LW r13, r11, 2  | 000000000010_01011_000_01101_0000001   | 0x0258681 |000000000010_01011_010_01101_0000011  | 0x0025A683      |
| BEQ r0, r0, 15  | 0_000000_00000_00000_000_1111_0_1100011   | 0X00f00002 |0_000000_00000_00000_000_1111_0_1100011  | 0x00000F63      |
| SRL r16, r11, r2  | 0000000_00010_01011_001_10000_0000011 |0x00259803  | 0000000_00010_01011_101_10000_0110011 | 0x0025D833      |

## Output Waveforms for the instructions provided in the verilog code:

| Operation          | Standard RISCV ISA | Hardcoded ISA |
|--------------------|---------------------|---------------|
| ADD R6, R1, R2     | 0x00110333        | 0x02208300  |
| SUB R7, R1, R2     | 0x402083b3        | 0x02209380  |
| AND R8, R1, R3     | 0x0030f433        | 0x0230a400  |
| OR R9, R2, R5      | 0x005164b3        | 0x02513480  |
| XOR R10, R1, R4    | 0x0040c533        | 0x0240c500  |
| SLT R11, R2, R4     | 0x0045a0b3        | 0x02415580  |
| ADDI R12, R4, 5    | 0x004120b3        | 0x00520600  |
| BEQ R0, R0, 15     | 0x00000f63        | 0x00f00002  |
| SW R3, R1, 2       | 0x0030a123        | 0x00209181  |
| LW R13, R1, 2      | 0x0020a683        | 0x00208681  |
| ADD R14, R2, R2    | 0x00210733         | 0x00210700  |

### Wave forms
``` ADD R6,R1,R2 ```<br>

![Screenshot 2024-08-12 190747](https://github.com/user-attachments/assets/65b65e0f-c0a6-47c9-bc7c-2764d2083987)

``` SUB R7,R1,R2```<br>

![Screenshot 2024-08-12 191520](https://github.com/user-attachments/assets/e21346eb-6dd0-41d3-b0f0-0912873312cd)

```AND R8,R1,R3```<br>

![Screenshot 2024-08-12 191918](https://github.com/user-attachments/assets/b3105bb2-ebf6-4e55-8625-19ecf0829432)


``` OR R9,R2,R5```<br>

![Screenshot 2024-08-12 192010](https://github.com/user-attachments/assets/f208c33c-d457-4cc8-8c42-25492ba113ee)


``` XOR R10,R1,R4```<br>

![Screenshot 2024-08-12 192041](https://github.com/user-attachments/assets/82d42570-0a06-4e38-b036-2e86a75ba284)


```SLT R11,R2,R4```<br>
![Screenshot 2024-08-12 192105](https://github.com/user-attachments/assets/fda0c504-de9a-4ffd-9165-551b6147a055)

```ADDI R12,R4,5```<br>

![Screenshot 2024-08-12 192136](https://github.com/user-attachments/assets/125fa7b9-0683-4aba-afd4-17b2415318f4)


```BEQ R0,R0,15```<br>
![Screenshot 2024-08-12 192202](https://github.com/user-attachments/assets/c89e8614-962d-4514-ba2e-aac9573dc578)


``` SW R3,R1,2```<br>

![Screenshot 2024-08-12 192259](https://github.com/user-attachments/assets/5227f230-3623-457a-8591-d1acae01da30)


```LW R13, R1, 2 ```<br>

![Screenshot 2024-08-12 192407](https://github.com/user-attachments/assets/9197cc14-8ce6-464a-93f4-62b6b9514cc8)


```ADD R14, R2, R2```<br>

![Screenshot 2024-08-12 192457](https://github.com/user-attachments/assets/80c63b58-e584-4539-81c2-d202864b357a)


Output form:<br>

![Screenshot 2024-08-12 192601](https://github.com/user-attachments/assets/964f03ae-ccbd-4a26-a117-703cae7b548f)


</details>

---


<details>
  <summary><strong> Lab 5: RISC-V GCC and GCC Compiler</strong></summary>
  
# Comparing Output Consistency Between RISC-V GCC and GCC Compiler

The code provided is a Palindrome Checker where the user inputs an integer, and the program checks whether the number is a palindrome. The program reverses the digits of the input number and compares the reversed number with the original. If both are identical, the number is identified as a palindrome; otherwise, it is not.<br>
<br>
![Screenshot 2024-08-14 203937](https://github.com/user-attachments/assets/0aed22de-b6cb-4551-becb-32197dc06697)

The image below displays the output produced when the C code is executed using a standard GCC compiler:<br>

![Screenshot 2024-08-14 204553](https://github.com/user-attachments/assets/440881db-fab0-4e59-86e2-4da259a753c5)

The image below displays the output generated when the C code is executed using a RISC-V GCC compiler:<br>

![Screenshot 2024-08-14 205024](https://github.com/user-attachments/assets/f13f862e-de61-4c15-9491-d080ffb1710c)


By examining the images above, we can observe that the output is identical when using both the GCC and RISC-V GCC compilers. This consistency indicates that the code behaves as expected across different compiler architectures, ensuring reliability and compatibility in various development environments. This demonstrates that the program's logic is platform-independent and confirms the accuracy of the compilation process on both compilers.


  
</details>

---

<details>
  <summary><strong>Lab 6: 5 Stage pipelined RISC-V processor  </strong></summary>

  <details>
  <summary><strong>Day 3</strong></summary>

# Designing Digital Logic with TL-Verilog using Makerchip

### Logic Gates
Logic gates are the fundamental building blocks of digital circuits, executing vital logical operations on binary inputs. These gates are crucial for designing intricate systems such as processors, memory units, and controllers. In digital circuits, logic gates work with binary signals, where "0" represents low voltage and "1" represents high voltage. They process one or more input signals to generate an output signal according to defined logical functions.<br>

![Screenshot 2024-08-21 093753](https://github.com/user-attachments/assets/28ddbce8-c199-4daa-93f3-fc8d0773913e)<br>

### Makerchip
Makerchip IDE is a robust tool for digital design, providing an all-in-one environment for coding, simulating, and testing HDL designs. It supports languages such as TL-Verilog, SystemVerilog, Verilog, and VHDL, offering a visual platform for real-time construction and simulation of digital systems. With its user-friendly interface and comprehensive features, Makerchip is suitable for both beginners and seasoned designers. Makerchip enables efficient prototyping, debugging, and refinement of digital designs, ensuring that circuits perform correctly before transitioning to hardware implementation.<br>


### Transaction Level (TL) - Verilog:
TL Verilog is a contemporary extension of traditional Verilog, developed by Redwood EDA to streamline hardware modeling and design. It offers a more abstract and efficient syntax while maintaining compatibility with standard Verilog. TL-Verilog facilitates transaction-level modeling, simplifying the management of complex microarchitectures. In this method, a transaction progresses through the architecture, interacting with components such as pipelines, arbiters, and queues. TL-Verilog is especially effective in minimizing bugs and optimizing design, particularly when used with tools like Makerchip.<br>


## Some Basic Combinational circuits:
### Name of clock signal is clr_asr
### 1. Inverter:
   The resulting block diagram and waveforms are presented as depicted:<br>
   ![Screenshot 2024-08-21 152754](https://github.com/user-attachments/assets/2867695f-706b-4047-9662-dc6c65b36a31)

### 2. 2- input AND gate:
   The resulting block diagram and waveforms are presented as depicted:<br>
   ![Screenshot 2024-08-21 153033](https://github.com/user-attachments/assets/d44bf330-ce4f-4b21-bf7b-43d63f1891f2)

### 3. 2-input OR gate:
   The resulting block diagram and waveforms are presented as depicted:<br>
   ![Screenshot 2024-08-21 153131](https://github.com/user-attachments/assets/50edfc0a-c23a-4d43-94b4-7e091aa27586)

### 4. 2:1 MUX
   The resulting block diagram and waveforms are presented as depicted:<br>
   ![Screenshot 2024-08-21 154614](https://github.com/user-attachments/assets/41df9ee3-0116-4e27-a1bd-6d7e5cb972f9)

### 5. Implementation of a Combinational Calculator in TL-Verilog
Overview of the Calculator: This section showcases a simple combinational calculator created using TL-Verilog on the Makerchip platform. The calculator performs the four basic arithmetic operations: addition, subtraction, multiplication, and division.<br>
The resulting block diagram and waveforms are presented as depicted:<br>

![image](https://github.com/user-attachments/assets/8036afeb-76f3-486c-b4f6-52f5c8793583)

In this code snippet, two random 4-bit values, `$rand1[3:0]` and `$rand2[3:0]`, are assigned to the 32-bit variables `$val1[31:0]` and `$val2[31:0]`, respectively. The calculator then performs four arithmetic operations on these values.<br>

A multiplexer (MUX), controlled by the selection bits `$sel[1:0]`, chooses the result of one of these operations. The selected output is then assigned to `$out[31:0]`.<br>

![Screenshot 2024-08-21 160425](https://github.com/user-attachments/assets/0ed3f8e0-eee7-45b9-b140-5f991597dff0)

## SEquential Circuits

A sequential circuit is a type of digital circuit that utilizes memory elements to store data, enabling it to produce outputs based on both current inputs and the circuit’s prior state. In contrast to combinational circuits, which rely solely on present inputs, sequential circuits incorporate feedback loops and storage components like flip-flops or registers to monitor their internal state. This internal state, combined with the current inputs, dictates the circuit’s functionality, making it capable of performing tasks that require a history of inputs, such as counting, data storage, or event sequencing.<br>

### 1.Counter Series:

The block diagram and waveforms generated are displayed below:<br>
![Screenshot 2024-08-21 161052](https://github.com/user-attachments/assets/85cff099-3dfd-4bc9-b474-a9d22589224a) <br>

![Screenshot 2024-08-21 161219](https://github.com/user-attachments/assets/2cf54660-8876-4055-8120-956a6acbc705)

### 2. Fibbonacci Series:

The block diagram and waveforms generated are displayed below:<br>

![Screenshot 2024-08-21 161435](https://github.com/user-attachments/assets/2779d46b-a43d-49b2-bb97-be76abd6b9ce) <br>


![image](https://github.com/user-attachments/assets/4b490f01-0945-4a28-bdc6-7237da52e88e)

### 3. Sequential Calculator:

This design is similar to the previous combinational calculator but simulates a real-world scenario where the result of the previous operation is used as one of the inputs for the next operation. When the circuit is reset, the result is cleared to zero.<br>

![Screenshot 2024-08-21 161837](https://github.com/user-attachments/assets/0f901d7a-5ff6-4560-b804-d19da54cc1a4)<br>

![Screenshot 2024-08-21 161920](https://github.com/user-attachments/assets/d90fe0a2-c3d3-4b1e-8262-f388e9f63960) <br>

![Screenshot 2024-08-21 161805](https://github.com/user-attachments/assets/6192171d-ed81-4b7e-be3f-6d11441192c2) <br>


## Pipelined Logic
In Transaction-Level Verilog (TL-Verilog), pipelined logic is effectively modeled using pipeline constructs that represent data movement through various stages, with each stage corresponding to a clock cycle. This method streamlines the modeling of sequential logic by managing state transitions automatically and providing clear, concise representations of complex multi-stage operations. This enhances both the clarity and maintainability of the design.<br>

### 1. Recreating the Design

![Screenshot 2024-08-21 162218](https://github.com/user-attachments/assets/71aff8b9-aa48-4c88-8c09-5ec86ce791fb) <br>


![Screenshot 2024-08-21 162446](https://github.com/user-attachments/assets/82066fc0-54a3-4944-bf7e-e13f830e1cb6) <br>

![Screenshot 2024-08-21 162521](https://github.com/user-attachments/assets/c86b3a8f-1412-45fd-a76a-52fa833d1d7f) <br>

Therefore, it can be observed that the given pipeline design and the recreated design are identical.<br>


### 2. Pipelined Calculator
This design is similar to the previous Sequential Calculator but incorporates a pipelined architecture and utilizes `$valid` to clear alternate values.<br>

![Screenshot 2024-08-21 182420](https://github.com/user-attachments/assets/d3d77f6a-a429-4047-a25c-72c2ff87646e) <br>

![Screenshot 2024-08-21 163012](https://github.com/user-attachments/assets/d3d5a167-51a3-4bc5-9c55-51469a5d321a) <br>

### 3. Cycle Calculator with validity
We introduce `$valid_or_reset = $valid || $reset;` as a condition for triggering calculations, replacing the previous method of setting `$out` to zero.<br>

![Screenshot 2024-08-21 175517](https://github.com/user-attachments/assets/e1cf5b8d-fb89-4e1e-ac2d-cb1ace330c50) <br>

  </details>

<details>
  <summary><strong> Day 4</strong></summary>

# Fundamentals of RISC-V CPU Micro-architecture
This section will discuss the implementation of a basic 3-stage RISC-V Core/CPU. The three stages include: Fetch, Decode, and Execute. The diagram below illustrates the fundamental block diagram of the CPU core:<br>

### Name of the clock signal is clc_asr

![Screenshot 2024-08-21 180115](https://github.com/user-attachments/assets/8d26c27f-ed72-4cbb-abbd-53ab154c5dcc) <br>

### Implementation plan:
![Screenshot 2024-08-21 180155](https://github.com/user-attachments/assets/d1e368ee-b8de-4819-b25e-11794e32706d) <br>

### 1. Program counter

The Program Counter, also known as the Instruction Pointer, is a component that holds the address of the next instruction to be executed. Typically, the program counter increments by 4 to fetch the subsequent instruction from memory. If a reset occurs, the program counter is reinitialized to zero for the next instruction, after which it resumes normal operation.<br>

The diagram below illustrates the functioning of the program counter.<br>

![Screenshot 2024-08-21 180439](https://github.com/user-attachments/assets/7e2f298d-8e19-47f5-9315-9fbcebadc888)<br>

![Screenshot 2024-08-21 182158](https://github.com/user-attachments/assets/9fb85acd-7ddd-439d-98e1-505473fb965d)  <br>

Code:<br>
``` $pc[31:0] = >>1$reset ? 0 : ( >>1$pc + 31'h4 ); ```

### 2. Adding the instruction memory

![Screenshot 2024-08-21 181059](https://github.com/user-attachments/assets/9ecf6c22-9838-4fec-88dc-c3eeef8ffad6) <br>

![Screenshot 2024-08-21 181120](https://github.com/user-attachments/assets/1b07fa46-04bc-4358-96a4-6ce66fa87e05) <br>

The output of the Program Counter (PC) is fed into the instruction memory, which then outputs the instruction to be executed. The program counter increments by 4 with each valid iteration. This incremented output is used to fetch the next instruction from the instruction memory.<br>

The instruction memory provides a 32-bit instruction based on the input address. During the Fetch Stage, the processor retrieves the instruction from the instruction memory (IM) at the address specified by the PC.<br>

![image](https://github.com/user-attachments/assets/e08019d4-8349-4d62-a832-9e33b6fb0fdd) <br>

Code:<br>
```
     @0
         $reset = *reset;
         $clc_asr = *clk;
         $pc[31:0] = >>1$reset ? 0 : ( >>1$pc + 31'h4 );
         $imem_rd_en = >>1$reset ? 0 : 1;
         $imem_rd_addr[31:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
      @1
         $instr[31:0] = $imem_rd_data[31:0];
```
### 3. Instruction Decoding 
The 32-bit fetched instruction must be decoded to determine the operation to be performed as well as the source and destination addresses. There are six types of instructions:<br>

- **R-type**: Register
- **I-type**: Immediate
- **S-type**: Store
- **B-type**: Branch (Conditional Jump)
- **U-type**: Upper Immediate
- **J-type**: Jump (Unconditional Jump)


The instruction format includes the opcode, immediate value, source address, and destination address. During the Decode Stage, the processor interprets the instruction according to its format and type.<br>
Typically, the RISC-V ISA features 32 registers, each with a width of XLEN (e.g., XLEN = 32 for RV32). The register file used in this architecture supports two simultaneous read operations and one write operation.<br>

![image](https://github.com/user-attachments/assets/a848f05e-fc69-4842-823b-b976a3b95dc1) <br>

![image](https://github.com/user-attachments/assets/b7074567-7940-4153-9c39-08cf97f0b7e6) <br>

Code:<br>
```
      @0
         $reset = *reset;
         $clc_asr = *clk;
         $pc[31:0] = >>1$reset ? 0 : ( >>1$pc + 31'h4 );
         $imem_rd_en = >>1$reset ? 0 : 1;
         $imem_rd_addr[31:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
      @1
         $instr[31:0] = $imem_rd_data[31:0];
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
              $instr[6:2] ==? 5'b001x0 ||
              $instr[6:2] ==? 5'b11001;
         $is_r_instr = $instr[6:2] ==? 5'b01011 ||
              $instr[6:2] ==? 5'b011x0 ||
              $instr[6:2] ==? 5'b10100;
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         $is_b_instr = $instr[6:2] ==? 5'b11000;
         $is_j_instr = $instr[6:2] ==? 5'b11011;
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
```
#### 3a. Immediate Decode Logic
![image](https://github.com/user-attachments/assets/5a7406fb-6ce1-485a-b395-17a629fe94ef) <br>

Code:<br>

```
             $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
             $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
             $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0} :
             $is_u_instr ? {$instr[31:12], 12'b0} :
             $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} : 32'b0;
````

#### 3b. Decoding logic for the other fields like rs1,rs2,funct3,funct7
In addition to the immediate field, several other fields also require decoding. The code for this process is as follows:<br>
Code:
```
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
            
         $rs1_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         
         $funct3_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
            
         $funct7_valid = $is_r_instr ;
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
            
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         ?$rd_valid
            $rd[4:0] = $instr[11:7];

         $opcode[6:0] = $instr[6:0];
```
At any given moment, only one instruction is decoded, and it may belong to any of the six instruction types. Therefore, it is crucial to validate the instruction to ensure it matches its specific category, thereby avoiding conflicts between different instruction types.<br>

![image](https://github.com/user-attachments/assets/1bd0370e-a6c6-4816-9e56-b85517fce671)


#### 3c. Individual Instructions Coding
![image](https://github.com/user-attachments/assets/f4b9df4c-7a78-4de5-b5ba-2d3cdbfcc8eb)

To decode the individual instructions outlined above, use the following code:<br>
```
$dec_bits [10:0] = {$funct7[5], $funct3, $opcode};
$is_beq = $dec_bits ==? 11'bx_000_1100011;
$is_bne = $dec_bits ==? 11'bx_001_1100011;
$is_blt = $dec_bits ==? 11'bx_100_1100011;
$is_bge = $dec_bits ==? 11'bx_101_1100011;
$is_bltu = $dec_bits ==? 11'bx_110_1100011;
$is_bgeu = $dec_bits ==? 11'bx_111_1100011;
$is_addi = $dec_bits ==? 11'bx_000_0010011;
$is_add = $dec_bits ==? 11'b0_000_0110011;
```

We also need to update the program counter to handle branch instructions.<br>
```
$pc[31:0] = >>1$reset ? 32'b0 :
            >>1$taken_branch ? >>1$br_target_pc :
            >>1$pc + 32'd4;
```
output:
![image](https://github.com/user-attachments/assets/a236b2b3-4f98-40e1-8fb1-c1b32f54e47a)

### 4. Register File Read and Enable
In this setup, instructions are fetched from the instruction memory and stored in registers. Two register slots are used to read these instructions, which are then sent to the ALU for processing.<br>

![image](https://github.com/user-attachments/assets/4ec7b570-6887-418e-a20d-95f1790a4ad9) <br>

![image](https://github.com/user-attachments/assets/69643cfa-bdb7-496a-bec6-42f567241580)

Code:<br>
```

$rf_rd_en1 = $rs1_valid;
$rf_rd_en2 = $rs2_valid;
$rf_rd_index1[4:0] = $rs1;
$rf_rd_index2[4:0] = $rs2;
$src1_value[31:0] = $rf_rd_data1;
$src2_value[31:0] = $rf_rd_data2;
```

### 5. Arithmetic and Logic unit
![image](https://github.com/user-attachments/assets/faf1bbb4-2261-4693-8bdd-dcb163bf01af)<br>

Used to execute arithmetic operations on the values stored in the registers. The code for this is as follows:<br>
![image](https://github.com/user-attachments/assets/57cd558b-85cb-4ff5-b927-228621ab9f23)
Code:
```
$result[31:0] = $is_addi ? $src1_value + $imm :
                $is_add ? $src1_value + $src2_value :
                32'bx ;
```

### 6. Register File write
![image](https://github.com/user-attachments/assets/016f9e12-9066-4434-bb66-7588924687bf)

After the ALU performs operations on the values stored in the registers, we may need to write the results back into the registers. This is done using the register file write operation. Additionally, we must ensure that no values are written to the destination register if it is x0, as it is designed to always remain zero. The code for this process is as follows:<br>

![image](https://github.com/user-attachments/assets/1d1301e1-2b73-45be-b4d0-29f37755ef35)
Code:<br>
```
$rf_wr_en = $rd_valid && $rd != 5'b0;
$rf_wr_index[4:0] = $rd;
$rf_wr_data[31:0] = $result;
```

### 7. Branch Instructions
![image](https://github.com/user-attachments/assets/53e9d344-03a9-439c-b89f-3e9b9799c223)

Based on the control input, we might need to jump to a different address after executing a specific instruction, depending on conditions generated at runtime. This is managed using branch instructions. The code for this operation is as follows:
Output:
![image](https://github.com/user-attachments/assets/a09d5618-5fc1-431b-8d0f-83848c677e4e)

Code:<br>
```

$taken_branch = $is_beq ? ($src1_value == $src2_value):
                $is_bne ? ($src1_value != $src2_value):
                $is_blt ? (($src1_value < $src2_value) ^ ($src1_value[31] != $src2_value[31])):
                $is_bge ? (($src1_value >= $src2_value) ^ ($src1_value[31] != $src2_value[31])):
                $is_bltu ? ($src1_value < $src2_value):
                $is_bgeu ? ($src1_value >= $src2_value):1'b0;

$br_target_pc[31:0] = $pc +$imm;
```

## Testbench

To verify the correctness of the code, we use a testbench to check the implementation over the first five cycles.<br>
Code:<br>
```
*passed = |cpu/xreg[10]>>5$value == (1+2+3+4+5+6+7+8+9) ;
```
Upon checking the log file we get the following result:

![Screenshot 2024-08-21 223921](https://github.com/user-attachments/assets/bd2be7a0-7c87-4a59-961f-2035042c4038)

Results:<br>
![Screenshot 2024-08-21 235038](https://github.com/user-attachments/assets/1d352e7e-fd23-45f5-b451-2a1f5e9fa0c1) <br>

![Screenshot 2024-08-21 235131](https://github.com/user-attachments/assets/e6fe4b2f-6dc7-4b1e-94e7-ef4d3998c4a2) <br>

![Screenshot 2024-08-21 235202](https://github.com/user-attachments/assets/3291db9d-016d-4674-90c8-6034b8ac6d3a) <br>

</details>

<details>
  <summary><strong>Day 5</strong></summary>
  
## Complete Pipelined RISC-V CPU Micro-architecture
The CPU core is pipelined to facilitate easier retiming and significantly reduce functional bugs. Pipelining is achieved by adding stages such as @1, @2, and so on. In TL-Verilog, there's no strict requirement for defining pipelines in a systematic order, which is an advantage of this approach.<br>

However, pipelining introduces certain hazards, particularly the "branch instruction hazard" or "branch penalty." This arises because branch instructions can alter the execution sequence, leading to uncertainties. The types of hazards include:<br>

- **Structural Hazards:** Conflicts over shared resources, such as execution units, can cause pipeline stalls until the resource contention is resolved.
- **Data Hazards:** Dependencies on results from previous instructions may lead to incorrect outcomes if the required data is not yet available.
- **Control Hazards (Branch Hazards):** Uncertainties in branch outcomes can delay the confirmation of the correct instruction path, potentially resulting in incorrect instruction fetches and performance degradation due to pipeline flushing.

### Valid signal for Pipelined Logic:
The TL-Verilog code to incorporate the valid signal for pipelined logic is provided below:<br>
```
$start = >>1$reset && !$reset;
$valid = $reset ? 1'b0 : ($start || >>3$valid);
$valid_or_reset = $valid || $reset;
$rs1_or_funct3_valid    = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
$rs2_valid              = $is_r_instr || $is_s_instr || $is_b_instr;
$rd_valid               = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
$funct7_valid           = $is_r_instr;
```

### Handling Data Hazards in Register File with Bypassing:

```
$src1_value[31:0] = $rs1_bypass ? >>1$result[31:0] : $rf_rd_data1[31:0];
$src2_value[31:0] = $rs2_bypass ? >>1$result[31:0] : $rf_rd_data2[31:0];
```

### Correcting branch target path:
```
   //Current instruction is valid if one of the previous 2 instructions were not (taken_branch or load or jump)
   $valid = ~(>>1$valid_taken_br || >>2$valid_taken_br || >>1$is_load || >>2$is_load || >>2$jump_valid 	|| >>1$jump_valid);
         
   //Current instruction is valid & is a taken branch
   $valid_taken_br = $valid && $taken_br;
         
   //Current instruction is valid & is a load
   $valid_load = $valid && $is_load;
         
   //Current instruction is valid & is jump
   $jump_valid = $valid && $is_jump;
   $jal_valid  = $valid && $is_jal;
   $jalr_valid = $valid && $is_jalr;
    
    *passed = |cpu/xreg[14]>>5$value == (1+2+3+4+5+6+7+8+9+10);
```

#### Final Logic for 5-Stage Pipelining:
```
\m4_TLV_version 1d: tl-x.org
\SV
   // Template code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   
   //  Sum 0 to 9 Program 
   //
   // Add 0,1,2,3,...,9
   //
   // Registers:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   m4_asm(SW, r0, r10, 10000)           // Store r10 result in dmem
   m4_asm(LW, r17, r0, 10000)           // Load contents of dmem to r17
   m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clc_asr = *clk;
         
         //PC fetch - branch, jumps and loads introduce 2 cycle bubbles in this pipeline
         $pc[31:0] = >>1$reset ? '0 : (>>3$valid_taken_br ? >>3$br_tgt_pc :
                                       >>3$valid_load     ? >>3$inc_pc[31:0] :
                                       >>3$jal_valid      ? >>3$br_tgt_pc :
                                       >>3$jalr_valid     ? >>3$jalr_tgt_pc :
                                                     (>>1$inc_pc[31:0]));
         // Access instruction memory using PC
         $imem_rd_en = ~ $reset;
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         
         
      @1
         //Getting instruction from IMem
         $instr[31:0] = $imem_rd_data[31:0];
         
         //Increment PC
         $inc_pc[31:0] = $pc[31:0] + 32'h4;
         
         //Decoding I,R,S,U,B,J type of instructions based on opcode [6:0]
         //Only [6:2] is used here because this implementation is for RV64I which does not use [1:0]
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] == 5'b11001;
         
         $is_r_instr = $instr[6:2] == 5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] == 5'b10100;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
         
         $is_b_instr = $instr[6:2] == 5'b11000;
         
         $is_j_instr = $instr[6:2] == 5'b11011;
         
         //Immediate value decode
         $imm[31:0] = $is_i_instr ? { {21{$instr[31]}} , $instr[30:20]} :
                      $is_s_instr ? { {21{$instr[31]}} , $instr[30:25] , $instr[11:8] , $instr[7]} :
                      $is_b_instr ? { {20{$instr[31]}} , $instr[7] , $instr[30:25] , $instr[11:8] , 1'b0} :
                      $is_u_instr ? { $instr[31] , $instr[30:12] , { 12{1'b0}} } :
                      $is_j_instr ? { {12{$instr[31]}} , $instr[19:12] , $instr[20] , $instr[30:21] , 1'b0} :
                      >>1$imm[31:0];
         
         //Generate valid signals for each instruction fields
         $rs1_or_funct3_valid    = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         $rs2_valid              = $is_r_instr || $is_s_instr || $is_b_instr;
         $rd_valid               = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         $funct7_valid           = $is_r_instr;
         
         //Decode other fields of instruction - source and destination registers, funct, opcode
         ?$rs1_or_funct3_valid
            $rs1[4:0]    = $instr[19:15];
            $funct3[2:0] = $instr[14:12];
         
         ?$rs2_valid
            $rs2[4:0]    = $instr[24:20];
         
         ?$rd_valid
            $rd[4:0]     = $instr[11:7];
         
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
         
         $opcode[6:0] = $instr[6:0];
         
         //Decode instruction in subset of base instruction set based on RISC-V 32I
         $dec_bits[10:0] = {$funct7[5],$funct3,$opcode};
         
         //Branch instructions
         $is_beq   = $dec_bits ==? 11'bx_000_1100011;
         $is_bne   = $dec_bits ==? 11'bx_001_1100011;
         $is_blt   = $dec_bits ==? 11'bx_100_1100011;
         $is_bge   = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu  = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu  = $dec_bits ==? 11'bx_111_1100011;
         
         //Jump instructions
         $is_auipc = $dec_bits ==? 11'bx_xxx_0010111;
         $is_jal   = $dec_bits ==? 11'bx_xxx_1101111;
         $is_jalr  = $dec_bits ==? 11'bx_000_1100111;
         
         //Arithmetic instructions
         $is_addi  = $dec_bits ==? 11'bx_000_0010011;
         $is_add   = $dec_bits ==  11'b0_000_0110011;
         $is_lui   = $dec_bits ==? 11'bx_xxx_0110111;
         $is_slti  = $dec_bits ==? 11'bx_010_0010011;
         $is_sltiu = $dec_bits ==? 11'bx_011_0010011;
         $is_xori  = $dec_bits ==? 11'bx_100_0010011;
         $is_ori   = $dec_bits ==? 11'bx_110_0010011;
         $is_andi  = $dec_bits ==? 11'bx_111_0010011;
         $is_slli  = $dec_bits ==? 11'b0_001_0010011;
         $is_srli  = $dec_bits ==? 11'b0_101_0010011;
         $is_srai  = $dec_bits ==? 11'b1_101_0010011;
         $is_sub   = $dec_bits ==? 11'b1_000_0110011;
         $is_sll   = $dec_bits ==? 11'b0_001_0110011;
         $is_slt   = $dec_bits ==? 11'b0_010_0110011;
         $is_sltu  = $dec_bits ==? 11'b0_011_0110011;
         $is_xor   = $dec_bits ==? 11'b0_100_0110011;
         $is_srl   = $dec_bits ==? 11'b0_101_0110011;
         $is_sra   = $dec_bits ==? 11'b1_101_0110011;
         $is_or    = $dec_bits ==? 11'b0_110_0110011;
         $is_and   = $dec_bits ==? 11'b0_111_0110011;
         
         //Store instructions
         $is_sb    = $dec_bits ==? 11'bx_000_0100011;
         $is_sh    = $dec_bits ==? 11'bx_001_0100011;
         $is_sw    = $dec_bits ==? 11'bx_010_0100011;
         
         //Load instructions - support only 4 byte load
         $is_load  = $dec_bits ==? 11'bx_xxx_0000011;
         
         $is_jump = $is_jal || $is_jalr;
         
      @2
         //Get Source register values from reg file
         $rf_rd_en1 = $rs1_or_funct3_valid;
         $rf_rd_en2 = $rs2_valid;
         
         $rf_rd_index1[4:0] = $rs1[4:0];
         $rf_rd_index2[4:0] = $rs2[4:0];
         
         //Register file bypass logic - data forwarding from ALU to resolve RAW dependence
         $src1_value[31:0] = $rs1_bypass ? >>1$result[31:0] : $rf_rd_data1[31:0];
         $src2_value[31:0] = $rs2_bypass ? >>1$result[31:0] : $rf_rd_data2[31:0];
         
         //Branch target PC computation for branches and JAL
         $br_tgt_pc[31:0] = $imm[31:0] + $pc[31:0];
         
         //RAW dependence check for ALU data forwarding
         //If previous instruction was writing to reg file, and current instruction is reading from same register
         $rs1_bypass = >>1$rf_wr_en && (>>1$rd == $rs1);
         $rs2_bypass = >>1$rf_wr_en && (>>1$rd == $rs2);
         
      @3
         //ALU
         $result[31:0] = $is_addi  ? $src1_value +  $imm :
                         $is_add   ? $src1_value +  $src2_value :
                         $is_andi  ? $src1_value &  $imm :
                         $is_ori   ? $src1_value |  $imm :
                         $is_xori  ? $src1_value ^  $imm :
                         $is_slli  ? $src1_value << $imm[5:0]:
                         $is_srli  ? $src1_value >> $imm[5:0]:
                         $is_and   ? $src1_value &  $src2_value:
                         $is_or    ? $src1_value |  $src2_value:
                         $is_xor   ? $src1_value ^  $src2_value:
                         $is_sub   ? $src1_value -  $src2_value:
                         $is_sll   ? $src1_value << $src2_value:
                         $is_srl   ? $src1_value >> $src2_value:
                         $is_sltu  ? $sltu_rslt[31:0]:
                         $is_sltiu ? $sltiu_rslt[31:0]:
                         $is_lui   ? {$imm[31:12], 12'b0}:
                         $is_auipc ? $pc + $imm:
                         $is_jal   ? $pc + 4:
                         $is_jalr  ? $pc + 4:
                         $is_srai  ? ({ {32{$src1_value[31]}} , $src1_value} >> $imm[4:0]) :
                         $is_slt   ? (($src1_value[31] == $src2_value[31]) ? $sltu_rslt : {31'b0, $src1_value[31]}):
                         $is_slti  ? (($src1_value[31] == $imm[31]) ? $sltiu_rslt : {31'b0, $src1_value[31]}) :
                         $is_sra   ? ({ {32{$src1_value[31]}}, $src1_value} >> $src2_value[4:0]) :
                         $is_load  ? $src1_value +  $imm :
                         $is_s_instr ? $src1_value + $imm :
                                    32'bx;
         
         $sltu_rslt[31:0]  = $src1_value <  $src2_value;
         $sltiu_rslt[31:0] = $src1_value <  $imm;
         
         //Jump instruction target PC computation
         $jalr_tgt_pc[31:0] = $imm[31:0] + $src1_value[31:0]; 
         
         //Branch resolution
         $taken_br = $is_beq ? ($src1_value == $src2_value) :
                     $is_bne ? ($src1_value != $src2_value) :
                     $is_blt ? (($src1_value < $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bge ? (($src1_value >= $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bltu ? ($src1_value < $src2_value) :
                     $is_bgeu ? ($src1_value >= $src2_value) :
                     1'b0;
         
         //Current instruction is valid if one of the previous 2 instructions were not (taken_branch or load or jump)
         $valid = ~(>>1$valid_taken_br || >>2$valid_taken_br || >>1$is_load || >>2$is_load || >>2$jump_valid || >>1$jump_valid);
         
         //Current instruction is valid & is a taken branch
         $valid_taken_br = $valid && $taken_br;
         
         //Current instruction is valid & is a load
         $valid_load = $valid && $is_load;
         
         //Current instruction is valid & is jump
         $jump_valid = $valid && $is_jump;
         $jal_valid  = $valid && $is_jal;
         $jalr_valid = $valid && $is_jalr;
         
         //Destination register update - ALU result or load result depending on instruction
         $rf_wr_en = (($rd != '0) && $rd_valid && $valid) || >>2$valid_load;
         $rf_wr_index[4:0] = $valid ? $rd[4:0] : >>2$rd[4:0];
         $rf_wr_data[31:0] = $valid ? $result[31:0] : >>2$ld_data[31:0];
         
      @4
         //Data memory access for load, store
         $dmem_addr[3:0]     =  $result[5:2];
         $dmem_wr_en         =  $valid && $is_s_instr;
         $dmem_wr_data[31:0] =  $src2_value[31:0];
         $dmem_rd_en         =  $valid_load;
         
      
         //Write back data read from load instruction to register
         $ld_data[31:0]      =  $dmem_rd_data[31:0];
         
      
      

      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   //Checks if sum of numbers from 1 to 9 is obtained in reg[17] and runs 10 cycles extra after this is met
   *passed = |cpu/xreg[17]>>10$value == (1+2+3+4+5+6+7+8+9);
   //Run for 200 cycles without any checks
   //*passed = *cyc_cnt > 200;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@2, @3)  // Args: (read stage, write stage) - if equal, no register bypass is required
      m4+dmem(@4)    // Args: (read/write stage)
   
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic
                       // @4 would work for all labs
\SV
   endmodule

```

#### Block diagram:
![Screenshot 2024-08-22 004302](https://github.com/user-attachments/assets/e45d29b4-74f7-4f05-97f7-fc4a9bbce3de)

#### VIZ Table:
![Screenshot 2024-08-22 004311](https://github.com/user-attachments/assets/209562c3-724e-4fe4-8408-8808657ce5ea)

#### Waveforms:
Clock:
![Screenshot 2024-08-22 004337](https://github.com/user-attachments/assets/8b7b9452-158e-44fb-8466-a5e19e6b0e67)

Reset:
![Screenshot 2024-08-22 004433](https://github.com/user-attachments/assets/c1f8aadf-a727-4675-8534-50a6274c83aa)

#### Incrementing the output gradually from 0 (0x00) to  45(0x2d).

![Screenshot 2024-08-22 004456](https://github.com/user-attachments/assets/2cf0e278-68f0-419b-a346-2d426d79f503)

#### Simulation status

![Screenshot 2024-08-22 004532](https://github.com/user-attachments/assets/32e518b1-8c78-472f-a2cb-00e4a4384506)

</details>
</details>

---

<details>
  
  <summary><strong>Lab 7: Comparing GTK wave and makerchip output<strong></summary>

# Evaluating RISC-V Pre-Synthesis Simulation Outputs with Iverilog, GTKwave, and Makerchip
The RISC-V processor was initially designed in TL-Verilog using the Makerchip IDE. For FPGA implementation, it was converted to Verilog through the Sandpiper-SaaS compiler. Pre-synthesis simulations were subsequently conducted using the GTKWave simulator.<br>

### Step 1:
Execute these commands to set up a development environment for working with simulation and synthesis tools, specifically for tasks involving Verilog and RISC-V.
```
sudo apt install make python python3 python3-pip git iverilog gtkwave

cd ~

sudo apt-get install python3-venv

python3 -m venv .venv

source ~/.venv/bin/activate

pip3 install pyyaml click sandpiper-saas
```
![Screenshot 2024-08-26 202210](https://github.com/user-attachments/assets/c5d756aa-d923-4523-9b6a-7154029d3a09)




### Step 2:
To install the required packages, run these commands within a virtual environment:
```
sudo apt install make python python3 python3-pip git iverilog gtkwave docker.io

sudo chmod 666 /var/run/docker.sock

cd ~

pip3 install pyyaml click sandpiper-saas
```
![Screenshot 2024-08-26 202242](https://github.com/user-attachments/assets/d27fb5f0-48a5-4a34-8074-9e2f7f59792d)



### Step 3:
Next, clone the repository into the home directory and create a `pre_synth_sim` directory to store the output.
```
cd ~

git clone https://github.com/manili/VSDBabySoC.git

cd /home/vsduser/VSDBabySoC

make pre_synth_sim
```


### Step 4:
Replace the `rvmyth.tlv` file in the `VSDBabySoC/src/module` folder with your RISC-V design from the Makerchip `.tlv` file that you want to convert to Verilog. Also, update the testbench to match your Makerchip code.<br>

To translate the `.tlv` definition of RISC-V into a `.v` Verilog file, use the following code:
```
sandpiper-saas -i ./src/module/rvmyth.tlv -o rvmyth.v --bestsv --noline -p verilog --outdir ./src/module/
```

### Step 5:
Now to compile and simulate RISC-V design run the following code
```
iverilog -o output/pre_synth_sim.out -DPRE_SYNTH_SIM src/module/testbench.v -I src/include -I src/module
```

### Step 6:
The simulation result, `pre_synth_sim.vcd`, will be saved in the `output/pre_synth_sim` directory.<br>
```
cd output

./pre_synth_sim.out
```

### Step 7:
To open the `.vcd` simulation file using the GTKWave simulation tool, use the following command:
```
$ gtkwave pre_synth_sim.vcd
```
![Screenshot 2024-08-26 202325](https://github.com/user-attachments/assets/ca90e2c3-2382-424c-a362-ae5ed6cc67d3)

### Pre-synthesis Simulation results:
- **clc_asr**: Clock input for the RISC-V core.
- **reset**: This is the input reset signal to the RISC-V core.
- **OUT[9:0]**: This represents the 10-bit output [9:0] port of the RISC-V core. It originates from RISC-V register #14.

### GTKWave Simulation waveforms:
#### Reset:

![Screenshot 2024-08-26 185036](https://github.com/user-attachments/assets/aa605e54-a595-4157-aaa7-4d1cc7bc8cb5)

#### Clock:

 ![Screenshot 2024-08-26 185025](https://github.com/user-attachments/assets/f198bf08-1161-4dac-af41-3ac6e98aeea4)

#### Out[9:0]:

![Screenshot 2024-08-26 185047](https://github.com/user-attachments/assets/fdcb1212-b967-45f7-8149-48e279bf3370)

### Makerchip Simulation waveforms:
#### Reset:

![Screenshot 2024-08-22 004433](https://github.com/user-attachments/assets/fbedc275-7a1a-4ed2-871e-8da5182236a7)

#### Clock:

![Screenshot 2024-08-22 004337](https://github.com/user-attachments/assets/1c16c26d-24d3-4c3b-a909-8642e063b52a)

#### Out[9:0]:

![Screenshot 2024-08-22 004456](https://github.com/user-attachments/assets/a020679d-8a50-49f0-8721-470693ab9c91)

</details>

---

<details>
  
  <summary><strong>Lab 8:</strong></summary>

# Integrating and Validating a Custom RISC-V Processor (rvmyth) within the BabySoC Platform

The goal is to integrate the custom RISC-V processor, known as rvmyth, into the BabySoC platform and validate its functionality using advanced digital design and simulation tools. This process involves generating DAC (Digital-to-Analog Converter) and PLL (Phase-Locked Loop) waveforms for the RISC-V processor to ensure proper performance and accuracy.<br>

### Phase-Locked Loop(PLL)

A Phase-Locked Loop (PLL) is an electronic control system designed to generate an output signal that maintains phase alignment with an input signal. Commonly employed in telecommunications, radio, and computing, PLLs are crucial for tasks such as signal synchronization, frequency stabilization, and clock generation in digital circuits.<br>

### Acquire and Set Up Project Files

You can download all the files for BabySoC using the following command.
```it clone https://github.com/manili/VSDBabySoC.git```

![image](https://github.com/user-attachments/assets/f6db64f9-0b0b-4a37-a277-505600d4c550)

### Verilog Code:
![image](https://github.com/user-attachments/assets/6b3ef4d5-6a5d-4ed3-bcea-585c28fb63c3)


### Changing top level verlog code:
### Simulation procedure:
You can execute a functional simulation by using the following command:
```
cd BabySoC_Simulation
iverilog -o ./pre_synth_sim.out -DPRE_SYNTH_SIM src/module/testbench.v -I src/include -I src/module/
./pre_synth_sim.out
gtkwave pre_synth_sim.vcd
```
### Final Results:
#### Waveforms:
Final Result waveform (with PLL output signal, rvmyth 10-bit output signal, DAC output analog waveform):<br>

![Screenshot from 2024-09-02 23-46-35](https://github.com/user-attachments/assets/b1a5eb2e-ef4b-46d6-aff4-40915ece677a)

Reset Waveform:
![Screenshot from 2024-09-02 23-46-24](https://github.com/user-attachments/assets/9af14ba2-c427-4318-a43d-f59700740dc2)

Clock waveform as clk_asr along with PLL clk:
![Screenshot from 2024-09-02 23-45-45](https://github.com/user-attachments/assets/a527488e-86f7-454f-81da-7e9dd399d619)


  
</details>

---


  
  <summary><strong>Lab 9:</strong></summary>
	
  <details>
	  <summary><strong>Day 1:Introduction to Verilog RTL design and Synthesis.</strong></summary>

## Introduction to iverilog
#### RTL Design and Simulation with Icarus Verilog

In digital circuit design, **Register-Transfer Level (RTL)** is an abstraction used to model synchronous digital circuits by describing the flow of data between hardware registers and the logic operations applied to these signals. This RTL abstraction is expressed using **HDL (Hardware Description Language)** to create high-level models, which are later transformed into lower-level representations and, ultimately, the physical hardware design.

#### Simulator

A tool used to verify the circuit design. In this workshop, we use the **Icarus Verilog (iverilog)** tool. Simulation involves creating models that mimic the behavior of the target device (simulation models) and using test models to validate the device (test benches). RTL design is typically composed of one or more Verilog files that specify the design’s functionality and requirements.

#### Test Bench

A setup that delivers stimulus (test vectors) to the design, verifying its behavior and ensuring it meets the required specifications.

### HOW SIMULATOR WORKS

A **Simulator** monitors changes in input signals and evaluates the output based on those changes. If an input changes, the output is recalculated; otherwise, the simulator does not perform any output evaluation.

![image](https://github.com/user-attachments/assets/689de58b-fc93-4d8e-ab7e-ed6140ef3738)

The **Design** can include one or more primary inputs and outputs, while the **testbench** does not have primary inputs or outputs.

### Simulation flow
![image](https://github.com/user-attachments/assets/d2ed9c58-161d-4143-8981-3b17af233854)

## Labs Introduction
### ENVIRONMENT SETUP

Set up the tool flow using the below commands:

```
mkdir VLSI

cd VLSI

git clone https://github.com/kunalg123/vsdflow.git

git clone https://github.com/kunalg123/sky130RTLDesignAndSynthesisWorkshop.git

cd sky130RTLDesignAndSynthesisWorkshop
```

![image](https://github.com/user-attachments/assets/b631a0f1-6975-45e0-a1ed-74e1618f4dae)

The `sky130RTLDesignAndSynthesisWorkshop` directory contains the `My_Lib` folder, which includes all necessary library files. The `lib` folder provides the standard cell libraries required for synthesis, while the `verilog_model` folder contains the Verilog models for the standard cells in the library. The `verilog_files` folder holds all lab session experiments, featuring both the Verilog code and the corresponding testbench files.

## Labs using iverilog & gtkwave
### Simulation using iverilog simulator - 2:1 multiplexer rtl design

#### VERILOG FILE OF A SIMPLE 2:1 MUX

To compile the verilog and testbench file use the following commands which will generate an executable file and will dump the waveform to view it using the gtkwave

```
iverilog good_mux.v tb_good_mux.v

./a.out

gtkwave tb_good_mux.vcd
```

We can view the waveform of a simple 2:1 mux which selects the input based on the select line
![image](https://github.com/user-attachments/assets/2ef0bf56-6924-495b-8c37-eda3e3780063)

#### Access Module Files
To view the contents of the **good_mux** file run the following command
```
 vim tb_good_mux.v -o good_mux.v 
```
![image](https://github.com/user-attachments/assets/1b12fabf-9473-46bb-9991-7edec85ba2ce)

## Introduction to Yosys & Logic Synthesis

**Synthesizer** is a tool for converting the **RTL** to Netlist and here we are using the **Yosys** Synthesizer.

### Yosys SETUP

![image](https://github.com/user-attachments/assets/9116e680-2c02-46af-a578-4a6c9cb1cd05)
### Verifying the Synthesis
![image](https://github.com/user-attachments/assets/2f6a6d15-3ca7-4cd0-9575-689a3cdbc990)
**Note**:- The set of Primary inputs / primary outputs will remain the same between the RTL design and Synthesis so we can use the same testbench.

## Logic Synthesis

**RTL Design** represents the behavioral specification using HDL (Hardware Description Language).

### Synthesis

Synthesis involves translating the RTL design into a gate-level representation. The design is converted into gates with appropriate connections, producing a file called the **netlist**.

### Liberty (.lib)

The **Liberty (.lib)** file contains a set of logical modules, including various logic gates such as AND, OR, and NOT, with multiple configurations like 2-input, 3-input, and 4-input versions. It also offers different speed options, such as slow, medium, and fast cells. Fast cells cater to high-performance requirements but may increase area and power usage, potentially causing hold time violations. Conversely, relying too heavily on slower cells can reduce performance. The synthesis process aims to select the optimal cells based on constraints to achieve a balance between area, power, and timing.

![image](https://github.com/user-attachments/assets/53f846e8-049d-433c-9e49-6691e6d7fdd5)

### Faster Cells and Slower Cells

The delay of a cell in a digital circuit is affected by the load, which is determined by the capacitance. Faster charging or discharging of this capacitance results in a lower cell delay.

To accelerate the charging/discharging process, wider transistors are used, as they provide more current, thus reducing cell delay. However, using wider transistors also increases power consumption and occupies more area. Conversely, narrower transistors help save area and reduce power consumption but result in higher cell delay. Therefore, minimizing cell delay requires balancing the trade-off between area, power, and performance.
![image](https://github.com/user-attachments/assets/65b42fd9-9720-4dc9-ba70-1702ff2d245c)
## Yosys flow

**1.**  start yosys.
          
```
yosys
```
![image](https://github.com/user-attachments/assets/98fcf243-64b2-4b6a-be45-7ddeabe8398e)
**2.** load the sky130 standard library.
```
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog good_mux.v
```
![image](https://github.com/user-attachments/assets/c92c6ba6-2320-4179-a63a-bc04582e61cc)
**3.** Synthesize the top level module
```
synth -top good_mux
```
![image](https://github.com/user-attachments/assets/c537abb3-a9f3-4705-80da-5fcd45fbcb57)
**4.** Map to the standard library
```
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
```
![image](https://github.com/user-attachments/assets/16ee2bb3-18ee-4023-b44e-207212bac215)
**6.** Two view the result as a graphich use the show command.
```
show
```
![image](https://github.com/user-attachments/assets/b7219fac-8013-45f7-98f3-930a41647f8f)
**7.** To write the result netlist to a file use the write_veriog command. This will output the netlist to a file in the current directory.
```
write_verilog -noattr good_mux_netlist.v
```
![image](https://github.com/user-attachments/assets/1a67427e-169b-4fba-ab14-27bfd22e5842)

</details>

<details>
  <summary><strong>Day 2:</strong>Timing libs, hierarchical vs flat synthesis and efficient flop coding styles.</strong></summary>

## Introduction to timing labs

Run the following commands to view the contents inside the .lib file:

```
cd VLSI/sky130RTLDesignAndSynthesisWorkshop/lib/

vim sky130_fd_sc_hd__tt_025C_1v80.lib

```
![image](https://github.com/user-attachments/assets/ee7228b4-511e-4c2f-b593-7e47401c0856)
#  Cell library
 A standard cell library is a collection of characterized logic gates that can be used to implement digital circuits. The Liberty (.lib) files contain PVT parameters (Process, Voltage, Temperature) that can significantly impact circuit performance. Variations in manufacturing, changes in voltage, and fluctuations in temperature all play a role in affecting how the circuit functions.
![image](https://github.com/user-attachments/assets/5f97291a-365c-481d-b403-27f8cfc836b1)<br>

We can also find various flavours of AND gate<br>
![image](https://github.com/user-attachments/assets/94bedc7f-a3ee-4dfb-9f0b-06da6385831a)<br>
![image](https://github.com/user-attachments/assets/025b64b5-7541-4a0e-b052-6cdf864c7020)<br>
![image](https://github.com/user-attachments/assets/27c4fe75-0ded-450f-99b2-1b33da878033)<br>
We can observe that:
* and2_0 -- takes the least area, more delay and low power.
* and2_1 -- takes more area, less delay and high power.
* and2_2 -- takes the largest area, larger delay and highest power.

## Hierarchial synthesis vs Flat synthesis 

Hierarchical synthesis involves breaking down a complex design into various sub-modules, each of which is synthesized separately to produce gate-level netlists before being integrated. This approach enhances organization, allows for module reuse, and enables incremental design changes without impacting the entire system. In contrast, flat synthesis treats the entire design as a single unit during the synthesis process, resulting in a single netlist regardless of any hierarchical relationships. While flat synthesis can optimize certain designs, it becomes difficult to maintain, analyze, and modify the design due to its absence of structural modularity.

### Hierarchial synthesis  

Consider the verilog file ```multiple_modules.v``` which is given in the verilog_files directory
```
module sub_module2 (input a, input b, output y);
    assign y = a | b;
endmodule

module sub_module1 (input a, input b, output y);
    assign y = a&b;
endmodule


module multiple_modules (input a, input b, input c , output y);
    wire net1;
    sub_module1 u1(.a(a),.b(b),.y(net1));  //net1 = a&b
    sub_module2 u2(.a(net1),.b(c),.y(y));  //y = net1|c ,ie y = a&b + c;
endmodule
```
To perform hierarchical synthesis on the ```multiple_modules.v ``` file use the following commands:
```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog multiple_modules.v

synth -top multiple_modules

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show multiple_modules

write_verilog -noattr multiple_modules_hier.v

!vim multiple_modules_hier.v

```
When you do synth -top 'topmodulename' in yosys, it does an hierarchical synthesis. ie the different hierarchies between modules are preserved.
![image](https://github.com/user-attachments/assets/bbc25345-5b46-4aff-96c0-7782b249a9b8)

### Statistics of multiple modules:
![image](https://github.com/user-attachments/assets/f7c794af-8e0c-40a8-8532-12a1f7396a1c)

### Realization of logic:
![image](https://github.com/user-attachments/assets/ad4367db-e277-41fb-bf6f-015ed462c4eb)
### Map to the standard library:
![image](https://github.com/user-attachments/assets/1abd7ffe-5620-402c-931b-5c1488b01f9e)
### Netlist file:
![image](https://github.com/user-attachments/assets/42c970b2-c97e-4188-9303-5aae4048b008)

#### Flat synthesis  
Merges all hierarchical modules in the design into a single module to create a flat netlist. To perform flat synthesis on the ```multiple_modules.v``` file type the following commands:
```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog multiple_modules.v

synth -top multiple_modules

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

flatten

show

write_verilog -noattr multiple_modules_flat.v

!vim multiple_modules_flat.v
```

![image](https://github.com/user-attachments/assets/3cd803ee-13a4-4013-b5d0-044d5fcbd460)<br>

### Realization logic:
![image](https://github.com/user-attachments/assets/5d6b7ba3-2c49-48bf-a1f2-3f59e7646dfd) <br>

### Netlist file
![image](https://github.com/user-attachments/assets/98561a8f-c365-49d4-86ff-35076a95a34b)
### Sub Module Level Synthesis
This method is preferred when multiple instances of same module are used. The synthesis is carried out once and is replicate multiple times, and the multiple instances of the same module are stitched together in the top module. This method is helpful when making use of divide and conquer algorithm


 ```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog multiple_modules.v

synth -top sub_module1

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show
```
![image](https://github.com/user-attachments/assets/79532c31-04f6-43e6-8475-562a54727dd0)<br>
### Realization of the logic
![image](https://github.com/user-attachments/assets/94572252-bf2c-42cc-894b-1e1b006e593c) <br>

## Flop coding styles and optimization

Flip-Flops are an essential part of sequential logic in a circuit and here we explore the design and synthesis of various types of flip-flops. To prevent glitches in digital circuits, we use flip-flops to store intermediate values. This ensures that combinational circuit inputs remain stable until the clock edge, avoiding glitches and maintaining correct operation:

### Asynchronous Reset/set:

**Verilog Code for Asynchronous Reset:**

```
module dff_asyncres ( input clk ,  input async_reset , input d , output reg q );
always @ (posedge clk , posedge async_reset)
begin
	if(async_reset)
		q <= 1'b0;
	else	
		q <= d;
end
endmodule
```
**Verilog Code Asynchronous Set:**

```
module dff_async_set ( input clk ,  input async_set , input d , output reg q );
always @ (posedge clk , posedge async_set)
begin
	if(async_set)
		q <= 1'b1;
	else	
		q <= d;
end
endmodule
```

In this design, the `always` block is triggered by changes in the clock or the reset signal. The circuit is sensitive to the positive edge of the clock. When the reset/set signal goes low or high, the signal on the `q` line changes accordingly. Therefore, the behavior associated with the reset/set occurs immediately and does not wait for the positive edge of the clock.

### Synchronous Reset:

```
module dff_syncres ( input clk , input async_reset , input sync_reset , input d , output reg q );
always @ (posedge clk )
begin
	if (sync_reset)
		q <= 1'b0;
	else	
		q <= d;
end
endmodule
```

#### FLIP FLOP SIMULATION

```
iverilog dff_asyncres.v tb_dff_asyncres.v 

ls

./a.out

gtkwave tb_dff_asyncres.vcd
```
![image](https://github.com/user-attachments/assets/99392de5-3452-4fb0-aa51-12e6d6bec1ee) <br>

### GTK WAVE OF ASYNCHRONOUS RESET:<br>
![image](https://github.com/user-attachments/assets/58fa8659-6a19-4e2f-b18a-83158a431184) <br>

### GTK WAVE OF ASYNCHRONOUS SET<br>
![image](https://github.com/user-attachments/assets/20269f6c-3bbd-476c-bcaa-d1dc960560ed)<br>


### GTK WAVE OF SYNCHRONOUS RESET<br>
![image](https://github.com/user-attachments/assets/cbffec19-9f5c-49db-a690-7b5358b6662d) <br>

#### FLIP FLOP SYNTHESIS

```

yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog dff_asyncres.v

synth -top dff_asyncres

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show 
```
**Statistics of D FLipflop with Asynchronous Reset**
![image](https://github.com/user-attachments/assets/60b98e53-17bd-4b91-aad6-4b43dc976551) <br>

![image](https://github.com/user-attachments/assets/bfd8dfa5-cf05-4c10-84c1-da1d3ebfe97d) <br>

**Realization of Logic**
![image](https://github.com/user-attachments/assets/1769272a-142f-4dea-942b-e53cd5151b8f) <br>

**Statistics of D FLipflop with Asynchronous set**\
Follow the same steps as given above just the file name changes to dff_async_set.v<br>

![image](https://github.com/user-attachments/assets/0ebe0be9-3a62-426e-b9d6-dcd2d62aae04)<br>
![image](https://github.com/user-attachments/assets/9c974ced-9522-4410-ab2a-ecbce6f7fe4a)<br>


### Realization Logic:
![image](https://github.com/user-attachments/assets/c4f0a4b6-405d-415d-bee6-276b4b929713)<br>

**Statistics of D FLipflop with Synchronous Reset**

![image](https://github.com/user-attachments/assets/57fa0386-4d90-4fcb-960a-7924959edcb0) <br>
![image](https://github.com/user-attachments/assets/cdfd385c-594e-4592-ba28-07064fa50010) <br>


### Realization logic:
![image](https://github.com/user-attachments/assets/0f9b2165-070b-4411-8a2b-85bf532f7872)<br>


## Optimizations

### Example 1: mult_2.v 

**verilog code**

```
module mul2 (input [2:0] a, output [3:0] y);
assign y = a * 2;
endmodule
```

**truth table**

![image](https://github.com/user-attachments/assets/d6fe75f5-2a8b-4466-a50d-3b723d32d12b) <br>
We can see the multiplication of a number by 2 doesnt really need any extra hardware we just need to append the LSB's with zeroes and the remaining bits are the input bits of same, It can be realised by grouding the LSB's and wiring the input properly to the output.

Run the below code to view the netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog mult_2.v

synth -top mult2

abc -liberty ../my_lib/lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show 

write_verilog -noattr mult_2_net.v

!vim mult_2_net.v
```
**Statistics**


### Realization logic:
![image](https://github.com/user-attachments/assets/e8906ab2-a50b-4a0e-8c36-b024bd875c1f)<br>

### Netlist:
![image](https://github.com/user-attachments/assets/db991512-2850-4f44-baa0-9e434137804f)<br>

### Example 2: mult_8.v

**verilog code**

```
module mult8 (input [2:0] a , output [5:0] y);
	assign y = a * 9;
endmodule
```

**logic behaviour**
![image](https://github.com/user-attachments/assets/b23f4794-c024-4b5b-be27-54359e6b1521) <br>

In this design the 3-bit input number "a" is multiplied by 9 i.e (a9) which can be re-written as (a8) + a . The term (a8) is nothing but a left shifting the number a by three bits. Consider that a = a2 a1 a0. (a8) results in a2 a1 a0 0 0 0. (a9)=(a8)+a = a2 a1 a0 a2 a1 a0 = aa(in 6 bit format). Hence in this case no hardware realization is required. The synthesized netlist of this design is shown below:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog mult_8.v

synth -top mult8

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr mult_8_net.v

```

**Statestics**
![image](https://github.com/user-attachments/assets/9b2fcb4a-bb33-408b-aaaa-d11855b1d980)


**Realization logic**
![image](https://github.com/user-attachments/assets/fb3d927b-3d7d-4b98-9d52-090d1d533e64)

**Netlist**
![image](https://github.com/user-attachments/assets/d3a4552a-2ef6-4397-8d19-0a8d2ebe410a)


  
</details>

<details>
 <summary><strong>Day 3:Introduction to Combinational and sequential optimizations.</strong></summary>

##  Introduction to Combinational Logic Optimization and sequential Optimization
There are two types of optimisations: Combinational and Sequential optimisations. These optimisations are done inorder to achieve designs that are efficient in terms of area, power, and performance.

**Combinational Optimization**

The techiniques used are:

- Constant Propagation (Direct Optimisation)
- Boolean Logic Optimisation (using K-Map or Quine McCluskey method)

**Constant Propagation:**

Consider the below circuit:<br>
![image](https://github.com/user-attachments/assets/41613684-804c-4202-b6e1-417ec4dfe02f) <br>

The top circuit uses 6 transistors (3 NMOS and 3 PMOS), while the bottom circuit uses 2 transistors (1 NMOS and 1 PMOS) when input A is set to zero, turning the logic into an inverter.

**Boolean Logic Optimisation:**

Consider the below verilog code:

```assign y = a?(b?c:(c?a:0)):(!c)```

The ternary operator (?:) will make the circuit behave like a mux upon synthesis as shown below.<br>

![image](https://github.com/user-attachments/assets/d32a85cd-d117-457d-ad6b-b4a7c18a0a7a) <br>

The circuit can be optimised as follows:<br>
![image](https://github.com/user-attachments/assets/e643fe2d-2c79-4cdb-8e55-a747ea81161f) <br>

**Example 1:**

Verilog code:

```
module opt_check (input a , input b , output y);
	assign y = a?b:0;
endmodule
```

The above code infers a multiplexer and since one of the inputs of the multiplexer is always connected to the ground it will infer an AND gate on optimisation.

Run the following commands for netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog opt_check.v

synth -top opt_check

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr opt_check_net.v

!vim opt_ckeck_net.v
```
### Realization logic:
![image](https://github.com/user-attachments/assets/6afa61c9-8423-4087-82ee-4d5f98ac7ecc) <br>

### Netlist:<br>
![image](https://github.com/user-attachments/assets/0bbe5fc3-fea1-49a2-90d9-ac3211d6805a)

**Example 2:**

Verilog code:

```
module opt_check2 (input a , input b , output y);
	assign y = a?1:b;
endmodule
```

Since one of the inputs of the multiplexer is always connected to the logic 1 it will infer an OR gate on optimisation.The OR gate will be NAND implementation since NOR gate has stacked pmos while NAND implementation has stacked nmos.

Run the below code for netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog opt_check2.v

synth -top opt_check2

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr opt_check2_net.v

!vim opt_ckeck2_net.v
```
![image](https://github.com/user-attachments/assets/99cf0c0f-7c17-4899-8656-d4f02e609856) <br>

![image](https://github.com/user-attachments/assets/b4336216-bde9-4e58-8338-5dadd1ba50bc) <br>

**Example 3:**

Verilog code:

```
module opt_check3 (input a , input b, input c , output y);
	assign y = a?(c?b:0):0;
endmodule
```

On optimisation the above design becomes a 3 input AND gate.

Run the below code for netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog opt_check3.v

synth -top opt_check3

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr opt_check3_net.v

!vim opt_ckeck3_net.v
```

![image](https://github.com/user-attachments/assets/e517b643-27c3-4e31-920a-2a34672a1671) <br>

![image](https://github.com/user-attachments/assets/6407abf8-0e7b-4f8a-af78-3ad422436b39) <br>

**Example 4:**

Verilog code:

```
module opt_check4 (input a , input b, input c , output y);
	assign y = a?(c?b:0):0;
endmodule
```

On optimisation the above design becomes a 2 input XNOR gate.

Run the below code for netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog opt_check4.v

synth -top opt_check4

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr opt_check4_net.v

!vim opt_ckeck4_net.v
```

![image](https://github.com/user-attachments/assets/57cf9621-f604-45d5-8ecd-5c131cb43a5b) <br>

![image](https://github.com/user-attachments/assets/1b8c0d4f-fedc-4a9a-97f4-bff527f45cde) <br>

**Example 5:**

Verilog code:

```
module sub_module1(input a , input b , output y);
 assign y = a & b;
endmodule

module sub_module2(input a , input b , output y);
 assign y = a^b;
endmodule

module multiple_module_opt(input a , input b , input c , input d , output y);
wire n1,n2,n3;

sub_module1 U1 (.a(a) , .b(1'b1) , .y(n1));
sub_module2 U2 (.a(n1), .b(1'b0) , .y(n2));
sub_module2 U3 (.a(b), .b(d) , .y(n3));

assign y = c | (b & n1); 

endmodule
```

On optimisation the above design becomes a AND OR gate

Run the below code for netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog multiple_module_opt.v

synth -top multiple_module_opt

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

flatten

show

write_verilog -noattr multiple_module_opt_net.v

!vim multiple_module_opt_net.v
```
![image](https://github.com/user-attachments/assets/51b4651c-3c03-4b1b-99be-88e552097e13)<br>

![image](https://github.com/user-attachments/assets/9be634ac-37bc-4d9c-8a85-e6cb7df15f70) <br>

**Example 6:**

Verilog code:

```
module sub_module(input a , input b , output y);
	assign y = a & b;
endmodule

module multiple_module_opt2(input a , input b , input c , input d , output y);
		wire n1,n2,n3;
	sub_module U1 (.a(a) , .b(1'b0) , .y(n1));
	sub_module U2 (.a(b), .b(c) , .y(n2));
	sub_module U3 (.a(n2), .b(d) , .y(n3));
	sub_module U4 (.a(n3), .b(n1) , .y(y));
endmodule
```

On optimisation the above design becomes Y=0 

Run the below code for netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog multiple_module_opt2.v

synth -top multiple_module_opt2

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

flatten

show

write_verilog -noattr multiple_module_opt2_net.v

!vim multiple_module_opt_net2.v
```

![image](https://github.com/user-attachments/assets/d59918dd-ef65-4aed-9c51-949b14dd5323) <br>

![image](https://github.com/user-attachments/assets/c079cea2-d20c-4024-b63b-77b4404ba28e) <br>



## Sequential Logic Optimizations

**Example 1:**

Verilog code:

```
module dff_const1(input clk, input reset, output reg q);
always @(posedge clk, posedge reset)
begin
	if(reset)
		q <= 1'b0;
	else
		q <= 1'b1;
end
endmodule
```

Run the below code for netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog dff_const1.v

synth -top dff_const1

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr dff_const1_net.v

!vim dff_const1_net.v
```

![image](https://github.com/user-attachments/assets/21083494-712e-4f90-a45e-0e28af4a6cc7) <br>

![image](https://github.com/user-attachments/assets/ff9b80be-db8c-414d-9d90-05e61b234e62) <br>

GTKWave Output:

```
iverilog dff_const1.v tb_dff_const1.v

./a.out

gtkwave tb_dff_const1.vcd

```

![image](https://github.com/user-attachments/assets/12d92a44-fc85-4bb4-9387-5af636e37165) <br>

**Example 2:**

Verilog code:

```
module dff_const2(input clk, input reset, output reg q);
always @(posedge clk, posedge reset)
begin
	if(reset)
		q <= 1'b1;
	else
		q <= 1'b1;
end
endmodule
```

Run the below code for netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog dff_const2.v

synth -top dff_const2

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr dff_const2_net.v

!vim dff_const2_net.v
```
![image](https://github.com/user-attachments/assets/e63b82a2-7acf-488f-a1c4-5bb0abc49851)<br>
![image](https://github.com/user-attachments/assets/9aab9bd0-5166-4d81-9aa9-b26136f9f9f5)<br>


GTKWave Output:

```
iverilog dff_const2.v tb_dff_const2.v

./a.out

gtkwave tb_dff_const2.vcd
```

![image](https://github.com/user-attachments/assets/f9b1918e-c301-47e5-956e-491ea018266c) <br>

**Example 3:**

Verilog code:

```
module dff_const3(input clk, input reset, output reg q);
reg q1;

always @(posedge clk, posedge reset)
begin
	if(reset)
	begin
		q <= 1'b1;
		q1 <= 1'b0;
	end
	else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end
endmodule
```

Run the below code for netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog dff_const3.v

synth -top dff_const3

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr dff_const3_net.v
```
![image](https://github.com/user-attachments/assets/6ab05acd-7804-4747-a8e5-5f6dd445cd0f) <br>
![image](https://github.com/user-attachments/assets/2ccb1385-fe02-486f-826a-dd1258d6fdb6) <br>


GTKWave Output:

```
iverilog dff_const3.v tb_dff_const3.v

./a.out

gtkwave tb_dff_const3.vcd
```
![image](https://github.com/user-attachments/assets/eeff10a5-2baa-49ef-b639-1cd6198445c4)<br>

**Example 4:**

Verilog code:

```
module dff_const4(input clk, input reset, output reg q);
reg q1;

always @(posedge clk, posedge reset)
begin
	if(reset)
	begin
		q <= 1'b1;
		q1 <= 1'b1;
	end
else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end
endmodule
```

Run the below code for netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog dff_const4.v

synth -top dff_const4

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr dff_const4_net.v
```

![image](https://github.com/user-attachments/assets/36eab097-2ac4-4d7c-8b69-fd8c953362e2) <br>
![image](https://github.com/user-attachments/assets/a2d85b49-e968-421c-b16a-c15fb132cd1a) <br>


 
GTKWave Output:

```
iverilog dff_const4.v tb_dff_const4.v

./a.out

gtkwave tb_dff_const4.vcd
```
![image](https://github.com/user-attachments/assets/855ed3fc-da16-4a13-adf5-9fc3cb303b6c) <br>

**Example 5:**

Verilog code:

```
module dff_const5(input clk, input reset, output reg q);
reg q1;
always @(posedge clk, posedge reset)
	begin
		if(reset)
		begin
			q <= 1'b0;
			q1 <= 1'b0;
		end
	else
		begin
			q1 <= 1'b1;
			q <= q1;
		end
	end
endmodule
```

Run the below code for netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog dff_const5.v

synth -top dff_const5

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr dff_const5_net.v
```
![image](https://github.com/user-attachments/assets/3252450a-1435-448d-b21e-87edf5bc05cf) <br>
![image](https://github.com/user-attachments/assets/2e1c56d9-752f-4d9e-baa3-64c8c07662e0) <br>


GTKWave Output:

```
iverilog dff_const5.v tb_dff_const5.v

./a.out

gtkwave tb_dff_const5.vcd
```

![image](https://github.com/user-attachments/assets/6902ac4a-f792-452c-be73-23f1916b54a9) <br>


**Sequential Logic Optimizations for unused outputs**

**Example 1:**

Verilog code:

```
module counter_opt (input clk , input reset , output q);
reg [2:0] count;
assign q = count[0];
always @(posedge clk ,posedge reset)
begin
	if(reset)
		count <= 3'b000;
	else
		count <= count + 1;
end
endmodule
```

Run the below code for netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog counter_opt.v

synth -top counter_opt

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr counter_opt_net.v
```
![image](https://github.com/user-attachments/assets/84229380-c453-449e-b560-2404b746d241)<br>
![image](https://github.com/user-attachments/assets/3061662e-430b-40bc-baba-5e6a75def8e5)<br>


GTKWave Output:

```
iverilog counter_opt.v tb_counter_opt.v

./a.out

gtkwave tb_counter_opt.vcd
```
![image](https://github.com/user-attachments/assets/6d3d342c-0d1d-45c0-9bdc-14f827df54d1) <br>


Modified counter logic:

Verilog code:

```
module counter_opt (input clk , input reset , output q);
reg [2:0] count;
assign q = {count[2:0]==3'b100};
always @(posedge clk ,posedge reset)
begin
if(reset)
	count <= 3'b000;
else
	count <= count + 1;
end
endmodule
```
Run the below code for netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog counter_opt.v

synth -top counter_opt

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr counter_opt_net.v

```
![image](https://github.com/user-attachments/assets/78cd2bc5-1cea-4917-8c30-b016ad19a253) <br>

![image](https://github.com/user-attachments/assets/89b0aa0f-b511-4790-84ac-f0fe5dfb1512) <br>
 



GTKWave Output:

```
iverilog counter_opt.v tb_counter_opt.v

./a.out

gtkwave tb_counter_opt.vcd
```

![image](https://github.com/user-attachments/assets/7c6a699d-615b-4d35-92cf-9df3bbe24b5e) <br>


</details>

<details>
	<summary><strong>Day 4:</strong> GLS, blocking vs non-blocking and Synthesis-Simulation mismatch.</strong></summary>
 
## Introduction to GLS and Synthesis-Simulation mismatch

Gate Level Simulation (GLS) is an important step in verifying digital circuits. It simulates the synthesized netlist, a lower-level representation of the design, using a testbench to check its logical accuracy and timing behavior. By comparing the simulation outputs with expected results, GLS ensures the synthesis process hasn't introduced any errors and that the design meets performance requirements.

Sensitivity lists are key for ensuring correct circuit behavior. An incomplete sensitivity list can result in unintended latches. Blocking and non-blocking assignments in `always` blocks behave differently, and improper use of blocking assignments can inadvertently create latches, leading to mismatches between synthesis and simulation. To prevent this, it's crucial to carefully review the circuit behavior and ensure the sensitivity list and assignments match the intended functionality.

![image](https://github.com/user-attachments/assets/42f9c6df-5016-474c-85ab-23bcefaee7b8)

**Example 1:**

Verilog code:

```
module ternary_operator_mux (input i0 , input i1 , input sel , output y);
assign y = sel?i1:i0;
endmodule
```

Simulation:

```
iverilog ternary_operator_mux.v tb_ternary_operator_mux.v

./a.out

gtkwave tb_ternary_operator_mux.vcd

```
![image](https://github.com/user-attachments/assets/8a3fbf82-569c-49e4-81e7-6df6827eaf01)

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog ternary_operator_mux.v

synth -top ternary_operator_mux

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr ternary_operator_mux_net.v

```
![image](https://github.com/user-attachments/assets/bba1f99b-0b45-43df-99e4-7cd4e9bc83bd) <br>
![image](https://github.com/user-attachments/assets/eb2b5876-abbe-41c4-b01f-409e5e14e936) <br>
![image](https://github.com/user-attachments/assets/4ce23e72-7bf6-401d-b159-bf89656d79c9) <br>

LS:

```
iverilog ../my_lib/verilog_model/primitives.v ../my_lib/verilog_model/sky130_fd_sc_hd.v ternary_operator_mux_net.v tb_ternary_operator_mux.v

./a.out

gtkwave tb_ternary_operator_mux.vcd
```
![image](https://github.com/user-attachments/assets/02f518d7-257f-43bc-964d-d563f95d7084) <br>

In this case there is no mismatch between the waveforms before and after synthesis.

**Example 2:**

Verilog code:

```
module bad_mux (input i0 , input i1 , input sel , output reg y);
always @ (sel)
begin
	if(sel)
		y <= i1;
	else 
		y <= i0;
end
endmodule
```

Simulation:

```
iverilog bad_mux.v tb_bad_mux.v

./a.out

gtkwave tb_bad_mux.vcd
```
![image](https://github.com/user-attachments/assets/ce260cb7-9a03-4887-971f-81a09ed8a0ef)



Netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog bad_mux.v

synth -top bad_mux

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr bad_mux_net.v

```
![image](https://github.com/user-attachments/assets/a02528c3-6ae3-4881-a64e-42c03d98c579)<br>
![image](https://github.com/user-attachments/assets/db013b4f-e4bc-462f-b9cc-8ee53f55870d)<br>
![image](https://github.com/user-attachments/assets/781bd660-5eba-4aa7-92ec-c7279e7f3146)<br>


GLS:

```
iverilog ../my_lib/verilog_model/primitives.v ../my_lib/verilog_model/sky130_fd_sc_hd.v bad_mux_net.v tb_bad_mux.v

./a.out

gtkwave tb_bad_mux.vcd
```
![image](https://github.com/user-attachments/assets/6994a8b4-4c4c-4902-9c4a-e83b30874bc3)


In this case there is a synthesis and simulation mismatch. While performing synthesis yosys has corrected the sensitivity list error.
**Labs on Synthesis-Simulation mismatch for blocking statements**

Verilog code:

```
module blocking_caveat (input a , input b , input  c, output reg d); 
reg x;
always @ (*)
begin
d = x & c;
x = a | b;
end
endmodule
```

Simulation:

```
iverilog blocking_caveat.v tb_blocking_caveat.v

./a.out

gtkwave tb_blocking_caveat.vcd
```
![image](https://github.com/user-attachments/assets/4a316f28-6246-4e81-b34a-6f3498b84965)


Netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog blocking_caveat.v

synth -top blocking_caveat

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr blocking_caveat_net.v
```
![image](https://github.com/user-attachments/assets/d755dc5d-4d6d-4963-97df-a94f0f62ded0) <br>
![image](https://github.com/user-attachments/assets/0a10123d-f2b5-4d28-ac82-22ab964ffe56) <br>
![image](https://github.com/user-attachments/assets/05525a75-de34-43d6-a178-6bae07128d30) <br>


GLS:

```
iverilog ../my_lib/verilog_model/primitives.v ../my_lib/verilog_model/sky130_fd_sc_hd.v blocking_caveat_net.v tb_blocking_caveat.v

./a.out

gtkwave tb_blocking_caveat.vcd
```
![image](https://github.com/user-attachments/assets/5e955b83-c5b4-4e26-9918-104c3afccefe) <br>


In this case there is a synthesis and simulation mismatch. While performing synthesis yosys has corrected the latch error.

</details>


---


<details>
	<summary><strong>Lab 10: </strong></summary>

 ## Performing RISC-V synthesis and comparing the results with functional (RTL) simulation outputs.
 Copy the src folder from your BabySoC folder to your sky130RTLDesignAndSynthesisWorkshop folder in your VLSI folder from previous lab.<br>
 ```
cd /home/rishi/VLSI/sky130RTLDesignAndSynthesisWorkshop/src/module
```
### Synthesis:
```
yosys       

read_liberty -lib /home/rishi/VLSI/sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog clk_gate.v

read_verilog rvmyth.v

synth -top rvmyth

abc -liberty /home/rishi/VLSI/sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib

write_verilog -noattr rvmyth_net.v

!gvim rvmyth_net.v

exit
```
![Screenshot from 2024-10-24 01-02-55](https://github.com/user-attachments/assets/8c010b16-c588-4634-ad5c-8f7dc24abf5f) <br>
![Screenshot from 2024-10-24 01-03-29](https://github.com/user-attachments/assets/6293ef4e-7cfd-4500-af4a-4e562b457434) <br>
![Screenshot from 2024-10-24 01-04-36](https://github.com/user-attachments/assets/9a27c85d-496a-4926-8ecb-78c2a81d3ff1) <br>

Now to observe the output waveform of synthesised RISC-V:<br>
```
iverilog ../../my_lib/verilog_model/primitives.v ../../my_lib/verilog_model/sky130_fd_sc_hd.v rvmyth.v testbench.v vsdbabysoc.v avsddac.v avsdpll.v clk_gate.v

./a.out

gtkwave dump.vcd
```
![Screenshot from 2024-10-24 03-26-53](https://github.com/user-attachments/assets/a58f5d7d-da1d-4c4f-87ed-caf3601f7b02) <br>

### Realization:
![image](https://github.com/user-attachments/assets/5ee32430-8146-4ae0-811b-d73b5868bdcf) <br>
![image](https://github.com/user-attachments/assets/71700130-4ce8-4374-8882-73fffeae77c3) <br>

## RTL Simulations:
```
cd BabySoC_Simulation

iverilog -o ./pre_synth_sim.out -DPRE_SYNTH_SIM src/module/testbench.v -I src/include -I src/module/

./pre_synth_sim.out

gtkwave pre_synth_sim.vcd
```
![Screenshot from 2024-10-24 01-14-33](https://github.com/user-attachments/assets/377ace79-5c28-42a5-9d29-de01da689e9f) <br>
![Screenshot from 2024-10-24 01-14-40](https://github.com/user-attachments/assets/f285df06-cce9-4214-a771-f4b011b6d869) <br>



 
</details>

---

<details>

 <summary><strong> Lab 11:</strong></summary>

**Static Timing Analysis (STA)**

Static Timing Analysis (STA) is a crucial verification process in digital circuit design, used to ensure that circuits adhere to timing requirements without running dynamic simulations. By evaluating the paths data travels from inputs to outputs, STA analyzes delays introduced by gate propagation and interconnects to validate that all timing constraints are met. It focuses on detecting setup and hold time violations, which ensures data stability around clock edges. STA also considers clock attributes, such as frequency, skew, and jitter, and operates under worst-case delay scenarios to ensure reliable performance under diverse conditions. Automated tools, like Synopsys PrimeTime and Cadence Tempus, streamline STA by identifying timing issues early, enabling circuits to achieve the desired operating speeds with consistent reliability.


**Register-to-Register (Reg-to-Reg) Paths**

A reg-to-reg path, which links two sequential elements like flip-flops in a circuit, is essential in STA to verify the data flow between registers through intermediate combinational logic. This path is particularly significant in pipelined or sequential architectures, as it ensures synchronized and correct data transfer. STA evaluates the timing compliance for setup and hold requirements on these paths, confirming stable data transitions at the register level. Timing analysis examines the delay through combinational logic between registers, and critical reg-to-reg paths often dictate the highest achievable operating frequency of the design. When analyzing registers across different clock domains, STA also considers synchronization requirements to mitigate potential metastability issues.

**Clock-to-Register (Clk-to-Reg) Paths**

The clk-to-reg path represents the timing relationship between a clock signal and a register, essential for coordinating register operation in line with clock edges. This path measures the delay for a clock pulse to reach a register from its clock source, accounting for buffer and routing delays along the way. During setup timing checks, the clk-to-reg path helps determine when data must arrive at a register in relation to the clock cycle. Clock delays directly impact data capture timing, so STA thoroughly examines setup and hold timing to address variations in clock jitter and other inconsistencies. For designs with multiple clock domains, additional synchronization requirements ensure that data transfers accurately and reliably across clock boundaries.

**Performing STA on a Synthesized RISC-V Core with a 10.75 ns Timing Constraint**

To confirm that a synthesized RISC-V core module meets its specified timing requirements, timing reports for setup and hold times will be generated. These reports help verify that data signals propagate as intended throughout the core and are stable at the appropriate times. The following commands can be executed to generate these reports and validate the timing integrity of the RISC-V core under the target timing period of 10.75 ns.

```
set PERIOD 10.75

set_units -time ns

create_clock [get_pins {pll/CLK}] -name clk -period $PERIOD
set_clock_uncertainty -setup  [expr $PERIOD * 0.05] [get_clocks clk]
set_clock_transition [expr $PERIOD * 0.05] [get_clocks clk]
set_clock_uncertainty -hold [expr $PERIOD * 0.08] [get_clocks clk]
set_input_transition [expr $PERIOD * 0.08] [get_ports ENb_CP]
set_input_transition [expr $PERIOD * 0.08] [get_ports ENb_VCO]
set_input_transition [expr $PERIOD * 0.08] [get_ports REF]
set_input_transition [expr $PERIOD * 0.08] [get_ports VCO_IN]
set_input_transition [expr $PERIOD * 0.08] [get_ports VREFH]
```

```
cd VSDBabySoc/src

sta

read_liberty -min ./lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_liberty -min ./lib/avsdpll.lib

read_liberty -min ./lib/avsddac.lib

read_liberty -max ./lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_liberty -max ./lib/avsdpll.lib

read_liberty -max ./lib/avsddac.lib

read_verilog ../output/synth/vsdbabysoc.synth.v

link_design vsdbabysoc

read_sdc ./sdc/vsdbabysoc_synthesis.sdc

report_checks -path_delay min_max -format full_clock_expanded -digits 4
```
![image](https://github.com/user-attachments/assets/9fa408b5-57cc-484a-8f90-a31ad2322b1b)


### Setup Time:
![WhatsApp Image 2024-10-28 at 23 59 15 (1)](https://github.com/user-attachments/assets/1872c22c-c960-47a7-b4ed-481d8836623a) <br>

### Hold Time:
![WhatsApp Image 2024-10-28 at 23 59 15](https://github.com/user-attachments/assets/c6e6dba3-f149-49da-959e-c1e04457c98e)




</details>

---


<details>
	<summary><stromg> Lab Session 12: </stromg></summary>

## STA comparison for various sky libraries
Store all the sky lib files in a folder named timing_libs. Now, go to VSDBabySoC/src and create a tickle file sta_across_pvt.tcl . The below block is the content of the tickle file:

```
set list_of_lib_files(1) "sky130_fd_sc_hd__ff_100C_1v65.lib"
set list_of_lib_files(2) "sky130_fd_sc_hd__ff_100C_1v95.lib"
set list_of_lib_files(3) "sky130_fd_sc_hd__ff_n40C_1v56.lib"
set list_of_lib_files(4) "sky130_fd_sc_hd__ff_n40C_1v65.lib"
set list_of_lib_files(5) "sky130_fd_sc_hd__ff_n40C_1v76.lib"
set list_of_lib_files(6) "sky130_fd_sc_hd__ff_n40C_1v95.lib"
set list_of_lib_files(7) "sky130_fd_sc_hd__ff_n40C_1v95_ccsnoise.lib.part1"
set list_of_lib_files(8) "sky130_fd_sc_hd__ff_n40C_1v95_ccsnoise.lib.part2"
set list_of_lib_files(9) "sky130_fd_sc_hd__ff_n40C_1v95_ccsnoise.lib.part3"
set list_of_lib_files(10) "sky130_fd_sc_hd__ss_100C_1v40.lib"
set list_of_lib_files(11) "sky130_fd_sc_hd__ss_100C_1v60.lib"
set list_of_lib_files(12) "sky130_fd_sc_hd__ss_n40C_1v28.lib"
set list_of_lib_files(13) "sky130_fd_sc_hd__ss_n40C_1v35.lib"
set list_of_lib_files(14) "sky130_fd_sc_hd__ss_n40C_1v40.lib"
set list_of_lib_files(15) "sky130_fd_sc_hd__ss_n40C_1v44.lib"
set list_of_lib_files(16) "sky130_fd_sc_hd__ss_n40C_1v60.lib"
set list_of_lib_files(17) "sky130_fd_sc_hd__ss_n40C_1v60_ccsnoise.lib.part1"
set list_of_lib_files(18) "sky130_fd_sc_hd__ss_n40C_1v60_ccsnoise.lib.part2"
set list_of_lib_files(19) "sky130_fd_sc_hd__ss_n40C_1v60_ccsnoise.lib.part3"
set list_of_lib_files(20) "sky130_fd_sc_hd__ss_n40C_1v76.lib"
set list_of_lib_files(21) "sky130_fd_sc_hd__tt_025C_1v80.lib"
set list_of_lib_files(22) "sky130_fd_sc_hd__tt_100C_1v80.lib"

for {set i 1} {$i <= [array size list_of_lib_files]} {incr i} {
read_liberty ./timing_libs/$list_of_lib_files($i)
read_verilog ../output/synth/vsdbabysoc.synth.v
link_design vsdbabysoc
read_sdc ./sdc/vsdbabysoc_synthesis.sdc
check_setup -verbose
report_checks -path_delay min_max -fields {nets cap slew input_pins fanout} -digits {4} > ./sta_output/min_max_$list_of_lib_files($i).txt

}
```
![image](https://github.com/user-attachments/assets/7f343263-2deb-4243-a5cf-e67d11651fe7) <br>


#### Constraints File:
![image](https://github.com/user-attachments/assets/59ed9229-b8c3-4faf-8ad0-7a26c335cfe8) <br>


#### Next run these commands:
```
cd VSDBabySoC/src

sta

source sta_across_pvt.tcl
```
![image](https://github.com/user-attachments/assets/0f8abd37-e082-4207-9e55-1575c863312c) <br>

#### Table:
![Screenshot from 2024-11-04 11-32-34](https://github.com/user-attachments/assets/db6f119d-f82d-4d6d-86c1-4a24857ccdaf)

### Grpahs:
#### Worst setup slack graph:

![image](https://github.com/user-attachments/assets/9ab453f4-026b-45fc-bc68-0ba2a5f1f476) <br>

#### Worst Hold Slack:
![image](https://github.com/user-attachments/assets/8a890d0b-e827-42a3-a521-5a9c554eeb30) <br>

--- 


![Screenshot from 2024-11-04 11-04-47](https://github.com/user-attachments/assets/223a43af-1fd2-4d94-b654-b3c679a8a2f0)
![Screenshot from 2024-11-04 11-04-58](https://github.com/user-attachments/assets/ca29c7a1-fb51-4e4e-b105-ec1d8a39d447)


![Screenshot from 2024-11-04 11-07-43](https://github.com/user-attachments/assets/3f30ac0e-c41b-4e86-87f0-4532a2098dda)
![Screenshot from 2024-11-04 11-07-55](https://github.com/user-attachments/assets/16cc8d74-2827-48f6-a023-f78cd880c690)


![Screenshot from 2024-11-04 11-08-35](https://github.com/user-attachments/assets/2d331878-b273-44cd-9e8c-1f6e6140ef8a)
![Screenshot from 2024-11-04 11-08-43](https://github.com/user-attachments/assets/00d8cb09-1a2f-4f19-9b70-cfd3eec25d65)


![Screenshot from 2024-11-04 11-09-31](https://github.com/user-attachments/assets/9c77f428-4e88-45dc-bf72-aae7648edb22)
![Screenshot from 2024-11-04 11-09-42](https://github.com/user-attachments/assets/651cdc97-0ac7-4b62-b390-7f9a3f9b45d6)


![Screenshot from 2024-11-04 11-13-59](https://github.com/user-attachments/assets/9b849d1b-f91a-42ca-9a67-978fe060aabb)
![Screenshot from 2024-11-04 11-14-11](https://github.com/user-attachments/assets/ed2a8188-2086-4e8b-a204-4551232b975d)


![Screenshot from 2024-11-04 11-14-56](https://github.com/user-attachments/assets/f4885e19-e441-4a6f-97b9-86e2d13f79bd)
![Screenshot from 2024-11-04 11-15-04](https://github.com/user-attachments/assets/9b8934d2-6611-489e-b4b6-c33f4864d0a2)

![Screenshot from 2024-11-04 11-16-00](https://github.com/user-attachments/assets/5678b4b5-5e3d-4cb2-a08c-6313407b707c)
![Screenshot from 2024-11-04 11-16-06](https://github.com/user-attachments/assets/e3e5dc9d-de93-48f3-b940-41fad8d07d81)

![Screenshot from 2024-11-04 11-17-12](https://github.com/user-attachments/assets/77fd232a-dc19-4dea-aa5b-ac183edb2ab1)
![Screenshot from 2024-11-04 11-17-17](https://github.com/user-attachments/assets/02b601e0-3ee7-4567-b65d-6bd6402b9b09)

![Screenshot from 2024-11-04 11-18-09](https://github.com/user-attachments/assets/a2e390de-4517-40c6-8e54-23503a2fbc3d)
![Screenshot from 2024-11-04 11-18-14](https://github.com/user-attachments/assets/0db1a7ea-e546-48b5-8363-6af4928bb041)

![Screenshot from 2024-11-04 11-18-25](https://github.com/user-attachments/assets/3b4e7519-b4da-465d-8ce1-2468657cccac)
![Screenshot from 2024-11-04 11-18-29](https://github.com/user-attachments/assets/da349a7d-2356-42b4-8919-ef2ef655ba87)

![Screenshot from 2024-11-04 11-19-08](https://github.com/user-attachments/assets/77c68902-c69d-43ba-a9d7-aebc8c1fd456)
![Screenshot from 2024-11-04 11-19-22](https://github.com/user-attachments/assets/21a1f9b6-4db9-470a-8729-a38171882aca)

![Screenshot from 2024-11-04 11-20-03](https://github.com/user-attachments/assets/5656c15b-840f-4069-ab95-1f74bea8bed8)
![Screenshot from 2024-11-04 11-20-11](https://github.com/user-attachments/assets/a2162ee2-d4a0-48d8-9b60-13eefd03ec78)

![Screenshot from 2024-11-04 11-21-12](https://github.com/user-attachments/assets/d1d5604c-4e67-45e5-a574-ca01272de1f3)
![Screenshot from 2024-11-04 11-21-20](https://github.com/user-attachments/assets/3c8b96af-89e6-41af-8cd3-dd76cf882b76)

![Screenshot from 2024-11-04 11-22-33](https://github.com/user-attachments/assets/28087c4e-d565-47f2-9d7d-fa58026bec26)
![Screenshot from 2024-11-04 11-22-40](https://github.com/user-attachments/assets/8ae38179-0203-4cb8-b295-b1dbbafc3292)

![Screenshot from 2024-11-04 11-23-06](https://github.com/user-attachments/assets/b4d2a595-8d32-4eb6-b06d-363e784d0283)
![Screenshot from 2024-11-04 11-23-16](https://github.com/user-attachments/assets/33ab755a-3b8f-4e1f-97c0-38068c888c78)

![Screenshot from 2024-11-04 11-24-02](https://github.com/user-attachments/assets/1f6ff33d-1259-428f-a416-04d356aa6865)
![Screenshot from 2024-11-04 11-24-17](https://github.com/user-attachments/assets/7d0a9b0f-38a0-482b-831d-7c696d56262d)

![Screenshot from 2024-11-04 11-24-59](https://github.com/user-attachments/assets/7dd7db91-851d-43bb-a27f-928a5b9876bf)
![Screenshot from 2024-11-04 11-25-06](https://github.com/user-attachments/assets/5fc82ac2-4882-4edd-8f1e-6c870fa58711)

![Screenshot from 2024-11-04 11-26-47](https://github.com/user-attachments/assets/501c316b-b032-4649-879a-ddfc54ed81c6)
![Screenshot from 2024-11-04 11-26-54](https://github.com/user-attachments/assets/644ed29e-ad0c-470a-bac4-2b772efd51d0)

![Screenshot from 2024-11-04 11-27-03](https://github.com/user-attachments/assets/10783767-5986-4ccf-9ac0-b22faded86ee)
![Screenshot from 2024-11-04 11-25-06](https://github.com/user-attachments/assets/0abcf8d5-6479-4853-b1c0-07da9ea192f0)

![Screenshot from 2024-11-04 11-26-47](https://github.com/user-attachments/assets/50aabd82-a4ce-4b7c-8386-20cb1ca365c7)
![Screenshot from 2024-11-04 11-26-54](https://github.com/user-attachments/assets/7d2814d5-6c97-4129-ab86-ca87d6ebf4c1)

![Screenshot from 2024-11-04 11-27-03](https://github.com/user-attachments/assets/273a977d-eb87-4d20-ac7d-0ca7516a4a35)
![Screenshot from 2024-11-04 11-27-14](https://github.com/user-attachments/assets/596bd48b-c598-42b0-b9ba-62cb797bd1f0)

![Screenshot from 2024-11-04 11-27-30](https://github.com/user-attachments/assets/78c1c00a-cec7-4fc4-96c0-d80cbbb2a6ef)
![Screenshot from 2024-11-04 11-27-43](https://github.com/user-attachments/assets/2c069b3c-a3f8-449b-b988-2f8b409f1c5c)

![Screenshot from 2024-11-04 11-28-04](https://github.com/user-attachments/assets/03f8b91a-c0b0-49ef-bd6f-9402151fdc4a)
![Screenshot from 2024-11-04 11-28-13](https://github.com/user-attachments/assets/1ba8ad67-1f45-4478-b9be-46d58d151217)

![Screenshot from 2024-11-04 11-28-55](https://github.com/user-attachments/assets/ab82f868-e5ed-4cf6-a4df-613269ddb172)
![Screenshot from 2024-11-04 11-29-02](https://github.com/user-attachments/assets/bfdba87d-8d51-451e-b1eb-7c9f195b4439)

![Screenshot from 2024-11-04 11-29-27](https://github.com/user-attachments/assets/b06748b1-dbdf-4428-bddd-89e3e31875be)
![Screenshot from 2024-11-04 11-29-34](https://github.com/user-attachments/assets/a10c1bf3-c3de-4e84-9944-ec36a965cb93)

 
</details>




<details>
	<summary><strong> Lab 13: Advanced Physical Design using OpenLane using Sky130</strong></summary>
<details>
	<summary><strong>Day 1 </strong></summary>

## The start of open-source tools for Electronic Design Automation (EDA) introduced projects like OpenLane and the Sky130 Process Design Kit (PDK).
**QFN-48 Package:** The QFN-48 is a small, leadless package with 48 connection pads along its edges. It offers great thermal and electrical performance, making it suitable for applications requiring high density.
![image](https://github.com/user-attachments/assets/71f6ddfe-f7d1-404f-979c-b96198e76899)

**Chip :** A chip is a silicon-based integrated circuit (IC) containing components like memory, processors, and input/output systems, created for specific electronic uses.
![image](https://github.com/user-attachments/assets/d93cffd1-4deb-4d23-bb5f-eaab9ded6826)

**Pads**: Tiny metal contact points on a chip or package that link internal circuits to external connections for signal transfer.  

**Core**: The central processing unit of a chip, designed for efficient power usage and high performance.  

**Die**: The part of a silicon wafer that holds a single integrated circuit (IC) before it is packaged, containing all the chip’s active components.
![image](https://github.com/user-attachments/assets/45ac0c4a-5dfd-4ac2-95dd-b5755b3f4496)

**IPs (Intellectual Properties) :**  IPs (Intellectual Properties) are pre-designed functional units, like USB controllers or memory interfaces, that are licensed for reuse in different designs, helping to reduce development time and costs.
![image](https://github.com/user-attachments/assets/92ee09f0-303c-4709-9e67-298c00004a33)

### Software to Hardware Execution Flow

When running an application on hardware, the process starts with the system software layer, which converts the application into binary form. This involves several key components:

-**OS :** It breaks down the high-level language functions (like C or Java) of the application and sends them to the compiler.
-**Compiler:** It translates the functions into low-level instructions specific to the hardware.
-**Assembler:** It converts these low-level instructions into binary code that the hardware can execute.
![image](https://github.com/user-attachments/assets/2bba4b0a-8da7-4ebd-92d1-e7255fe4192a)

For example, consider a stopwatch app running on a RISC-V core. The OS generates a function in C, which is passed to the compiler. The compiler then produces instructions specific to the RISC-V architecture. These instructions are processed by the assembler, converting them into binary code. Finally, the binary code is integrated into the chip layout, enabling the hardware to perform the desired task.
![image](https://github.com/user-attachments/assets/c8d3699c-a7f0-458e-856c-aa82523a52d8)<br>

For the above stopwatch the below figure shows the input and output of the compiler and assembler.
![image](https://github.com/user-attachments/assets/5043acc4-84c3-4edb-abc8-2075d01212f0)

The compiler generates architecture-specific instructions, which the assembler then converts into corresponding binary patterns. To run these on hardware, a Register Transfer Level (RTL) design, written in a Hardware Description Language, interprets and implements the instructions. This RTL design is synthesized into a netlist, which consists of interconnected logic gates. The netlist is then used for physical design implementation, preparing the design for chip fabrication.
![image](https://github.com/user-attachments/assets/942749d6-acd5-490c-8e21-a9d57a770b42)

### Components of ASIC Design

- **RTL IPs**: Verified circuit blocks (such as adders and flip-flops) in Hardware Description Language (HDL), used to speed up the design of complex circuits.  
- **EDA Tools**: Software that automates tasks like synthesis, optimization, and timing analysis, ensuring that the design meets performance requirements.  
- **PDK Data**: Files from semiconductor foundries that define the manufacturing process, ensuring the ASIC design is ready for fabrication.
![image](https://github.com/user-attachments/assets/2a3ca2d0-101f-43f0-b612-da70e35aade1)

---

![image](https://github.com/user-attachments/assets/a6989885-f5ec-4adf-861a-aff47a928a34)

**RTL Design**: Describes the circuit's functionality using Hardware Description Languages (HDLs) like Verilog or VHDL.  

**RTL Synthesis**: Transforms the RTL design into a gate-level netlist with optimized cells.  

**Floor and Power Planning**: Organizes the major components, power grid, and I/O.  

**Placement**: Assigns cells to locations, minimizing wire length and signal delay.  

**Clock Tree Synthesis (CTS)**: Ensures clock signals are distributed evenly to reduce skew.  

**Routing**: Connects the components while following design rules.  

**Sign-off**: Final verification to confirm the design is ready for fabrication.  

**GDSII Generation**: Creates the chip's layout for production.
![image](https://github.com/user-attachments/assets/44c126e9-91f6-4a09-ab2b-36072f1aa01d)

- **RTL Synthesis and Technology Mapping**: Uses tools like Yosys and ABC.  
- **Static Timing Analysis**: Performed using OpenSTA.  
- **Floor Planning**: Managed with tools such as init_fp, ioPlacer, pdn, and tapcell.  
- **Placement**: Handled by RePLace, Resizer, OpenPhySyn, and OpenDP.  
- **Clock Tree Synthesis**: Done using TritonCTS.  
- **Fill Insertion**: Performed with OpenDP.  
- **Routing**: Global routing uses FastRoute/CU-GR, while detailed routing is done with TritonRoute/DR-CU.  
- **SPEF Extraction**: Parasitic data is extracted using OpenRCX.  
- **GDSII Output**: Generated by Magic and KLayout.  
- **Design Rule Checks**: Conducted using Magic and KLayout.  
- **Layout vs. Schematic Check**: Done using Netgen.  
- **Antenna Checks**: Handled by Magic.

### OpenLane Directory Structure

```plaintext
├── OpenLane            # Tool directory
│   ├── designs         # Holds all designs
│   │   └── picorv32a   # Example design
├── pdks                # PDK-related files
│   ├── skywater-pdk    # Skywater 130nm PDKs
│   ├── open-pdks       # Scripts for open-source tool compatibility
│   ├── sky130A         # Open-source compatible PDK variant
│   │   ├── libs.ref    # Node-specific files (e.g., timing, tech LEF)
│   │   ├── libs.tech   # Tool-specific files (e.g., for KLayout)
```

### Running Synthesis in OpenLane:
1. **Navigate and start OpenLane**:
   ```bash
   cd Desktop/work/tools/openlane_working_dir/openlane
   docker
   ./flow.tcl -interactive
   package require openlane 0.9
   prep -design picorv32a
   run_synthesis
   ```

![image](https://github.com/user-attachments/assets/e20245e7-1fde-4664-bc76-0affc8db76ab) <br>

3. **View the Netlist**:
   ```bash
   cd designs/picorv32a/runs/13-11_14-52/results/synthesis/
   gedit picorv32a.synthesis.v
   ```
![image](https://github.com/user-attachments/assets/c3227cab-acff-4432-9f0d-4c92f91375ef)
![image](https://github.com/user-attachments/assets/8731bdb4-028f-4b39-a588-238ce3533472)

5. **Yosys Report**:
   ```bash
   cd ../..
   cd reports/synthesis
   gedit 1-yosys_4.stat.rpt
   ```

![image](https://github.com/user-attachments/assets/c5c7cf63-4b15-43f1-881c-090c9313e750)

**Report :**
```

28. Printing statistics.

=== picorv32a ===

   Number of wires:              14596
   Number of wire bits:          14978
   Number of public wires:        1565
   Number of public wire bits:    1947
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:              14876
     sky130_fd_sc_hd__a2111o_2       1
     sky130_fd_sc_hd__a211o_2       35
     sky130_fd_sc_hd__a211oi_2      60
     sky130_fd_sc_hd__a21bo_2      149
     sky130_fd_sc_hd__a21boi_2       8
     sky130_fd_sc_hd__a21o_2        57
     sky130_fd_sc_hd__a21oi_2      244
     sky130_fd_sc_hd__a221o_2       86
     sky130_fd_sc_hd__a22o_2      1013
     sky130_fd_sc_hd__a2bb2o_2    1748
     sky130_fd_sc_hd__a2bb2oi_2     81
     sky130_fd_sc_hd__a311o_2        2
     sky130_fd_sc_hd__a31o_2        49
     sky130_fd_sc_hd__a31oi_2        7
     sky130_fd_sc_hd__a32o_2        46
     sky130_fd_sc_hd__a41o_2         1
     sky130_fd_sc_hd__and2_2       157
     sky130_fd_sc_hd__and3_2        58
     sky130_fd_sc_hd__and4_2       345
     sky130_fd_sc_hd__and4b_2        1
     sky130_fd_sc_hd__buf_1       1656
     sky130_fd_sc_hd__buf_2          8
     sky130_fd_sc_hd__conb_1        42
     sky130_fd_sc_hd__dfxtp_2     1613
     sky130_fd_sc_hd__inv_2       1615
     sky130_fd_sc_hd__mux2_1      1224
     sky130_fd_sc_hd__mux2_2         2
     sky130_fd_sc_hd__mux4_1       221
     sky130_fd_sc_hd__nand2_2       78
     sky130_fd_sc_hd__nor2_2       524
     sky130_fd_sc_hd__nor2b_2        1
     sky130_fd_sc_hd__nor3_2        42
     sky130_fd_sc_hd__nor4_2         1
     sky130_fd_sc_hd__o2111a_2       2
     sky130_fd_sc_hd__o211a_2       69
     sky130_fd_sc_hd__o211ai_2       6
     sky130_fd_sc_hd__o21a_2        54
     sky130_fd_sc_hd__o21ai_2      141
     sky130_fd_sc_hd__o21ba_2      209
     sky130_fd_sc_hd__o21bai_2       1
     sky130_fd_sc_hd__o221a_2      204
     sky130_fd_sc_hd__o221ai_2       7
     sky130_fd_sc_hd__o22a_2      1312
     sky130_fd_sc_hd__o22ai_2       59
     sky130_fd_sc_hd__o2bb2a_2     119
     sky130_fd_sc_hd__o2bb2ai_2     92
     sky130_fd_sc_hd__o311a_2        8
     sky130_fd_sc_hd__o31a_2        19
     sky130_fd_sc_hd__o31ai_2        1
     sky130_fd_sc_hd__o32a_2       109
     sky130_fd_sc_hd__o41a_2         2
     sky130_fd_sc_hd__or2_2       1088
     sky130_fd_sc_hd__or2b_2        25
     sky130_fd_sc_hd__or3_2         68
     sky130_fd_sc_hd__or3b_2         5
     sky130_fd_sc_hd__or4_2         93
     sky130_fd_sc_hd__or4b_2         6
     sky130_fd_sc_hd__or4bb_2        2

   Chip area for module '\picorv32a': 147712.918400
```

**Report Summary**:

- **Flop Ratio**: The number of D flip-flops is 1,613, resulting in a flop ratio of 0.1084, calculated as:

  \[
  \frac{1613}{14876} = 0.1084
  \]

- **Wire Count**: 14,596  
- **Cell Count**: 14,876, including specific cells like `sky130_fd_sc_hd__a2111o_2`, `sky130_fd_sc_hd__and2_2`.  
- **D Flip-flops**: 1,613, contributing to a flop ratio of 0.1084.

 
</details>

<details>
	<summary><strong>Day 2 </strong></summary>

## Good Floorplan vs. Bad Floorplan and Introduction to Library Cells

### **Utilization Factor and Aspect Ratio**
In IC floor planning, two important parameters are the utilization factor and aspect ratio. The **utilization factor** is the ratio of the area occupied by the netlist to the total core area. While an ideal utilization factor is 1 (100%), practical designs aim for a factor between 0.5 and 0.6. This provides space for buffer zones, routing channels, and necessary adjustments. The **aspect ratio** is calculated by dividing the height by the width of the chip. An aspect ratio of 1 indicates a square shape, while other values result in a rectangular layout. The ratio is chosen based on functional, packaging, and manufacturing needs.

```
Utilization Factor = Area occupied by netlist
                    __________________________
                        Total area of core
                         

Aspect Ratio = Height
              ________
               Width
```

### **Pre-placed Cells**
Pre-placed cells are essential functional blocks like memory, custom processors, and analog circuits that are manually positioned in fixed locations. These cells are crucial for performance and must remain fixed during the placement and routing stages to ensure the correct functionality and layout integrity.

### **Decoupling Capacitors**
Decoupling capacitors help stabilize power supply voltages near logic circuits during transient events. Acting as local energy reserves, they minimize voltage fluctuations, reduce crosstalk, and lower electromagnetic interference (EMI), ensuring stable and reliable power delivery to sensitive circuits.

### **Power Planning**
Power planning involves creating a mesh of power and ground connections (VDD and VSS) to evenly distribute power across the chip. This setup ensures stable power delivery, minimizes voltage drops, and improves efficiency. Multiple power and ground points help meet power demands and reduce instability risks.

### **Pin Placement**
Pin placement, or I/O planning, is crucial for maintaining functionality and reliability. Proper placement of pins minimizes signal degradation, optimizes heat dissipation, and supports thermal stability. Strategically placed power and ground pins strengthen the signal and improve manufacturability.

### **Floorplanning with OpenLANE**
To initiate floorplanning in OpenLANE, execute these commands:

```
cd Desktop/work/tools/openlane_working_dir/openlane
docker
```

```
./flow.tcl -interactive
package require openlane 0.9
prep -design picorv32a
run_synthesis
run_floorplan
```
![Screenshot 2024-11-13 205427](https://github.com/user-attachments/assets/953d0ad0-ab7a-4d13-bac9-12853fafdc43)
![Screenshot 2024-11-13 205414](https://github.com/user-attachments/assets/2e1b98be-a474-449f-8d3d-b1d5e99adb4c)

Then, in a new terminal, access the floorplan file as follows:

```
cd Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/13-11_15-21/results/floorplan
gedit picorv32a.floorplan.def
```
![Screenshot 2024-11-13 211205](https://github.com/user-attachments/assets/c3c2fec5-457e-4322-9193-96b68b167ea7)

According to the floorplan definitions:

- 1000 Unit Distance = 1 Micron
- Die width in unit distance = 660685−0 = 660685  
- Die height in unit distance = 671405−0 = 671405  
- Width in microns = 660685 / 1000 = 660.685 Microns  
- Height in microns = 671405 / 1000 = 671.405 Microns  
- Die area in microns² = 660.685 × 671.405 = 443587.212425 Microns²  

To view the floorplan in Magic:

```
cd Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/13-11_15-21/results/floorplan/
magic -T /home/vsduser/Desktop/work/tools/openlane_working_dir/pdks/sky130A/libs.tech/magic/sky130A.tech lef read ../../tmp/merged.lef def read picorv32a.floorplan.def &
```
![Screenshot 2024-11-13 211458](https://github.com/user-attachments/assets/2cf5819c-1b33-49a4-b446-30ab002ea804)


**Decap and Tap Cells**
Decap cells and tap cells are placed to manage power delivery and maintain electrical connectivity across the chip.<br>
![image](https://github.com/user-attachments/assets/97b3259a-8c68-4b20-a808-85e1edd71c69) <br>

**Unplaced Standard Cells at Origin**
![image](https://github.com/user-attachments/assets/76db959a-1cd7-46f8-84d9-34aff0ff2ebe) <br>

```
./flow.tcl -interactive
package require openlane 0.9
prep -design picorv32a
run_synthesis
run_floorplan
run_placement
```
![Screenshot 2024-11-13 212427](https://github.com/user-attachments/assets/b685c451-6a07-4b6a-acd4-c893d04c77b9)



View the placement in Magic with:

```
cd Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/13-11_15-48/results/placement/
magic -T /home/vsduser/Desktop/work/tools/openlane_working_dir/pdks/sky130A/libs.tech/magic/sky130A.tech lef read ../../tmp/merged.lef def read picorv32a.placement.def &
```

![Screenshot 2024-11-13 212928](https://github.com/user-attachments/assets/ddc165a6-4b54-48a7-b08b-5581cdd95fb5)
![Screenshot 2024-11-13 212855](https://github.com/user-attachments/assets/8a848bc6-f466-41ed-a0f1-1b5e5161f80a)

### **Cell Design and Characterization Flow**
The library offers critical cell data, such as various sizes, functionalities, and threshold voltages. A typical design flow involves the following steps:

- **Inputs**: Process Design Kits (PDKs) for Design Rule Check (DRC) & Layout Versus Schematic (LVS), SPICE models, and user-defined library specifications.  
- **Steps**: The design process includes circuit design, layout design (using methods like Euler's path and stick diagrams), parasitic extraction, and characterization (timing, noise, power).  
- **Outputs**: The final outputs include CDL, LEF, GDSII, extracted SPICE netlist (.cir), and timing/noise/power .lib files.

### **Standard Cell Characterization Flow**
The standard cell characterization flow includes the following steps:

1. Reading model and technology files  
2. Loading the extracted SPICE netlist  
3. Identifying cell behavior  
4. Reading subcircuits  
5. Applying power sources  
6. Setting up stimulation for characterization  
7. Defining output capacitance loads  
8. Running simulation commands  

These steps are managed by the GUNA software, which generates timing, noise, and power models.

### **Timing Parameters**

| Timing Definition     | Value       |
|-----------------------|-------------|
| slew_low_rise_thr     | 20%         |
| slew_high_rise_thr    | 80%         |
| slew_low_fall_thr     | 20%         |
| slew_high_fall_thr    | 80%         |
| in_rise_thr           | 50%         |
| in_fall_thr           | 50%         |
| out_rise_thr          | 50%         |
| out_fall_thr          | 50%         |

**Propagation Delay**: The time it takes for an input change to reach 50% of its final value, affecting the output in the same way.

```
rise delay = time(out_fall_thr) - time(in_rise_thr)
```

**Transition Time**: The time required for a signal to transition between 10% to 90% or 20% to 80% of its signal levels.

```
Fall transition time: time(slew_high_fall_thr) - time(slew_low_fall_thr)
Rise transition time: time(slew_high_rise_thr) - time(slew_low_rise_thr)
```
 
</details>

<details>
	<summary><strong>Day 3 </strong></summary>

## CMOS Inverter NGSPICE Simulations

#### SPICE Deck for a CMOS Inverter Simulation

1. **Netlist Creation**: Begin by defining the netlist for the CMOS inverter circuit, making sure to clearly label the nodes (e.g., `input`, `output`, `ground`, and `supply`) for easier identification during the SPICE simulation.

2. **Device Sizing**: Specify the Width-to-Length (W/L) ratios for the PMOS and NMOS transistors. To achieve balanced drive strength, the PMOS width is typically 2x to 3x the width of the NMOS.

3. **Voltage Levels**: Set the gate and supply voltages as multiples of the transistor length to match the design specifications.

4. **Node Naming**: Assign specific names to each node (e.g., `VDD`, `GND`, `IN`, `OUT`) in the SPICE netlist to make the components easier to reference during the simulation. <br>
![image](https://github.com/user-attachments/assets/4909b747-13e6-4015-8701-6b69b5832d30) <br>

**Simulation Commands**: For transient analysis, use the following commands:

``` 
source [filename].cir 
run 
setplot 
dc1 
plot out vs in 
``` 

- `source [filename].cir`: Loads the SPICE netlist file.
- `run`: Executes the simulation.
- `setplot`: Prepares the plot settings.
- `dc1`: Runs a DC analysis.
- `plot out vs in`: Plots the output voltage against the input voltage.

#### Simulation and Analysis

- **Switching Threshold (Vm)**: The switching threshold (Vm) is the input voltage at which the inverter output transitions between logic levels. For equal PMOS and NMOS sizes, Vm is typically around VDD/2. Changing the sizes of the PMOS or NMOS transistors can shift Vm higher or lower.

- **SPICE Command for Threshold Calculation**:
   ``` 
   Vin in 0 2.5 
   .op 
   .dc Vin 0 2.5 0.05 
   ```

   - `Vin in 0 2.5`: Defines the input voltage range (from 0V to 2.5V).
   - `.op`: Performs an operating point analysis to find the initial conditions.
   - `.dc Vin 0 2.5 0.05`: Runs a DC sweep of the input voltage (Vin) from 0V to 2.5V with a step size of 0.05V.

![image](https://github.com/user-attachments/assets/15eaaff2-2270-4671-9bc3-7a15140a0d73)

- **Transient Analysis for Propagation Delay**: To perform transient analysis with a pulse input, use the following SPICE command:

``` 
Vin in 0 0 pulse 0 2.5 0 10p 10p 1n 2n 
.op 
.tran 10p 4n 
```

- `Vin in 0 0 pulse 0 2.5 0 10p 10p 1n 2n`: Defines a pulse input for `Vin` with a 0 to 2.5V swing, a rise time and fall time of 10ps, a pulse width of 1ns, and a period of 2ns.
- `.op`: Performs an operating point analysis to determine the initial conditions.
- `.tran 10p 4n`: Runs a transient analysis with a time step of 10ps and a total simulation time of 4ns.

![image](https://github.com/user-attachments/assets/734d729f-7097-4514-bc51-4961429c14a2)

#### Cloning the Custom Inverter Layout

1. Clone the inverter:
   ``` 
   cd Desktop/work/tools/openlane_working_dir/openlane 
   git clone https://github.com/nickson-jose/vsdstdcelldesign 
   cd vsdstdcelldesign 
   cp /home/vsduser/Desktop/work/tools/openlane_working_dir/pdks/sky130A/libs.tech/magic/sky130A.tech . 
   magic -T sky130A.tech sky130_inv.mag & 
   ```
![Screenshot 2024-11-13 214631](https://github.com/user-attachments/assets/f18bd6a9-9236-4037-90fa-8b245c798666) <br>

#### CMOS Fabrication Process (16 Masks)

1. **Substrate Preparation**: The process begins with preparing the silicon wafer, which serves as the foundation for the circuit.

2. **N-Well Formation**: Phosphorus impurities are introduced to form N-well regions on the substrate through implantation or diffusion.

3. **P-Well Formation**: P-well regions are created similarly by using boron or other dopants, typically through ion implantation or diffusion.

4. **Gate Oxide Deposition**: A thin layer of silicon dioxide is deposited to serve as the gate insulator for the transistors.

5. **Polysilicon Deposition**: A polysilicon layer is deposited on top of the gate oxide to form the gate electrode.

6. **Polysilicon Masking and Etching**: A photoresist mask is applied to define where the polysilicon should remain, and unprotected sections are etched away.

7. **N-Well Masking and Implantation**: A mask protects the N-well regions while impurities like phosphorus are implanted in the remaining areas.

8. **P-Well Masking and Implantation**: A mask shields the P-well regions, allowing boron or equivalent dopants to be implanted in other areas.

9. **Source/Drain Implantation**: Using masks, dopants such as arsenic for NMOS and boron for PMOS are implanted to form the source and drain regions of the transistors.

10. **Gate Formation**: The gate electrode is formed by etching the polysilicon layer, with the pattern defined by a mask.

11. **Source/Drain Masking and Etching**: Masks are applied to define the source and drain regions, and the oxide is etched away from these areas.

12. **Contact/Via Formation**: Holes are etched through the oxide layer to expose regions like the source, drain, or polysilicon gate, enabling contacts.

13. **Metal Deposition**: A metal layer, typically aluminum or copper, is deposited to create the electrical interconnections between components.

14. **Metal Masking and Etching**: A photoresist mask defines the metal interconnect patterns, followed by etching to remove unnecessary metal.

15. **Passivation Layer Deposition**: A protective layer of silicon dioxide or nitride is applied to shield the metal interconnections and protect the chip from environmental damage.

16. **Final Testing and Packaging**: After thorough testing to verify functionality, the chips are separated, packaged, and prepared for deployment.

![image](https://github.com/user-attachments/assets/94bb1130-336b-4e54-b70b-0a1462e884bc)

![Screenshot 2024-11-13 215023](https://github.com/user-attachments/assets/145ff252-bac0-4f41-aeaa-6f2bf8110f6c)
![Screenshot 2024-11-13 215043](https://github.com/user-attachments/assets/f5d7e362-71d0-4f54-9042-8fa0611a116a)
![Screenshot 2024-11-13 215110](https://github.com/user-attachments/assets/8e27d25f-042f-4adc-a6e4-be8c6463e652)
![Screenshot 2024-11-13 215208](https://github.com/user-attachments/assets/5e3bdc8f-c7a8-4f6a-bceb-0f00b5ff3998)
![Screenshot 2024-11-13 214956](https://github.com/user-attachments/assets/70262a50-3979-4b3e-88fe-19c240b9fd55)

#### SPICE Extraction with Magic

Run commands in `tkcon` to extract and generate SPICE:
``` 
pwd 
extract all 
ext2spice cthresh 0 rthresh 0 
ext2spice 
```
![Screenshot 2024-11-13 215430](https://github.com/user-attachments/assets/317251e6-d776-4186-8fe3-dc898d1e65a4)

### Modifying SPICE File for Transient Analysis
![image](https://github.com/user-attachments/assets/37d9eb59-9910-4434-9271-ffacdb1eca61)

Edit `sky130_inv.spice`:
```
* SPICE3 file created from sky130_inv.ext - technology: sky130A

.option scale=0.01u
.include ./libs/pshort.lib
.include ./libs/nshort.lib

M1000 Y A VGND VGND nshort_model.0 w=35 l=23
+  ad=1.44n pd=0.152m as=1.37n ps=0.148m
M1001 Y A VPWR VPWR pshort_model.0 w=37 l=23
+  ad=1.44n pd=0.152m as=1.52n ps=0.156m

VDD VPWR 0 3.3V
VSS VGND 0 0V
Va A VGND PULSE(0V 3.3V 0 0.1ns 0.1ns 2ns 4ns)

.tran 1n 20n
.control
run
.endc
.end
```

To simulate:
``` 
ngspice sky130_inv.spice 
plot y vs time a 
```
![Screenshot 2024-11-13 220100](https://github.com/user-attachments/assets/ebb78f86-c31a-44be-9aba-dda4a65a291e)

![Screenshot 2024-11-13 220048](https://github.com/user-attachments/assets/39b1e7b2-67bd-427f-91f4-41c914f22e48)

#### Characterizing Slew Rate and Propagation Delay

Using transient response:
- **Rise Transition**: Time for output to rise from 20% to 80% of max value.
- **Fall Transition**: Time for output to fall from 80% to 20%.
- **Cell Rise/Fall Delay**: Difference in time for 50% output change compared to input transition.

Example calculations:
```
Rise Transition : 2.24638 - 2.18242 =  0.06396 ns = 63.96 ps
Fall Transition : 4.0955 - 4.05536 =  0.0419 ns = 41.9 ps
Cell Rise Delay : 2.21144 - 2.15008 = 0.06136 ns = 61.36 ps
Cell Fall Delay : 4.07807 - 4.05 =0.02 ns = 20 ps
```

#### Magic Tool DRC Rules Check

Set up and run:
``` 
cd 
wget http://opencircuitdesign.com/open_pdks/archive/drc_tests.tgz 
tar xfz drc_tests.tgz 
cd drc_tests 
gvim .magicrc 
magic -d XR & 
```
![image](https://github.com/user-attachments/assets/03c8e107-d58a-4717-b5ee-1d8934ed0406)
![image](https://github.com/user-attachments/assets/db7b5147-76fb-4f9f-a05d-ebd75843dffc)

Run DRC commands:
``` 
tech load sky130A.tech 
drc check 
drc why 
```
![Screenshot 2024-11-13 221447](https://github.com/user-attachments/assets/ae2e6738-9bf4-4d71-8022-f9893b55538e) <br>
![Screenshot 2024-11-13 222423](https://github.com/user-attachments/assets/7c3f7018-bfd6-41aa-bf12-996623f5a78a) <br> 
![Screenshot 2024-11-13 222327](https://github.com/user-attachments/assets/e2cc8e63-729a-413f-981e-5c6586b4f9d4) <br>

 
</details>

<details>
	<summary><strong>Day 4 :pre-layout timing analysis and importance of good clock tree </strong></summary>

## pre-layout timing analysis and importance of good clock tree

Commands to extract `tracks.info` file:

```
cd Desktop/work/tools/openlane_working_dir/openlane/vsdstdcelldesign
cd ../../pdks/sky130A/libs.tech/openlane/sky130_fd_sc_hd/
less tracks.info
```
![Screenshot 2024-11-13 222913](https://github.com/user-attachments/assets/17c3afbd-4938-4ef5-94f6-e74fefdaa31d) <br>

Commands to set grid for tkcon window as tracks of locali layer use the following command

```
grid 0.46um 0.34um 0.23um 0.17um
```
![Screenshot 2024-11-13 225003](https://github.com/user-attachments/assets/a1095a2b-623b-4460-a4c4-b8ff796b6524) <br>

Now, save it by giving a custon mae

```
save sky130_asrinv.mag
```
![Screenshot 2024-11-13 224945](https://github.com/user-attachments/assets/7e58ae19-e34c-4600-8123-d15dd4bc7834) <br>

Now, open it by using the following commands:

```
magic -T sky130A.tech sky130_asrinv.mag &
```
![image](https://github.com/user-attachments/assets/b2733278-e588-40f0-9478-5f833e56b0e8) <br>

Now, type the following command in tkcon window:

```
lef write
```
![Screenshot 2024-11-13 225522](https://github.com/user-attachments/assets/8c0a9594-8252-47d1-bdd4-79d62dda713d) <br>

Modify config.tcl:

```
# Design
set ::env(DESIGN_NAME) "picorv32a"

set ::env(VERILOG_FILES) "./designs/picorv32a/src/picorv32a.v"
set ::env(SDC_FILE) "./designs/picorv32a/src/picorv32a.sdc"

set ::env(CLOCK_PERIOD) "5.000"
set ::env(CLOCK_PORT) "clk"

set ::env(CLOCK_NET) $::env(CLOCK_PORT)

set ::env(LIB_SYNTH) "$::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130_fd_sc_hd__typical.lib"
set ::env(LIB_FASTEST) "$::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130_fd_sc_hd__fast.lib"
set ::env(LIB_SLOWEST) "$::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130_fd_sc_hd__slow.lib"
set ::env(LIB_TYPICAL) "$::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130_fd_sc_hd__typical.lib"

set ::env(EXTRA_LEFS) [glob $::env(OPENLANE_ROOT)/designs/$::env(DESIGN_NAME)/src/*.lef]

set filename $::env(OPENLANE_ROOT)/designs/$::env(DESIGN_NAME)/$::env(PDK)_$::env(STD_CELL_LIBRARY)_config.tcl
if { [file exists $filename] == 1 } {
  source $filename
}
```

Now, run openlane flow synthesis:

```
cd Desktop/work/tools/openlane_working_dir/openlane
docker
```

```
./flow.tcl -interactive
package require openlane 0.9
prep -design picorv32a
set lefs [glob $::env(DESIGN_DIR)/src/*.lef]
add_lefs -src $lefs
run_synthesis
```

![image](https://github.com/user-attachments/assets/d08cfc1a-54ae-4b8b-a9b5-134e7453e900)
![image](https://github.com/user-attachments/assets/97a9729f-3686-4221-8a19-63f0188e5f41)
![image](https://github.com/user-attachments/assets/d793b3a3-8af6-4990-9452-10f8e4a0d864)
**Delay Tables**

Delay is a critical factor in cell timing, influenced by input transition and output load. Even cells of the same type can have different delays depending on wire length, due to variations in resistance and capacitance. To manage this, "delay tables" are used, which are 2D arrays incorporating input slew and load capacitance for each buffer size as timing models. Algorithms then compute buffer delays from these tables, interpolating between available data points when necessary to accurately estimate delays. This helps maintain signal integrity across varying load conditions, ensuring reliable performance.

![image](https://github.com/user-attachments/assets/a7173194-eda2-4215-99f9-fd9657736d0d)
Fixing slack:

```
./flow.tcl -interactive
package require openlane 0.9
prep -design picorv32a -tag 13-11_17-56 -overwrite
set lefs [glob $::env(DESIGN_DIR)/src/*.lef]
add_lefs -src $lefs
echo $::env(SYNTH_STRATEGY)
set ::env(SYNTH_STRATEGY) "DELAY 3"
echo $::env(SYNTH_BUFFERING
echo $::env(SYNTH_SIZING)
set ::env(SYNTH_SIZING) 1
echo $::env(SYNTH_DRIVING_CELL)
run_synthesis
```
![Screenshot 2024-11-13 233819](https://github.com/user-attachments/assets/f74621f3-30ec-4b5c-997f-f381e003e3ae)

![Screenshot 2024-11-13 233751](https://github.com/user-attachments/assets/ba08a272-48e8-4f2e-9b3b-e55d4754b14d)
![Screenshot 2024-11-13 233805](https://github.com/user-attachments/assets/0e3cc109-e030-4882-903f-e117956aa86c)

Now, run floorplan

```
run_floorplan
```

![image](https://github.com/user-attachments/assets/aad5c46c-00a8-4c78-a80c-b916da436ff3) <br>

Since we are facing unexpected un-explainable error while using run_floorplan command, we can instead use the following set of commands available based on information from `Desktop/work/tools/openlane_working_dir/openlane/scripts/tcl_commands/floorplan.tcl` and also based on Floorplan Commands section in `Desktop/work/tools/openlane_working_dir/openlane/docs/source/OpenLANE_commands.md`

```
init_floorplan
place_io
tap_decap_or
```

Now, do placement

```
run_placement
```
![Screenshot 2024-11-13 234421](https://github.com/user-attachments/assets/12d6b342-5674-4402-8866-0fd78cb7d64c)
![Screenshot 2024-11-13 234758](https://github.com/user-attachments/assets/93bbce15-39c3-4418-8d51-c4417ded8a8b)

Now, open a new terminal and run the below commands to load placement def in magic

```
cd Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/13-11_17-56/results/placement/
magic -T /home/vsduser/Desktop/work/tools/openlane_working_dir/pdks/sky130A/libs.tech/magic/sky130A.tech lef read ../../tmp/merged.lef def read picorv32a.placement.def &

```
Custom inverter inserted in placement def<br>
![image](https://github.com/user-attachments/assets/0c629879-ddbf-49b4-af4e-5310502e7d33)<br>
Now, select the cell and type `expand` in tkcon window to view internal layers of cells<br>
![image](https://github.com/user-attachments/assets/65e42d74-358b-46bd-ada3-4c5c8479c675) <br>

**Timing analysis with ideal clocks using openSTA**

Pre-layout STA will include effects of clock buffers and net-delay due to RC parasitics (wire delay will be derived from PDK library wire model).
![image](https://github.com/user-attachments/assets/d9430cdd-e46e-4a7e-834b-dfa0610f2857)

Since we are getting 0 wns after improved timing run, we will be doing the timing analysis on initial run of synthesis which has lots of violations and no parameters added to improve timing.

Commands to invoke the OpenLANE flow include new lef and perform synthesis:

```
cd Desktop/work/tools/openlane_working_dir/openlane
docker
./flow.tcl -interactive
package require openlane 0.9set
prep -design picorv32a
set lefs [glob $::env(DESIGN_DIR)/src/*.lef]
add_lefs -src $lefs
set ::env(SYNTH_SIZING) 1
run_synthesis
```

Go, to `Desktop/work/tools/openlane_working_dir/openlane` and create a file `pre_sta.conf`. The contents of the file are:

```
set_cmd_units -time ns -capacitance pF -current mA -voltage V -resistance kOhm -distance um
read_liberty -max /home/vsduser/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/src/sky130_fd_sc_hd__slow.lib
read_liberty -min /home/vsduser/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/src/sky130_fd_sc_hd__fast.lib
read_verilog /home/vsduser/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/13-11_17-56/results/synthesis/picorv32a.synthesis.v
link_design picorv32a
read_sdc /home/vsduser/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/src/my_base.sdc
report_checks -path_delay min_max -fields {slew trans net cap input_pin}
report_tns
report_wns
```

Contents of `my_base.sdc`:

```
set ::env(CLOCK_PORT) clk
set ::env(CLOCK_PERIOD) 12.000
set ::env(SYNTH_DRIVING_CELL) sky130_fd_sc_hd__inv_8
set ::env(SYNTH_DRIVING_CELL_PIN) Y
set ::env(SYNTH_CAP_LOAD) 17.65
create_clock [get_ports $::env(CLOCK_PORT)]  -name $::env(CLOCK_PORT)  -period $::env(CLOCK_PERIOD)
set IO_PCT  0.2
set input_delay_value [expr $::env(CLOCK_PERIOD) * $IO_PCT]
set output_delay_value [expr $::env(CLOCK_PERIOD) * $IO_PCT]
puts "\[INFO\]: Setting output delay to: $output_delay_value"
puts "\[INFO\]: Setting input delay to: $input_delay_value"


set clk_indx [lsearch [all_inputs] [get_port $::env(CLOCK_PORT)]]
#set rst_indx [lsearch [all_inputs] [get_port resetn]]
set all_inputs_wo_clk [lreplace [all_inputs] $clk_indx $clk_indx]
#set all_inputs_wo_clk_rst [lreplace $all_inputs_wo_clk $rst_indx $rst_indx]
set all_inputs_wo_clk_rst $all_inputs_wo_clk


# correct resetn
set_input_delay $input_delay_value  -clock [get_clocks $::env(CLOCK_PORT)] $all_inputs_wo_clk_rst
#set_input_delay 0.0 -clock [get_clocks $::env(CLOCK_PORT)] {resetn}
set_output_delay $output_delay_value  -clock [get_clocks $::env(CLOCK_PORT)] [all_outputs]

# TODO set this as parameter
set_driving_cell -lib_cell $::env(SYNTH_DRIVING_CELL) -pin $::env(SYNTH_DRIVING_CELL_PIN) [all_inputs]
set cap_load [expr $::env(SYNTH_CAP_LOAD) / 1000.0]
puts "\[INFO\]: Setting load to: $cap_load"
set_load  $cap_load [all_outputs]
```

Commands to run STA:

```
cd Desktop/work/tools/openlane_working_dir/openlane
sta pre_sta.conf
```
![image](https://github.com/user-attachments/assets/30b94070-7224-4650-b0db-449e38d342a3)
![image](https://github.com/user-attachments/assets/bfb2c473-a51b-47af-b73e-cc660d255563)


We now try to optimise synthesis.

Go to new terminal and run the follwoing commands:

```
cd Desktop/work/tools/openlane_working_dir/openlane
docker
./flow.tcl -interactive
prep -design picorv32a -tag 13-11_17-56 -overwrite
set lefs [glob $::env(DESIGN_DIR)/src/*.lef]
add_lefs -src $lefs
set ::env(SYNTH_SIZING) 1
set ::env(SYNTH_MAX_FANOUT) 4
echo $::env(SYNTH_DRIVING_CELL)
run_synthesis
```
![image](https://github.com/user-attachments/assets/ac1bbeeb-ff7f-4325-b085-7c21f1c1e3c1)


Commands to run STA:

```
cd Desktop/work/tools/openlane_working_dir/openlane
sta pre_sta.conf
```
![image](https://github.com/user-attachments/assets/30b94070-7224-4650-b0db-449e38d342a3)
![image](https://github.com/user-attachments/assets/bfb2c473-a51b-47af-b73e-cc660d255563)

**Basic timing ECO**

NOR gate of drive strength 2 is driving 5 fanouts
![image](https://github.com/user-attachments/assets/643132ff-a53c-467f-9c3f-932b2e423cb1)


Run the following commands to optimise timing:

```
report_net -connections _13111_
replace_cell _16171_ sky130_fd_sc_hd__nor3_2
report_checks -fields {net cap slew input_pins} -digits 4
```
![image](https://github.com/user-attachments/assets/3af05e0b-4141-4127-a469-65487f70fa27)


We can observe that the tns has reduced to -402.45 from -403.54 and wns has reduced to -5.44 from -5.59

**Clock tree synthesis TritonCTS and signal integrity**

Clock Tree Synthesis (CTS) techniques vary based on design needs:

- Balanced Tree CTS: Uses a balanced binary-like tree for equal path lengths, minimizing clock skew but with moderate power efficiency.
- H-tree CTS: Employs an "H"-shaped structure, good for large areas and power efficiency.
![image](https://github.com/user-attachments/assets/84bb1d31-ea29-4335-989e-86bc97bde266)

- Star CTS: Distributes the clock from a central point, minimizing skew but requiring more buffers near the source.
- Global-Local CTS: Combines star and tree topologies, with a global tree for clock domains and local trees within domains, balancing global and local timing.
- Mesh CTS: Uses a grid pattern ideal for structured designs, balancing simplicity and skew.
- Adaptive CTS: Dynamically adjusts based on timing and congestion, offering flexibility but with added complexity.

**Crosstalk**

Crosstalk is interference from overlapping electromagnetic fields between adjacent circuits, causing unwanted signals. In VLSI, it can lead to data corruption, timing issues, and higher power consumption. Mitigation strategies include optimized layout and routing, shielding, and clock gating to reduce dynamic power and minimize crosstalk effects.

![image](https://github.com/user-attachments/assets/ea6bfa3c-b959-405b-bfe7-52570fe93906)

**Clock Net Shielding**

Clock net shielding prevents glitches by isolating the clock network, using shields connected to VDD or GND that don’t switch. It reduces interference by isolating clocks from other signals, often with dedicated routing layers and clock buffers. Additionally, clock domain isolation helps prevent cross-domain interference, avoiding metastability and maintaining synchronization.

![image](https://github.com/user-attachments/assets/e90287e1-8f3b-4f37-953f-523fca962127)

Now to insert this updated netlist to PnR flow and we can use write_verilog and overwrite the synthesis netlist but before that we are going to make a copy of the old old netlist:

Run the following commands:

```
cd Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/13-11_17-56/results/synthesis/
ls
cp picorv32a.synthesis.v picorv32a.synthesis_old.v
ls
```

Commands to write verilog:

```
write_verilog /home/vsduser/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/13-11_17-56/results/synthesis/picorv32a.synthesis.v
exit
```
Verified that the netlist is overwritten

![image](https://github.com/user-attachments/assets/e3cf754d-4bb9-4de5-93de-304d6003a7d0)

Now run the following commands:
```
cd Desktop/work/tools/openlane_working_dir/openlane
docker
./flow.tcl -interactive
prep -design picorv32a -tag 13-11_17-56 -overwrite
set lefs [glob $::env(DESIGN_DIR)/src/*.lef]
add_lefs -src $lefs
set ::env(SYNTH_STRATEGY) "DELAY 3"
set ::env(SYNTH_SIZING) 1
run_synthesis
init_floorplan
place_io
tap_decap_or
run_placement
run_cts
```
![Screenshot 2024-11-14 014740](https://github.com/user-attachments/assets/ad52fe91-fb7c-4c1f-8497-559907ac0531)

![Screenshot 2024-11-14 014703](https://github.com/user-attachments/assets/23bd19b7-3d5b-4bc3-bc70-3d8f3181ec91)

**Setup timing analysis using real clocks**

A real clock in timing analysis accounts for practical factors like clock skew and clock jitter. Clock skew is the difference in arrival times of the clock signal at different parts of the circuit due to physical delays, which affects setup and hold timing margins. Clock jitter is the variability in the clock period caused by power, temperature, and noise fluctuations, leading to uncertainty in clock edge timing. Both factors are crucial for accurate timing analysis, ensuring the design performs reliably in real-world conditions.
![image](https://github.com/user-attachments/assets/78043628-14c3-4cf3-9f75-c8aa11ac5daf)
![image](https://github.com/user-attachments/assets/5f846e2e-4d01-4a41-8945-b65fc09171de)

Now, enter the following commands for Post-CTS OpenROAD timing analysis:

```
openroad
read_lef /openLANE_flow/designs/picorv32a/runs/13-11_17-56/tmp/merged.lef
read_def /openLANE_flow/designs/picorv32a/runs/13-11_17-56/results/cts/picorv32a.cts.def
write_db pico_cts.db
read_db pico_cts.db
read_verilog /openLANE_flow/designs/picorv32a/runs/13-11_17-56/results/synthesis/picorv32a.synthesis_cts.v
read_liberty $::env(LIB_SYNTH_COMPLETE)
link_design picorv32a
read_sdc /openLANE_flow/designs/picorv32a/src/my_base.sdc
set_propagated_clock [all_clocks]
report_checks -path_delay min_max -fields {slew trans net cap input_pins} -format full_clock_expanded -digits 4
exit
```
![Screenshot 2024-11-14 014941](https://github.com/user-attachments/assets/8cee7518-59d3-44eb-80fc-662967b6c8fb)
![Screenshot 2024-11-14 014952](https://github.com/user-attachments/assets/a3231624-4f53-4776-b1d6-b2fbe3865d8b)




Now, enter the following commands for exploring post-CTS OpenROAD timing analysis by removing 'sky130_fd_sc_hd__clkbuf_1' cell from clock buffer list variable 'CTS_CLK_BUFFER_LIST':

```
echo $::env(CTS_CLK_BUFFER_LIST)
set ::env(CTS_CLK_BUFFER_LIST) [lreplace $::env(CTS_CLK_BUFFER_LIST) 0 0]
echo $::env(CTS_CLK_BUFFER_LIST)
echo $::env(CURRENT_DEF)
set ::env(CURRENT_DEF) /openLANE_flow/designs/picorv32a/runs/13-11_17-56/results/placement/picorv32a.placement.def
run_cts
echo $::env(CTS_CLK_BUFFER_LIST)
openroad
read_lef /openLANE_flow/designs/picorv32a/runs/13-11_17-56/tmp/merged.lef
read_def /openLANE_flow/designs/picorv32a/runs/13-11_17-56/results/cts/picorv32a.cts.def
write_db pico_cts1.db
read_db pico_cts.db
read_verilog /openLANE_flow/designs/picorv32a/runs/13-11_17-56/results/synthesis/picorv32a.synthesis_cts.v
read_liberty $::env(LIB_SYNTH_COMPLETE)
link_design picorv32a
read_sdc /openLANE_flow/designs/picorv32a/src/my_base.sdc
set_propagated_clock [all_clocks]
report_checks -path_delay min_max -fields {slew transd net cap input_pins} -format full_clock_expanded -digits 4
report_clock_skew -hold
report_clock_skew -setup
exit
echo $::env(CTS_CLK_BUFFER_LIST)
set ::env(CTS_CLK_BUFFER_LIST) [linsert $::env(CTS_CLK_BUFFER_LIST) 0 sky130_fd_sc_hd__clkbuf_1]
echo $::env(CTS_CLK_BUFFER_LIST)
```

![Screenshot 2024-11-14 015121](https://github.com/user-attachments/assets/c94e0e11-f681-4a4a-bbeb-3cb7a8aca273)
![Screenshot 2024-11-14 015111](https://github.com/user-attachments/assets/ad802793-0df9-453e-8e79-b6dedad8e2ea)

 
</details>

<details>
	<summary><strong>Day 5 </strong></summary>

## Final Steps for RTL to GDS Using TritonRoute and OpenSTA

Maze routing connects pins physically on a routing grid, with Lee’s algorithm being a common method. This algorithm begins at the source pin, assigning sequential labels to neighboring grid cells until the target pin is reached. It prefers L-shaped routes and only uses zigzag paths if needed. While Lee’s algorithm ensures the shortest path between two pins, it can be slow for larger designs, leading to the adoption of faster methods for more complex routing tasks.

```

cd Desktop/work/tools/openlane_working_dir/openlane
docker

./flow.tcl -interactive
package require openlane 0.9
prep -design picorv32a
set lefs [glob $::env(DESIGN_DIR)/src/*.lef]
add_lefs -src $lefs
set ::env(SYNTH_STRATEGY) "DELAY 3"
set ::env(SYNTH_SIZING) 1
run_synthesis
init_floorplan
place_io
tap_decap_or
run_placement
run_cts
gen_pdn

```
Screenshots of power distribution network run:

![Screenshot 2024-11-14 020448](https://github.com/user-attachments/assets/fc9482a4-a90d-4695-b576-768891f13234)
![Screenshot 2024-11-14 020558](https://github.com/user-attachments/assets/91840bde-0cb5-4ba6-873d-531311c324c6)
![Screenshot 2024-11-14 020626](https://github.com/user-attachments/assets/c8502309-f675-46bb-9e33-87fe166cfb80)
![Screenshot 2024-11-14 020644](https://github.com/user-attachments/assets/0a28d600-deeb-419e-abd1-ec4d34a8f50b)
![Screenshot 2024-11-14 020701](https://github.com/user-attachments/assets/20df6e14-a027-4dd3-bc78-31c585dd1266)
![Screenshot 2024-11-14 134654](https://github.com/user-attachments/assets/f9dd7bf8-80db-46c4-8d8e-f15ce7b35396)
![Screenshot 2024-11-14 134633](https://github.com/user-attachments/assets/058be6e9-dbc9-4d47-9b1a-869833c316bd)


## 2. Perfrom detailed routing using TritonRoute and explore the routed layout.
Command to perform routing
```
echo $::env(CURRENT_DEF)
echo $::env(ROUTING_STRATEGY)
run_routing
```
Screenshots of routing run:
![Screenshot 2024-11-14 023507](https://github.com/user-attachments/assets/1a3a716d-7509-49bf-aa56-edb800a9852a)
![Screenshot 2024-11-14 023756](https://github.com/user-attachments/assets/acdc5249-0008-4885-a445-81006e96baa7)
![Screenshot 2024-11-14 023258](https://github.com/user-attachments/assets/de23cca0-b7c4-47b1-88aa-0b32b6599c76)

Screenshot of fast route guide present in openlane/designs/picorv32a/runs/13-11_18-24/tmp/routing directory :
![Screenshot 2024-11-14 023912](https://github.com/user-attachments/assets/4b9658fc-3a4e-409e-adee-4ab0007d1e32)
![Screenshot 2024-11-14 134834](https://github.com/user-attachments/assets/9d7e6a60-ed29-4815-81b7-6b6fb373cd37)
![Screenshot 2024-11-14 134824](https://github.com/user-attachments/assets/ae4a8543-f97b-407d-a691-da87b5792b2e)


### **3. Post-Route Parasitic Extraction with SPEF Extractor**

To extract parasitics after routing, the SPEF extractor analyzes the design layout and generates a Standard Parasitic Exchange Format (SPEF) file. Use the following command to perform the extraction:

```bash
cd Desktop/work/tools/SPEF_EXTRACTOR

python3 main.py /home/vsduser/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/13-11_18-24/tmp/merged.lef /home/vsduser/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/13-11_18-24/results/routing/picorv32a.def
```

Here, the `.lef` file provides information about cell layout, and the `.def` file details the design's physical implementation.

---

### **4. Post-Route Timing Analysis with OpenSTA**

To analyze timing post-routing with extracted parasitics, OpenSTA integrated within OpenROAD is used. Follow these steps to run the analysis:

```bash
openroad
read_lef /openLANE_flow/designs/picorv32a/runs/13-11_18-24/tmp/merged.lef
read_def /openLANE_flow/designs/picorv32a/runs/13-11_18-24/results/routing/picorv32a.def
write_db pico_route.db
read_db pico_route.db
read_verilog /openLANE_flow/designs/picorv32a/runs/13-11_18-24/results/synthesis/picorv32a.synthesis_preroute.v
read_liberty $::env(LIB_SYNTH_COMPLETE)
link_design picorv32a
read_sdc /openLANE_flow/designs/picorv32a/src/my_base.sdc
set_propagated_clock [all_clocks]
read_spef /openLANE_flow/designs/picorv32a/runs/13-11_18-24/results/routing/picorv32a.spef
report_checks -path_delay min_max -fields {slew trans net cap input_pins} -format full_clock_expanded -digits 4
exit
```

- **Files Used**:
  - `.lef`: Layout information for standard cells.
  - `.def`: Details the post-route physical design.
  - `.synthesis_preroute.v`: Pre-route synthesized netlist.
  - `.sdc`: Design constraints like clock definitions.
  - `.spef`: Extracted parasitic data from the SPEF extractor.
  
- **Commands Overview**:
  - Load design files, including library, layout, and constraints.
  - Incorporate parasitics with the `.spef` file.
  - Generate timing reports (`report_checks`) for min/max delays with detailed fields.

This flow ensures accurate timing analysis, including parasitic effects, enhancing design reliability before fabrication.

</details>
 
</details>

---


<details>
	<summary><strong> Lab 14</strong></summary>


 ### Installing and setting up ORFS
```
git clone --recursive https://github.com/The-OpenROAD-Project/OpenROAD-flow-scripts
cd OpenROAD-flow-scripts
sudo ./setup.sh
```
![Screenshot from 2024-11-26 00-04-05](https://github.com/user-attachments/assets/2bf05e40-baa5-4d81-9695-620f6dd6a5fc)

Next run the following command:
```
./build_openroad.sh --local
```
![Screenshot from 2024-11-26 00-04-24](https://github.com/user-attachments/assets/7fdc7df2-7045-4265-8b85-664f61a0ff4b)
![Screenshot from 2024-11-26 00-04-39](https://github.com/user-attachments/assets/6d6af42d-3ad4-4591-af8a-8867a1ace0ac)

To verify the installation run the following commands:
```
source ./env.sh
yosys -help
openroad -help
cd flow
make
```
![Screenshot from 2024-11-26 00-04-53](https://github.com/user-attachments/assets/7a73f17b-67dd-48b8-8a79-374ff523a05a)
![Screenshot from 2024-11-26 00-05-04](https://github.com/user-attachments/assets/b3368195-4236-4d11-bb25-78d89746005f)
![Screenshot from 2024-11-26 00-05-31](https://github.com/user-attachments/assets/504c9fa1-9216-4062-9414-d71e21456256)

next run the command:
```
make gui_final
```
![Screenshot from 2024-11-25 23-06-21](https://github.com/user-attachments/assets/23740033-da1d-4e46-ba39-f7f953ab76a9)

### ORFS Directory Structure and File formats
![Screenshot from 2024-11-26 00-06-39](https://github.com/user-attachments/assets/2d637e72-10d7-4c3f-aab0-10bd5e5e6d2c)

```
├── OpenROAD-flow-scripts             
│   ├── docker           -> It has Docker based installation, run scripts and all saved here
│   ├── docs             -> Documentation for OpenROAD or its flow scripts.  
│   ├── flow             -> Files related to run RTL to GDS flow  
|   ├── jenkins          -> It contains the regression test designed for each build update
│   ├── tools            -> It contains all the required tools to run RTL to GDS flow
│   ├── etc              -> Has the dependency installer script and other things
│   ├── setup_env.sh     -> Its the source file to source all our OpenROAD rules to run the RTL to GDS flow
```

## Structure of the flow directory
```
├── flow           
│   ├── design           -> It has built-in examples from RTL to GDS flow across different technology nodes
│   ├── makefile         -> The automated flow runs through makefile setup
│   ├── platform         -> It has different technology note libraries, lef files, GDS etc 
|   ├── tutorials        
│   ├── util            
│   ├── scripts
```

Automated RTL2GDS Flow for VSDBabySoC:

Initial Steps:

1. Create a directory named `vsdbabysoc` under `OpenROAD-flow-scripts/flow/designs/sky130hd`.
2. Inside `OpenROAD-flow-scripts/flow/designs/src`, create another directory named `vsdbabysoc` and add all the Verilog files there.
3. Copy the `gds`, `include`, `lef`, and `lib` folders from your local `VSDBabySoC` folder into this new directory.
   - The `gds` folder should contain `avsddac.gds` and `avsdpll.gds`.
   - The `include` folder should contain `sandpiper.vh`, `sandpiper_gen.vh`, `sp_default.vh`, and `sp_verilog.vh`.
   - The `lef` folder should contain `avsddac.lef` and `avsdpll.lef`.
   - The `lib` folder should contain `avsddac.lib` and `avsdpll.lib`.
4. Copy the `vsdbabysoc_synthesis.sdc` constraints file from your local `VSDBabySoC` folder into this directory.
5. Copy the `macro.cfg` and `pin_order.cfg` files from your local `VSDBabySoC` folder into this directory.
6. Create a `config.mk` file with the contents shown below:
```
export DESIGN_NICKNAME = vsdbabysoc
export DESIGN_NAME = vsdbabysoc
export PLATFORM    = sky130hd

# export VERILOG_FILES_BLACKBOX = $(DESIGN_HOME)/src/$(DESIGN_NICKNAME)/IPs/*.v
# export VERILOG_FILES = $(sort $(wildcard $(DESIGN_HOME)/src/$(DESIGN_NICKNAME)/*.v))
# Explicitly list the Verilog files for synthesis
export VERILOG_FILES = $(DESIGN_HOME)/src/$(DESIGN_NICKNAME)/vsdbabysoc.v \
                       $(DESIGN_HOME)/src/$(DESIGN_NICKNAME)/rvmyth.v \
                       $(DESIGN_HOME)/src/$(DESIGN_NICKNAME)/clk_gate.v

export SDC_FILE      = $(DESIGN_HOME)/$(PLATFORM)/$(DESIGN_NICKNAME)/vsdbabysoc_synthesis.sdc


export DIE_AREA   = 0 0 1600 1600
export CORE_AREA  = 20 20 1590 1590


export vsdbabysoc_DIR = $(DESIGN_HOME)/$(PLATFORM)/$(DESIGN_NICKNAME)

export VERILOG_INCLUDE_DIRS = $(wildcard $(vsdbabysoc_DIR)/include/)
# export SDC_FILE      = $(wildcard $(vsdbabysoc_DIR)/sdc/*.sdc)
export ADDITIONAL_GDS  = $(wildcard $(vsdbabysoc_DIR)/gds/*.gds.gz)
export ADDITIONAL_LEFS  = $(wildcard $(vsdbabysoc_DIR)/lef/*.lef)
export ADDITIONAL_LIBS = $(wildcard $(vsdbabysoc_DIR)/lib/*.lib)
# export PDN_TCL = $(DESIGN_HOME)/$(PLATFORM)/$(DESIGN_NICKNAME)/pdn.tcl

# Clock Configuration (vsdbabysoc specific)
# export CLOCK_PERIOD = 20.0
export CLOCK_PORT = CLK
export CLOCK_NET = $(CLOCK_PORT)

# Floorplanning Configuration (vsdbabysoc specific)
export FP_PIN_ORDER_CFG = $(wildcard $(DESIGN_DIR)/pin_order.cfg)
export FP_SIZING = absolute

export DIE_AREA   = 0 0 1600 1600
export CORE_AREA  = 20 20 1590 1590

# Placement Configuration (vsdbabysoc specific)
export MACRO_PLACEMENT_CFG = $(wildcard $(DESIGN_DIR)/macro.cfg)
export PLACE_PINS_ARGS = -exclude left:0-600 -exclude left:1000-1600: -exclude right:* -exclude top:* -exclude bottom:*
# export MACRO_PLACEMENT = $(DESIGN_HOME)/$(PLATFORM)/$(DESIGN_NICKNAME)/macro_placement.cfg

export TNS_END_PERCENT = 100
export REMOVE_ABC_BUFFERS = 1

# Magic Tool Configuration
export MAGIC_ZEROIZE_ORIGIN = 0
export MAGIC_EXT_USE_GDS = 1

# CTS tuning
export CTS_BUF_DISTANCE = 600
export SKIP_GATE_CLONING = 1

export CORE_UTILIZATION=0.1  # Reduce this value to allow more whitespace for routing.

```
### Now go to terminal and run the following commands:
```
cd OpenROAD-flow-scripts
source env.sh
cd flow
```

Commands for synthesis:
```
make DESIGN_CONFIG=./designs/sky130hd/vsdbabysoc/config.mk synth
```
![Screenshot from 2024-11-26 00-07-26](https://github.com/user-attachments/assets/283eb121-cab0-4e80-8316-78f7f94c3704)
![Screenshot from 2024-11-26 00-07-36](https://github.com/user-attachments/assets/42bff074-a393-49d9-b22e-ec992d59cb19)

### Synthesis Netlist:
![Screenshot from 2024-11-26 00-07-47](https://github.com/user-attachments/assets/2e09b3f2-dc29-4d57-8bcc-85f31ab86c4b)

### Synthesis log:
![Screenshot from 2024-11-26 00-24-54](https://github.com/user-attachments/assets/9597de54-d63a-46c3-ab12-460a831f1e8b)


### Synthesis Check:
![Screenshot from 2024-11-26 00-26-36](https://github.com/user-attachments/assets/d3ec9de4-46e2-4aec-a510-179bb2543da7)


### Synthesis Stats:
![Screenshot from 2024-11-26 00-27-17](https://github.com/user-attachments/assets/14f0e28a-5082-4565-a9d4-ba14d99b9b1c)
![Screenshot from 2024-11-26 00-27-25](https://github.com/user-attachments/assets/55fce473-4def-4263-b5cc-d1595f801dea)
![Screenshot from 2024-11-26 00-27-38](https://github.com/user-attachments/assets/a327c446-083a-4015-94b4-1c42a815a1c0)

Commands For Floor plan:
```
make DESIGN_CONFIG=./designs/sky130hd/vsdbabysoc/config.mk floorplan
```
![Screenshot from 2024-11-26 11-27-51](https://github.com/user-attachments/assets/4a95f9d0-3d26-417f-b25f-e4e81aeebebf)
![Screenshot from 2024-11-26 11-29-45](https://github.com/user-attachments/assets/cb36ddbc-b08e-402a-a374-1c365d8d52ea)

```
make DESIGN_CONFIG=./designs/sky130hd/vsdbabysoc/config.mk gui_floorplan
```
![Screenshot from 2024-11-26 11-30-46](https://github.com/user-attachments/assets/bde8a694-4849-4873-a222-898a0a0a5778)
![Screenshot from 2024-11-26 11-30-34](https://github.com/user-attachments/assets/d41f298c-689a-4d73-8446-d4ebfc426766)
![Screenshot from 2024-11-26 11-31-51](https://github.com/user-attachments/assets/9b663b01-87a2-4509-b039-c393eae226c8)

### Commands for Placement:
```
make DESIGN_CONFIG=./designs/sky130hd/vsdbabysoc/config.mk place
```
![Screenshot from 2024-11-26 11-34-20](https://github.com/user-attachments/assets/c91c44e3-054a-4d26-bac0-59bdbd898aec)

![Screenshot from 2024-11-26 11-33-21](https://github.com/user-attachments/assets/0a791fc7-db10-4dbc-a1d0-bb7a3d48e909)

```
make DESIGN_CONFIG=./designs/sky130hd/vsdbabysoc/config.mk gui_place
```
![Screenshot from 2024-11-26 11-34-40](https://github.com/user-attachments/assets/7c5ef710-37e6-47d7-92c9-feb79452eea0)
![Screenshot from 2024-11-26 11-34-58](https://github.com/user-attachments/assets/868126fa-bd49-49a3-97f9-80a096b57fef)
![Screenshot from 2024-11-26 11-35-55](https://github.com/user-attachments/assets/ae73ba00-6442-4c80-9ac2-6c8cea56b628)

**HeatMap:**
![Screenshot from 2024-11-26 11-37-11](https://github.com/user-attachments/assets/03576b11-10fc-4feb-bf0b-7928d75b9f1d)
![Screenshot from 2024-11-26 11-42-07](https://github.com/user-attachments/assets/988b05e2-b81a-40d8-9cf2-654f24068984)

```
make DESIGN_CONFIG=./designs/sky130hd/vsdbabysoc/config.mk cts
```
![Screenshot from 2024-11-26 11-42-51](https://github.com/user-attachments/assets/120e90b9-6974-4e61-b434-65ee9c375c0a)
![Screenshot from 2024-11-26 11-42-43](https://github.com/user-attachments/assets/b2f27ea6-1c55-4e2b-9f54-38c4ab474256)

```
make DESIGN_CONFIG=./designs/sky130hd/vsdbabysoc/config.mk gui_cts
```
![Screenshot from 2024-11-26 11-43-36](https://github.com/user-attachments/assets/ad78b4f7-cc47-4791-b66f-0643b33d9ad3)
![Screenshot from 2024-11-26 11-44-30](https://github.com/user-attachments/assets/41b4fcf0-1cfc-4995-9c32-95cdacad5e84)

### Heatmap:


### Final CTS Report:
```

==========================================================================
cts final report_tns
--------------------------------------------------------------------------
tns 0.00

==========================================================================
cts final report_wns
--------------------------------------------------------------------------
wns 0.00

==========================================================================
cts final report_worst_slack
--------------------------------------------------------------------------
worst slack 5.04

==========================================================================
cts final report_clock_skew
--------------------------------------------------------------------------
Clock clk
   0.96 source latency core.CPU_src2_value_a3[28]$_DFF_P_/CLK ^
  -0.82 target latency core.CPU_pc_a1[22]$_SDFF_PP0_/CLK ^
   0.54 clock uncertainty
   0.00 CRPR
--------------
   0.68 setup skew


==========================================================================
cts final report_checks -path_delay min
--------------------------------------------------------------------------
Startpoint: core.CPU_Xreg_value_a4[30][10]$_SDFFE_PP0P_
            (rising edge-triggered flip-flop clocked by clk)
Endpoint: core.CPU_src2_value_a3[10]$_DFF_P_
          (rising edge-triggered flip-flop clocked by clk)
Path Group: clk
Path Type: min

Fanout     Cap    Slew   Delay    Time   Description
-----------------------------------------------------------------------------
                          0.00    0.00   clock clk (rise edge)
                          0.00    0.00   clock source latency
     1    0.18    0.00    0.00    0.00 ^ pll/CLK (avsdpll)
                                         CLK (net)
                  0.02    0.01    0.01 ^ clkbuf_0_CLK/A (sky130_fd_sc_hd__clkbuf_16)
     8    0.22    0.22    0.25    0.26 ^ clkbuf_0_CLK/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_0_CLK (net)
                  0.22    0.00    0.26 ^ clkbuf_3_6_0_CLK/A (sky130_fd_sc_hd__clkbuf_16)
     2    0.04    0.06    0.20    0.47 ^ clkbuf_3_6_0_CLK/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_3_6_0_CLK (net)
                  0.06    0.00    0.47 ^ clkbuf_4_13__f_CLK/A (sky130_fd_sc_hd__clkbuf_16)
     8    0.13    0.14    0.21    0.68 ^ clkbuf_4_13__f_CLK/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_4_13__leaf_CLK (net)
                  0.14    0.00    0.68 ^ clkbuf_leaf_53_CLK/A (sky130_fd_sc_hd__clkbuf_16)
    13    0.04    0.06    0.18    0.86 ^ clkbuf_leaf_53_CLK/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_leaf_53_CLK (net)
                  0.06    0.00    0.86 ^ core.CPU_Xreg_value_a4[30][10]$_SDFFE_PP0P_/CLK (sky130_fd_sc_hd__dfxtp_1)
     2    0.01    0.15    0.38    1.24 ^ core.CPU_Xreg_value_a4[30][10]$_SDFFE_PP0P_/Q (sky130_fd_sc_hd__dfxtp_1)
                                         core.CPU_Xreg_value_a4[30][10] (net)
                  0.15    0.00    1.24 ^ _15427_/B2 (sky130_fd_sc_hd__a221oi_4)
     1    0.01    0.05    0.09    1.33 v _15427_/Y (sky130_fd_sc_hd__a221oi_4)
                                         _02493_ (net)
                  0.05    0.00    1.33 v _15433_/C (sky130_fd_sc_hd__nand4_1)
     1    0.01    0.12    0.14    1.47 ^ _15433_/Y (sky130_fd_sc_hd__nand4_1)
                                         _02499_ (net)
                  0.12    0.00    1.47 ^ _15435_/A3 (sky130_fd_sc_hd__o32ai_4)
     1    0.03    0.10    0.14    1.61 v _15435_/Y (sky130_fd_sc_hd__o32ai_4)
                                         _02501_ (net)
                  0.10    0.00    1.61 v _15438_/A2 (sky130_fd_sc_hd__o21ai_0)
     1    0.00    0.07    0.16    1.77 ^ _15438_/Y (sky130_fd_sc_hd__o21ai_0)
                                         core.CPU_src2_value_a2[10] (net)
                  0.07    0.00    1.77 ^ core.CPU_src2_value_a3[10]$_DFF_P_/D (sky130_fd_sc_hd__dfxtp_1)
                                  1.77   data arrival time

                          0.00    0.00   clock clk (rise edge)
                          0.00    0.00   clock source latency
     1    0.18    0.00    0.00    0.00 ^ pll/CLK (avsdpll)
                                         CLK (net)
                  0.02    0.01    0.01 ^ clkbuf_0_CLK/A (sky130_fd_sc_hd__clkbuf_16)
     8    0.22    0.22    0.25    0.26 ^ clkbuf_0_CLK/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_0_CLK (net)
                  0.22    0.00    0.26 ^ clkbuf_3_4_0_CLK/A (sky130_fd_sc_hd__clkbuf_16)
     2    0.04    0.06    0.20    0.47 ^ clkbuf_3_4_0_CLK/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_3_4_0_CLK (net)
                  0.06    0.00    0.47 ^ clkbuf_4_9__f_CLK/A (sky130_fd_sc_hd__clkbuf_16)
    15    0.21    0.22    0.27    0.74 ^ clkbuf_4_9__f_CLK/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_4_9__leaf_CLK (net)
                  0.22    0.00    0.74 ^ clkbuf_leaf_94_CLK/A (sky130_fd_sc_hd__clkbuf_16)
    15    0.05    0.07    0.21    0.94 ^ clkbuf_leaf_94_CLK/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_leaf_94_CLK (net)
                  0.07    0.00    0.94 ^ core.CPU_src2_value_a3[10]$_DFF_P_/CLK (sky130_fd_sc_hd__dfxtp_1)
                          0.86    1.80   clock uncertainty
                          0.00    1.80   clock reconvergence pessimism
                         -0.03    1.77   library hold time
                                  1.77   data required time
-----------------------------------------------------------------------------
                                  1.77   data required time
                                 -1.77   data arrival time
-----------------------------------------------------------------------------
                                  0.00   slack (MET)



==========================================================================
cts final report_checks -path_delay max
--------------------------------------------------------------------------
Startpoint: core.CPU_src2_value_a3[28]$_DFF_P_
            (rising edge-triggered flip-flop clocked by clk)
Endpoint: core.CPU_pc_a1[29]$_SDFF_PP0_
          (rising edge-triggered flip-flop clocked by clk)
Path Group: clk
Path Type: max

Fanout     Cap    Slew   Delay    Time   Description
-----------------------------------------------------------------------------
                          0.00    0.00   clock clk (rise edge)
                          0.00    0.00   clock source latency
     1    0.18    0.00    0.00    0.00 ^ pll/CLK (avsdpll)
                                         CLK (net)
                  0.02    0.01    0.01 ^ clkbuf_0_CLK/A (sky130_fd_sc_hd__clkbuf_16)
     8    0.22    0.22    0.25    0.26 ^ clkbuf_0_CLK/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_0_CLK (net)
                  0.22    0.00    0.26 ^ clkbuf_3_5_0_CLK/A (sky130_fd_sc_hd__clkbuf_16)
     2    0.04    0.07    0.21    0.47 ^ clkbuf_3_5_0_CLK/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_3_5_0_CLK (net)
                  0.07    0.00    0.47 ^ clkbuf_4_11__f_CLK/A (sky130_fd_sc_hd__clkbuf_16)
    17    0.23    0.23    0.28    0.75 ^ clkbuf_4_11__f_CLK/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_4_11__leaf_CLK (net)
                  0.23    0.00    0.75 ^ clkbuf_leaf_104_CLK/A (sky130_fd_sc_hd__clkbuf_16)
    14    0.04    0.07    0.21    0.96 ^ clkbuf_leaf_104_CLK/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_leaf_104_CLK (net)
                  0.07    0.00    0.96 ^ core.CPU_src2_value_a3[28]$_DFF_P_/CLK (sky130_fd_sc_hd__dfxtp_4)
     3    0.05    0.15    0.43    1.39 ^ core.CPU_src2_value_a3[28]$_DFF_P_/Q (sky130_fd_sc_hd__dfxtp_4)
                                         core.CPU_src2_value_a3[28] (net)
                  0.15    0.00    1.39 ^ _08637_/A (sky130_fd_sc_hd__inv_1)
     1    0.00    0.05    0.06    1.46 v _08637_/Y (sky130_fd_sc_hd__inv_1)
                                         _08260_ (net)
                  0.05    0.00    1.46 v _16672_/A (sky130_fd_sc_hd__ha_2)
     8    0.04    0.20    0.44    1.89 ^ _16672_/SUM (sky130_fd_sc_hd__ha_2)
                                         _08262_ (net)
                  0.20    0.00    1.89 ^ _08372_/B (sky130_fd_sc_hd__nand4_4)
     3    0.02    0.15    0.17    2.07 v _08372_/Y (sky130_fd_sc_hd__nand4_4)
                                         _03536_ (net)
                  0.15    0.00    2.07 v _08412_/A (sky130_fd_sc_hd__nor4_4)
     3    0.03    0.49    0.53    2.60 ^ _08412_/Y (sky130_fd_sc_hd__nor4_4)
                                         _03576_ (net)
                  0.49    0.00    2.60 ^ _08426_/C1 (sky130_fd_sc_hd__o311a_1)
     2    0.02    0.18    0.35    2.96 ^ _08426_/X (sky130_fd_sc_hd__o311a_1)
                                         _03590_ (net)
                  0.18    0.00    2.96 ^ _08427_/C (sky130_fd_sc_hd__nor3_4)
     2    0.03    0.10    0.10    3.05 v _08427_/Y (sky130_fd_sc_hd__nor3_4)
                                         _03591_ (net)
                  0.10    0.00    3.05 v _08434_/B2 (sky130_fd_sc_hd__a32oi_4)
     1    0.02    0.26    0.27    3.33 ^ _08434_/Y (sky130_fd_sc_hd__a32oi_4)
                                         _03598_ (net)
                  0.26    0.00    3.33 ^ _08438_/A2 (sky130_fd_sc_hd__a21o_4)
    33    0.16    0.44    0.45    3.77 ^ _08438_/X (sky130_fd_sc_hd__a21o_4)
                                         _03602_ (net)
                  0.44    0.02    3.80 ^ _14437_/B1_N (sky130_fd_sc_hd__a21boi_4)
    26    0.12    0.86    0.78    4.58 ^ _14437_/Y (sky130_fd_sc_hd__a21boi_4)
                                         _01617_ (net)
                  0.86    0.00    4.58 ^ _14537_/A1 (sky130_fd_sc_hd__a21oi_1)
     1    0.00    0.14    0.13    4.71 v _14537_/Y (sky130_fd_sc_hd__a21oi_1)
                                         _01692_ (net)
                  0.14    0.00    4.71 v hold1172/A (sky130_fd_sc_hd__dlygate4sd3_1)
     1    0.00    0.06    0.59    5.30 v hold1172/X (sky130_fd_sc_hd__dlygate4sd3_1)
                                         net1281 (net)
                  0.06    0.00    5.30 v _14538_/B1 (sky130_fd_sc_hd__a21oi_1)
     1    0.00    0.09    0.10    5.40 ^ _14538_/Y (sky130_fd_sc_hd__a21oi_1)
                                         _01561_ (net)
                  0.09    0.00    5.40 ^ hold1173/A (sky130_fd_sc_hd__dlygate4sd3_1)
     1    0.00    0.05    0.55    5.95 ^ hold1173/X (sky130_fd_sc_hd__dlygate4sd3_1)
                                         net1282 (net)
                  0.05    0.00    5.95 ^ core.CPU_pc_a1[29]$_SDFF_PP0_/D (sky130_fd_sc_hd__dfxtp_1)
                                  5.95   data arrival time

                         10.75   10.75   clock clk (rise edge)
                          0.00   10.75   clock source latency
     1    0.18    0.00    0.00   10.75 ^ pll/CLK (avsdpll)
                                         CLK (net)
                  0.02    0.01   10.76 ^ clkbuf_0_CLK/A (sky130_fd_sc_hd__clkbuf_16)
     8    0.22    0.22    0.25   11.01 ^ clkbuf_0_CLK/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_0_CLK (net)
                  0.22    0.00   11.01 ^ clkbuf_3_0_0_CLK/A (sky130_fd_sc_hd__clkbuf_16)
     2    0.04    0.06    0.20   11.22 ^ clkbuf_3_0_0_CLK/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_3_0_0_CLK (net)
                  0.06    0.00   11.22 ^ clkbuf_4_0__f_CLK/A (sky130_fd_sc_hd__clkbuf_16)
     7    0.10    0.12    0.19   11.41 ^ clkbuf_4_0__f_CLK/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_4_0__leaf_CLK (net)
                  0.12    0.00   11.41 ^ clkbuf_leaf_164_CLK/A (sky130_fd_sc_hd__clkbuf_16)
    11    0.04    0.06    0.17   11.58 ^ clkbuf_leaf_164_CLK/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_leaf_164_CLK (net)
                  0.06    0.00   11.58 ^ core.CPU_pc_a1[29]$_SDFF_PP0_/CLK (sky130_fd_sc_hd__dfxtp_1)
                         -0.54   11.04   clock uncertainty
                          0.00   11.04   clock reconvergence pessimism
                         -0.05   10.99   library setup time
                                 10.99   data required time
-----------------------------------------------------------------------------
                                 10.99   data required time
                                 -5.95   data arrival time
-----------------------------------------------------------------------------
                                  5.04   slack (MET)



==========================================================================
cts final report_checks -unconstrained
--------------------------------------------------------------------------
Startpoint: core.CPU_src2_value_a3[28]$_DFF_P_
            (rising edge-triggered flip-flop clocked by clk)
Endpoint: core.CPU_pc_a1[29]$_SDFF_PP0_
          (rising edge-triggered flip-flop clocked by clk)
Path Group: clk
Path Type: max

Fanout     Cap    Slew   Delay    Time   Description
-----------------------------------------------------------------------------
                          0.00    0.00   clock clk (rise edge)
                          0.00    0.00   clock source latency
     1    0.18    0.00    0.00    0.00 ^ pll/CLK (avsdpll)
                                         CLK (net)
                  0.02    0.01    0.01 ^ clkbuf_0_CLK/A (sky130_fd_sc_hd__clkbuf_16)
     8    0.22    0.22    0.25    0.26 ^ clkbuf_0_CLK/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_0_CLK (net)
                  0.22    0.00    0.26 ^ clkbuf_3_5_0_CLK/A (sky130_fd_sc_hd__clkbuf_16)
     2    0.04    0.07    0.21    0.47 ^ clkbuf_3_5_0_CLK/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_3_5_0_CLK (net)
                  0.07    0.00    0.47 ^ clkbuf_4_11__f_CLK/A (sky130_fd_sc_hd__clkbuf_16)
    17    0.23    0.23    0.28    0.75 ^ clkbuf_4_11__f_CLK/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_4_11__leaf_CLK (net)
                  0.23    0.00    0.75 ^ clkbuf_leaf_104_CLK/A (sky130_fd_sc_hd__clkbuf_16)
    14    0.04    0.07    0.21    0.96 ^ clkbuf_leaf_104_CLK/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_leaf_104_CLK (net)
                  0.07    0.00    0.96 ^ core.CPU_src2_value_a3[28]$_DFF_P_/CLK (sky130_fd_sc_hd__dfxtp_4)
     3    0.05    0.15    0.43    1.39 ^ core.CPU_src2_value_a3[28]$_DFF_P_/Q (sky130_fd_sc_hd__dfxtp_4)
                                         core.CPU_src2_value_a3[28] (net)
                  0.15    0.00    1.39 ^ _08637_/A (sky130_fd_sc_hd__inv_1)
     1    0.00    0.05    0.06    1.46 v _08637_/Y (sky130_fd_sc_hd__inv_1)
                                         _08260_ (net)
                  0.05    0.00    1.46 v _16672_/A (sky130_fd_sc_hd__ha_2)
     8    0.04    0.20    0.44    1.89 ^ _16672_/SUM (sky130_fd_sc_hd__ha_2)
                                         _08262_ (net)
                  0.20    0.00    1.89 ^ _08372_/B (sky130_fd_sc_hd__nand4_4)
     3    0.02    0.15    0.17    2.07 v _08372_/Y (sky130_fd_sc_hd__nand4_4)
                                         _03536_ (net)
                  0.15    0.00    2.07 v _08412_/A (sky130_fd_sc_hd__nor4_4)
     3    0.03    0.49    0.53    2.60 ^ _08412_/Y (sky130_fd_sc_hd__nor4_4)
                                         _03576_ (net)
                  0.49    0.00    2.60 ^ _08426_/C1 (sky130_fd_sc_hd__o311a_1)
     2    0.02    0.18    0.35    2.96 ^ _08426_/X (sky130_fd_sc_hd__o311a_1)
                                         _03590_ (net)
                  0.18    0.00    2.96 ^ _08427_/C (sky130_fd_sc_hd__nor3_4)
     2    0.03    0.10    0.10    3.05 v _08427_/Y (sky130_fd_sc_hd__nor3_4)
                                         _03591_ (net)
                  0.10    0.00    3.05 v _08434_/B2 (sky130_fd_sc_hd__a32oi_4)
     1    0.02    0.26    0.27    3.33 ^ _08434_/Y (sky130_fd_sc_hd__a32oi_4)
                                         _03598_ (net)
                  0.26    0.00    3.33 ^ _08438_/A2 (sky130_fd_sc_hd__a21o_4)
    33    0.16    0.44    0.45    3.77 ^ _08438_/X (sky130_fd_sc_hd__a21o_4)
                                         _03602_ (net)
                  0.44    0.02    3.80 ^ _14437_/B1_N (sky130_fd_sc_hd__a21boi_4)
    26    0.12    0.86    0.78    4.58 ^ _14437_/Y (sky130_fd_sc_hd__a21boi_4)
                                         _01617_ (net)
                  0.86    0.00    4.58 ^ _14537_/A1 (sky130_fd_sc_hd__a21oi_1)
     1    0.00    0.14    0.13    4.71 v _14537_/Y (sky130_fd_sc_hd__a21oi_1)
                                         _01692_ (net)
                  0.14    0.00    4.71 v hold1172/A (sky130_fd_sc_hd__dlygate4sd3_1)
     1    0.00    0.06    0.59    5.30 v hold1172/X (sky130_fd_sc_hd__dlygate4sd3_1)
                                         net1281 (net)
                  0.06    0.00    5.30 v _14538_/B1 (sky130_fd_sc_hd__a21oi_1)
     1    0.00    0.09    0.10    5.40 ^ _14538_/Y (sky130_fd_sc_hd__a21oi_1)
                                         _01561_ (net)
                  0.09    0.00    5.40 ^ hold1173/A (sky130_fd_sc_hd__dlygate4sd3_1)
     1    0.00    0.05    0.55    5.95 ^ hold1173/X (sky130_fd_sc_hd__dlygate4sd3_1)
                                         net1282 (net)
                  0.05    0.00    5.95 ^ core.CPU_pc_a1[29]$_SDFF_PP0_/D (sky130_fd_sc_hd__dfxtp_1)
                                  5.95   data arrival time

                         10.75   10.75   clock clk (rise edge)
                          0.00   10.75   clock source latency
     1    0.18    0.00    0.00   10.75 ^ pll/CLK (avsdpll)
                                         CLK (net)
                  0.02    0.01   10.76 ^ clkbuf_0_CLK/A (sky130_fd_sc_hd__clkbuf_16)
     8    0.22    0.22    0.25   11.01 ^ clkbuf_0_CLK/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_0_CLK (net)
                  0.22    0.00   11.01 ^ clkbuf_3_0_0_CLK/A (sky130_fd_sc_hd__clkbuf_16)
     2    0.04    0.06    0.20   11.22 ^ clkbuf_3_0_0_CLK/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_3_0_0_CLK (net)
                  0.06    0.00   11.22 ^ clkbuf_4_0__f_CLK/A (sky130_fd_sc_hd__clkbuf_16)
     7    0.10    0.12    0.19   11.41 ^ clkbuf_4_0__f_CLK/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_4_0__leaf_CLK (net)
                  0.12    0.00   11.41 ^ clkbuf_leaf_164_CLK/A (sky130_fd_sc_hd__clkbuf_16)
    11    0.04    0.06    0.17   11.58 ^ clkbuf_leaf_164_CLK/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_leaf_164_CLK (net)
                  0.06    0.00   11.58 ^ core.CPU_pc_a1[29]$_SDFF_PP0_/CLK (sky130_fd_sc_hd__dfxtp_1)
                         -0.54   11.04   clock uncertainty
                          0.00   11.04   clock reconvergence pessimism
                         -0.05   10.99   library setup time
                                 10.99   data required time
-----------------------------------------------------------------------------
                                 10.99   data required time
                                 -5.95   data arrival time
-----------------------------------------------------------------------------
                                  5.04   slack (MET)



==========================================================================
cts final report_check_types -max_slew -max_cap -max_fanout -violators
--------------------------------------------------------------------------

==========================================================================
cts final max_slew_check_slack
--------------------------------------------------------------------------
0.07420186698436737

==========================================================================
cts final max_slew_check_limit
--------------------------------------------------------------------------
1.5

==========================================================================
cts final max_slew_check_slack_limit
--------------------------------------------------------------------------
0.0495

==========================================================================
cts final max_fanout_check_slack
--------------------------------------------------------------------------
1.0000000150474662e+30

==========================================================================
cts final max_fanout_check_limit
--------------------------------------------------------------------------
1.0000000150474662e+30

==========================================================================
cts final max_capacitance_check_slack
--------------------------------------------------------------------------
0.01785619929432869

==========================================================================
cts final max_capacitance_check_limit
--------------------------------------------------------------------------
0.021067000925540924

==========================================================================
cts final max_capacitance_check_slack_limit
--------------------------------------------------------------------------
0.8476

==========================================================================
cts final max_slew_violation_count
--------------------------------------------------------------------------
max slew violation count 0

==========================================================================
cts final max_fanout_violation_count
--------------------------------------------------------------------------
max fanout violation count 0

==========================================================================
cts final max_cap_violation_count
--------------------------------------------------------------------------
max cap violation count 0

==========================================================================
cts final setup_violation_count
--------------------------------------------------------------------------
setup violation count 0

==========================================================================
cts final hold_violation_count
--------------------------------------------------------------------------
hold violation count 0

==========================================================================
cts final report_checks -path_delay max reg to reg
--------------------------------------------------------------------------
Startpoint: core.CPU_src2_value_a3[28]$_DFF_P_
            (rising edge-triggered flip-flop clocked by clk)
Endpoint: core.CPU_pc_a1[29]$_SDFF_PP0_
          (rising edge-triggered flip-flop clocked by clk)
Path Group: clk
Path Type: max

  Delay    Time   Description
---------------------------------------------------------
   0.00    0.00   clock clk (rise edge)
   0.00    0.00   clock source latency
   0.00    0.00 ^ pll/CLK (avsdpll)
   0.26    0.26 ^ clkbuf_0_CLK/X (sky130_fd_sc_hd__clkbuf_16)
   0.21    0.47 ^ clkbuf_3_5_0_CLK/X (sky130_fd_sc_hd__clkbuf_16)
   0.28    0.75 ^ clkbuf_4_11__f_CLK/X (sky130_fd_sc_hd__clkbuf_16)
   0.21    0.96 ^ clkbuf_leaf_104_CLK/X (sky130_fd_sc_hd__clkbuf_16)
   0.00    0.96 ^ core.CPU_src2_value_a3[28]$_DFF_P_/CLK (sky130_fd_sc_hd__dfxtp_4)
   0.43    1.39 ^ core.CPU_src2_value_a3[28]$_DFF_P_/Q (sky130_fd_sc_hd__dfxtp_4)
   0.07    1.46 v _08637_/Y (sky130_fd_sc_hd__inv_1)
   0.44    1.89 ^ _16672_/SUM (sky130_fd_sc_hd__ha_2)
   0.18    2.07 v _08372_/Y (sky130_fd_sc_hd__nand4_4)
   0.53    2.60 ^ _08412_/Y (sky130_fd_sc_hd__nor4_4)
   0.36    2.96 ^ _08426_/X (sky130_fd_sc_hd__o311a_1)
   0.10    3.05 v _08427_/Y (sky130_fd_sc_hd__nor3_4)
   0.27    3.33 ^ _08434_/Y (sky130_fd_sc_hd__a32oi_4)
   0.45    3.77 ^ _08438_/X (sky130_fd_sc_hd__a21o_4)
   0.81    4.58 ^ _14437_/Y (sky130_fd_sc_hd__a21boi_4)
   0.13    4.71 v _14537_/Y (sky130_fd_sc_hd__a21oi_1)
   0.59    5.30 v hold1172/X (sky130_fd_sc_hd__dlygate4sd3_1)
   0.10    5.40 ^ _14538_/Y (sky130_fd_sc_hd__a21oi_1)
   0.55    5.95 ^ hold1173/X (sky130_fd_sc_hd__dlygate4sd3_1)
   0.00    5.95 ^ core.CPU_pc_a1[29]$_SDFF_PP0_/D (sky130_fd_sc_hd__dfxtp_1)
           5.95   data arrival time

  10.75   10.75   clock clk (rise edge)
   0.00   10.75   clock source latency
   0.00   10.75 ^ pll/CLK (avsdpll)
   0.26   11.01 ^ clkbuf_0_CLK/X (sky130_fd_sc_hd__clkbuf_16)
   0.20   11.22 ^ clkbuf_3_0_0_CLK/X (sky130_fd_sc_hd__clkbuf_16)
   0.20   11.41 ^ clkbuf_4_0__f_CLK/X (sky130_fd_sc_hd__clkbuf_16)
   0.17   11.58 ^ clkbuf_leaf_164_CLK/X (sky130_fd_sc_hd__clkbuf_16)
   0.00   11.58 ^ core.CPU_pc_a1[29]$_SDFF_PP0_/CLK (sky130_fd_sc_hd__dfxtp_1)
  -0.54   11.04   clock uncertainty
   0.00   11.04   clock reconvergence pessimism
  -0.05   10.99   library setup time
          10.99   data required time
---------------------------------------------------------
          10.99   data required time
          -5.95   data arrival time
---------------------------------------------------------
           5.04   slack (MET)



==========================================================================
cts final report_checks -path_delay min reg to reg
--------------------------------------------------------------------------
Startpoint: core.CPU_Xreg_value_a4[30][10]$_SDFFE_PP0P_
            (rising edge-triggered flip-flop clocked by clk)
Endpoint: core.CPU_src2_value_a3[10]$_DFF_P_
          (rising edge-triggered flip-flop clocked by clk)
Path Group: clk
Path Type: min

  Delay    Time   Description
---------------------------------------------------------
   0.00    0.00   clock clk (rise edge)
   0.00    0.00   clock source latency
   0.00    0.00 ^ pll/CLK (avsdpll)
   0.26    0.26 ^ clkbuf_0_CLK/X (sky130_fd_sc_hd__clkbuf_16)
   0.21    0.47 ^ clkbuf_3_6_0_CLK/X (sky130_fd_sc_hd__clkbuf_16)
   0.21    0.68 ^ clkbuf_4_13__f_CLK/X (sky130_fd_sc_hd__clkbuf_16)
   0.18    0.86 ^ clkbuf_leaf_53_CLK/X (sky130_fd_sc_hd__clkbuf_16)
   0.00    0.86 ^ core.CPU_Xreg_value_a4[30][10]$_SDFFE_PP0P_/CLK (sky130_fd_sc_hd__dfxtp_1)
   0.38    1.24 ^ core.CPU_Xreg_value_a4[30][10]$_SDFFE_PP0P_/Q (sky130_fd_sc_hd__dfxtp_1)
   0.09    1.33 v _15427_/Y (sky130_fd_sc_hd__a221oi_4)
   0.14    1.47 ^ _15433_/Y (sky130_fd_sc_hd__nand4_1)
   0.14    1.61 v _15435_/Y (sky130_fd_sc_hd__o32ai_4)
   0.16    1.77 ^ _15438_/Y (sky130_fd_sc_hd__o21ai_0)
   0.00    1.77 ^ core.CPU_src2_value_a3[10]$_DFF_P_/D (sky130_fd_sc_hd__dfxtp_1)
           1.77   data arrival time

   0.00    0.00   clock clk (rise edge)
   0.00    0.00   clock source latency
   0.00    0.00 ^ pll/CLK (avsdpll)
   0.26    0.26 ^ clkbuf_0_CLK/X (sky130_fd_sc_hd__clkbuf_16)
   0.20    0.47 ^ clkbuf_3_4_0_CLK/X (sky130_fd_sc_hd__clkbuf_16)
   0.27    0.74 ^ clkbuf_4_9__f_CLK/X (sky130_fd_sc_hd__clkbuf_16)
   0.21    0.94 ^ clkbuf_leaf_94_CLK/X (sky130_fd_sc_hd__clkbuf_16)
   0.00    0.94 ^ core.CPU_src2_value_a3[10]$_DFF_P_/CLK (sky130_fd_sc_hd__dfxtp_1)
   0.86    1.80   clock uncertainty
   0.00    1.80   clock reconvergence pessimism
  -0.03    1.77   library hold time
           1.77   data required time
---------------------------------------------------------
           1.77   data required time
          -1.77   data arrival time
---------------------------------------------------------
           0.00   slack (MET)



==========================================================================
cts final critical path target clock latency max path
--------------------------------------------------------------------------
0

==========================================================================
cts final critical path target clock latency min path
--------------------------------------------------------------------------
0

==========================================================================
cts final critical path source clock latency min path
--------------------------------------------------------------------------
0

==========================================================================
cts final critical path delay
--------------------------------------------------------------------------
5.9498

==========================================================================
cts final critical path slack
--------------------------------------------------------------------------
5.0363

==========================================================================
cts final slack div critical path delay
--------------------------------------------------------------------------
84.646543

==========================================================================
cts final report_power
--------------------------------------------------------------------------
Group                  Internal  Switching    Leakage      Total
                          Power      Power      Power      Power (Watts)
----------------------------------------------------------------
Sequential             7.93e-03   1.25e-03   1.60e-08   9.17e-03  37.7%
Combinational          2.70e-03   5.49e-03   3.14e-08   8.19e-03  33.6%
Clock                  3.94e-03   3.04e-03   3.18e-09   6.98e-03  28.7%
Macro                  0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.0%
Pad                    0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.0%
----------------------------------------------------------------
Total                  1.46e-02   9.77e-03   5.06e-08   2.43e-02 100.0%
                          59.8%      40.2%       0.0%


```


```
make DESIGN_CONFIG=./designs/sky130hd/vsdbabysoc/config.mk route
```







 
</details>
