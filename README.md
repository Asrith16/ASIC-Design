# ASIC-Design
---
<details>
  <summary><strong>Lab 1:Cprogram compilation.</strong> </summary>
  
# Lab 1A:Create a simple C program to find the sum of the numbers from 1 to n.
### Step 1:
Use the Leafpad editor to write the C code. You can install Leafpad using the following command:<br>
``sudo snap install leafpad``<br>
Create a file named ``sum1ton.c``<br>
![Screenshot 2024-08-07 144122](https://github.com/user-attachments/assets/dd646c7a-636a-45bc-9097-cfe4378df4a9)
### Step 2:
Write c program to find the sum of the numbers from 1 to n.<br>
For an example set the value of n to 45.<br>
Save the file in Leafpad and return to the terminal.
```
#include<stdio.h>
int main(){
  int sum=0;
  int n=100;
  for(int i=1;i<=n;i++){
    sum=sum+i;
  }
  printf("sum of the numbers form 1 to %d is %d",n,sum);
  return 0;
}
```
![Screenshot 2024-08-07 215530](https://github.com/user-attachments/assets/b390cc4f-aa0e-4121-9597-f53345261c88)

### Step 3:
For the compilation of the code, use the following command:<br>
``GCC sum1ton.c``<br>
Make sure there are no errors.<br>
After compilation, an executable file is generated. Run this executable in the terminal to get the final output using the following command:<br>
``./a.out``<br>
![Screenshot 2024-08-07 215759](https://github.com/user-attachments/assets/66bd1819-3ec7-4192-99f0-54b03fa1e782)

The final output will be:<br>
`` Sum of the numbers form 1 to 100 is 5050.``
Check the output using a calculator to verify the result.

# Lab 1B:Compile the same C program using the RISC-V GCC compiler.
### Step 1:
To run the same C program file use the below command:<br>
`` riscv64-unknown-elf-gcc -O1 -mabi=lp64 -march=rv64i -o Lab1.o Lab1.c`` <br>
After compilation it will generate a file named sum1ton.o<br>
![Screenshot 2024-08-07 154120](https://github.com/user-attachments/assets/11f8bea0-3719-4b5b-9c91-446d28cef16d)
### step 2:
To get the aasembly code run the following command:<br>
``riscv64-unkown-elf-objdump -d Lab1.o ``
We will get a large output of code, but we are only interested in the main section. To view just the main section, add | less to the previous command.
`` riscv64-unkown-elf-objdump -d Lab1.o |less``
![Screenshot 2024-08-07 154806](https://github.com/user-attachments/assets/9fcef9a3-4598-479b-9efa-09ab9e3ea56b)<br>

After running the second command, we will get some output. Since we are interested in the main section, search for "main." We will see a bunch of instructions in the main snippet. To count the number of instructions, subtract the address of the first instruction from that of the next section, then divide by 4 (as the increment at each step is 4). This method reveals that there are 15 instructions when we are using O1. We can recheck this using a calculator as well.<br>
![Screenshot 2024-08-07 160155](https://github.com/user-attachments/assets/39208124-f050-4b7c-82f2-f789259dd133)<br>

Now, move back to the first terminal. Here, change the optimization level from `-O1` to `-Ofast` and follow the same procedure as above.<br>
![Screenshot 2024-08-07 160617](https://github.com/user-attachments/assets/dc9393fe-82fe-4a1c-a19f-8b45debbcb6d)<br>

Here, if we use `-Ofast` instead of `-O1`, we get only 12 instructions. Therefore, the number of instructions changes with the optimization level.<br>
![Screenshot 2024-08-07 160729](https://github.com/user-attachments/assets/73b6bcaa-2ca8-4330-b5aa-4f5a1ff4257b)<br>
For `O2`, the number of instructions are 12.<br>
Using `-Ofast` reduces our set of instructions because this optimization level applies a broader range of aggressive optimizations. These optimizations streamline the code, eliminate redundancies, and leverage parallelism, resulting in a lower instruction count compared to `-O1`.<br>
</details>

---

<details>
  <summary><strong>Lab2 :RISC-V Spike simulator.</strong></summary>
  
# Lab 2:Running the Object File Generated by the RISC-V GCC Compiler with the Spike Simulator.
We will compile the object dump file using the RISC-V GCC compiler and check the output against the GCC results from Lab 1. This includes debugging the main part of the program and watching the register values after each step. By looking closely at these values, we can understand how the program behaves and how different compilation stages affect it. This helps make sure the compiled output is accurate and consistent across different compiler settings.<br>
1. For executing an object file created by RISC-V compiler use the below command in the terminal.<br>
```spike pk sum1ton.o```<br>
![Screenshot 2024-08-07 181544](https://github.com/user-attachments/assets/f145ba38-f692-426f-b639-862219a9da23)<br>
2. The following command will help us enter debugging mode using the Spike simulator:<br>
```spike -d pk sum1ton.o```<br>
Use the following command to jump to the beginning of the main section:<br>
``` until pc 0 0x100b0```<br>
![Screenshot 2024-08-07 182238](https://github.com/user-attachments/assets/c0c1d00d-f2ea-481b-8111-2e21f3fe2823)<br>
![Screenshot 2024-08-07 184013](https://github.com/user-attachments/assets/cb1696fb-0d6f-4017-a3ad-a7e51376a026)<br>

3. To check any register value the following command is used:
   ```reg 0 a0```<br>
   Press enter to run the next instruction.
   Here the next instruction is ``lui a2 0x1``, which load upper bits of a2 by 01.<br>
   Intially value of a2 register is 0x0000000000000000.<br>
   After the first instruction it has changed to 0x0000000000001000.<br>
![Screenshot 2024-08-07 183148](https://github.com/user-attachments/assets/1021f417-9713-4e2c-bb46-ee4d9c1c7149)
4. The next instructions are:<br>
   ``lui a0 0x21`` which updates the a0 register value<br>
   ``addi sp sp -16`` This updates the content of the stack pointer 'sp' by -16 (or -10 in hexadecimal).<br>
   ![Screenshot 2024-08-07 185218](https://github.com/user-attachments/assets/dd1798a5-9fdc-44e0-8bfc-d82f64d3793c)<br>
   In the above image we can see that intially sp value is 0x0000003ffffffb50.<br
   After the addi instruction sp value is 0x0000003ffffffb40.<br>
  We can recheck using the calculator. <br>
![Screenshot 2024-08-07 185623](https://github.com/user-attachments/assets/d5b753c4-3ee7-4f0c-9eaf-66802fb67ec1)<br>
</details>

---

<details>
  <summary><strong>Lab 3:RISC-V Instructions</strong></summary>
  
# Lab 3: Overview of RISC-V Instruction Formats.
The RISC-V architecture employs six distinct instruction formats—R-Type, I-Type, S-Type, B-Type, U-Type, and J-Type—each designed for particular operations such as arithmetic and logic processing, immediate value handling, branching, memory access, and jumps. These formats are crucial in specifying the 32-bit instruction codes that drive the RISC-V system.These formats differ in their structure and the kind of operations they facilitate. Below is a detailed breakdown of each format:<br>
![WhatsApp Image 2024-08-10 at 23 31 46_35a88ac2](https://github.com/user-attachments/assets/63377927-7d1a-4f39-8c51-250e2d3f3a42)


### 1) R-Type (Register Type)
**Purpose:** The R-Type format is used for operations like arithmetic and logic that only involve register values. These operations don’t need immediate values or memory access, making them direct and efficient.

**Structure:**
- **Opcode (7 bits):** Instructs the processor on what operation to carry out, such as arithmetic or logic tasks.
- **funct3 (3 bits):** Works with `funct7` to specify the exact operation (e.g., add, subtract, AND, OR).
- **rs1 (5 bits):** The first source register that holds the first operand.
- **rs2 (5 bits):** The second source register that holds the second operand.
- **rd (5 bits):** The destination register where the result is stored.
- **funct7 (7 bits):** Used together with `funct3` to define the operation more accurately, especially to differentiate between similar tasks.

### 2) I-Type (Immediate Type)
**Purpose:** The I-Type format is used for operations that involve an immediate value (a constant within the instruction), loading from memory, and certain arithmetic tasks.

**Structure:**
- **Opcode (7 bits):** Defines the type of operation, such as arithmetic with an immediate value or loading from memory.
- **funct3 (3 bits):** Further specifies the operation, like adding with an immediate value or loading a byte from memory.
- **rs1 (5 bits):** The source register that provides the operand for arithmetic tasks.
- **rd (5 bits):** The destination register where the result is stored.
- **Immediate (12 bits):** The signed immediate value used in the operation, often for offset calculation or as an operand.

### 3) S-Type (Store Type)
**Purpose:** The S-Type format is used for store operations, where data is written from a register to a memory location. This is crucial for storing data in RAM or other memory areas.

**Structure:**
- **Opcode (7 bits):** Specifies the type of store operation, such as storing a word (32-bit) or a byte.
- **funct3 (3 bits):** Further defines the store operation, indicating whether it’s a byte, half-word, or word store.
- **rs1 (5 bits):** The base register that holds the address where the data will be stored.
- **rs2 (5 bits):** The source register that contains the data to be stored.
- **Immediate (12 bits):** The immediate value, split into two parts, that provides the offset to the base address for the store operation.

### 4) B-Type (Branch Type)
**Purpose:** The B-Type format handles conditional branch operations, allowing the program to jump to a different part of the code based on a comparison between two registers. This is key for control flow structures like loops and conditional statements.

**Structure:**
- **Opcode (7 bits):** Specifies the branch operation.
- **funct3 (3 bits):** Indicates the type of comparison (e.g., equal, not equal, less than).
- **rs1 (5 bits):** The first source register involved in the comparison.
- **rs2 (5 bits):** The second source register involved in the comparison.
- **Immediate (12 bits):** A signed offset used to calculate the branch target address. The immediate is split across the instruction fields and combined to compute the jump destination.

### 5) U-Type (Upper Immediate Type)
**Purpose:** The U-Type format is used for operations that require a large immediate value to be loaded into a register, often for constructing addresses or large constants. It allows loading a 20-bit immediate value into the upper 20 bits of a register.

**Structure:**
- **Opcode (7 bits):** Specifies the operation, such as loading an upper immediate value.
- **rd (5 bits):** The destination register where the upper immediate value will be stored.
- **Immediate (20 bits):** The upper immediate value that will be loaded into the register. The lower 12 bits of the register are typically zeroed out or combined with other operations.

### 6) J-Type (Jump Type)
**Purpose:** The J-Type format is used for jump operations, enabling the program to jump to a specific address unconditionally. This is essential for function calls, jump tables, and other control flow changes that require an absolute change in program flow.

**Structure:**
- **Opcode (7 bits):** Specifies the jump operation.
- **rd (5 bits):** The destination register where the return address will be stored, allowing the program to return to the point after the jump.
- **Immediate (20 bits):** A signed offset used to calculate the target address for the jump. The immediate is spread across multiple fields in the instruction and combined to form the jump target.

<img width="772" alt="3808 1535301636" src="https://github.com/user-attachments/assets/d0f05dac-2191-4ade-89f6-8b371a1e3a29">

## Identifying RISC-V Instruction Types (R, I, S, B, U, J) and Determining the Exact 32-bit Instruction Encoding.
```
ADD r5, r4, r5
SUB r5, r5, r4
AND r4, r5, r5
OR r8, r4, r5
XOR r8, r5, r4
SLT r10, r2, r4
ADDI r12, r3, 5
SW r3, r1, 4
SRL r16, r11, r2
BNE r0, r1, 20
BEQ r0, r0, 15
LW r13, r11, 2
SLL r15, r11, r2
```

### 1. `ADD r5, r4, r5`
- **Opcode:** `0110011`
- **rd:** `r5 = 00101`
- **rs1:** `r4 = 00100`
- **rs2:** `r5 = 00101`
- **funct3:** `000`
- **funct7:** `0000000`
- **Instruction Type:** R-Type
- **32-bit Instruction:** `0000000_00101_00100_000_00101_0110011`
- **Hexadecimal Representation:** `0x005202B3`

### 2. `SUB r5, r5, r4`
- **Opcode:** `0110011`
- **rd:** `r5 = 00101`
- **rs1:** `r5 = 00101`
- **rs2:** `r4 = 00100`
- **funct3:** `000`
- **funct7:** `0100000`
- **Instruction Type:** R-Type
- **32-bit Instruction:** `0100000_00100_00101_000_00101_0110011`
- **Hexadecimal Representation:** `0x404282B3`

### 3. `AND r4, r5, r5`
- **Opcode:** `0110011`
- **rd:** `r4 = 00100`
- **rs1:** `r5 = 00101`
- **rs2:** `r5 = 00101`
- **funct3:** `111`
- **funct7:** `0000000`
- **Instruction Type:** R-Type
- **32-bit Instruction:** `0000000_00101_00101_111_00100_0110011`
- **Hexadecimal Representation:** `0x0052F233`

### 4. `OR r8, r4, r5`
- **Opcode:** `0110011`
- **rd:** `r8 = 01000`
- **rs1:** `r4 = 00100`
- **rs2:** `r5 = 00101`
- **funct3:** `110`
- **funct7:** `0000000`
- **Instruction Type:** R-Type
- **32-bit Instruction:** `0000000_00101_00100_110_01000_0110011`
- **Hexadecimal Representation:** `0x00526433`

### 5. `XOR r8, r5, r4`
- **Opcode:** `0110011`
- **rd:** `r8 = 01000`
- **rs1:** `r5 = 00101`
- **rs2:** `r4 = 00100`
- **funct3:** `100`
- **funct7:** `0000000`
- **Instruction Type:** R-Type
- **32-bit Instruction:** `0000000_00100_00101_100_01000_0110011`
- **Hexadecimal Representation:** `0x0042C433`

### 6. `SLT r10, r2, r4`
- **Opcode:** `0110011`
- **rd:** `r10 = 01010`
- **rs1:** `r2 = 00010`
- **rs2:** `r4 = 00100`
- **funct3:** `010`
- **funct7:** `0000000`
- **Instruction Type:** R-Type
- **32-bit Instruction:** `0000000_00100_00010_010_01010_0110011`
- **Hexadecimal Representation:** `0x00412533`

### 7. `ADDI r12, r3, 5`
- **Opcode:** `0010011`
- **rd:** `r12 = 01100`
- **rs1:** `r3 = 00011`
- **Immediate:** `000000000101`
- **funct3:** `000`
- **Instruction Type:** I-Type
- **32-bit Instruction:** `000000000101_00011_000_01100_0010011`
- **Hexadecimal Representation:** `0x00518613`

### 8. `SW r3, r1, 4`
- **Opcode:** `0100011`
- **rs1:** `r1 = 00001`
- **rs2:** `r3 = 00011`
- **Immediate:** `000000000100`
- **funct3:** `010`
- **Instruction Type:** S-Type
- **32-bit Instruction:** `0000000_00011_00001_010_00100_0100011`
- **Hexadecimal Representation:** `0x0030A223`

### 9. `SRL r16, r11, r2`
- **Opcode:** `0110011`
- **rd:** `r16 = 10000`
- **rs1:** `r11 = 01011`
- **rs2:** `r2 = 00010`
- **funct3:** `101`
- **funct7:** `0000000`
- **Instruction Type:** R-Type
- **32-bit Instruction:** `0000000_00010_01011_101_10000_0110011`
- **Hexadecimal Representation:** `0x0025D833`

### 10. `BNE r0, r1, 20`
- **Opcode:** `1100011`
- **rs1:** `r1 = 00001`
- **rs2:** `r0 = 00000`
- **Immediate:** `000000000101`
- **funct3:** `001`
- **Instruction Type:** B-Type
- **32-bit Instruction:** `0_000001_00001_00000_001_0100_0_1100011`
- **Hexadecimal Representation:** `0x02101463`

### 11. `BEQ r0, r0, 15`
- **Opcode:** `1100011`
- **rs1:** `r0 = 00000`
- **rs2:** `r0 = 00000`
- **Immediate:** `000000000111`
- **funct3:** `000`
- **Instruction Type:** B-Type
- **32-bit Instruction:** `0_000000_00000_00000_000_1111_0_1100011`
- **Hexadecimal Representation:** `0x00000F63`

### 12. `LW r13, r11, 2`
- **Opcode:** `0000011`
- **rd:** `r13 = 01101`
- **rs1:** `r11 = 01011`
- **Immediate:** `000000000010`
- **funct3:** `010`
- **Instruction Type:** I-Type
- **32-bit Instruction:** `000000000010_01011_010_01101_0000011`
- **Hexadecimal Representation:** `0x0025A683`

### 13. `SLL r15, r11, r2`
- **Opcode:** `0110011`
- **rd:** `r15 = 01111`
- **rs1:** `r11 = 01011`
- **rs2:** `r2 = 00010`
- **funct3:** `001`
- **funct7:** `0000000`
- **Instruction Type:** R-Type
- **32-bit Instruction:** `0000000_00010_01011_001_01111_0110011`
- **Hexadecimal Representation:** `0x002597B3`

## Summary of RISC-V Instructions

| Instruction        | Type   | 32-bit Representation                       | Hexadecimal Representation |
|--------------------|--------|---------------------------------------------|----------------------------|
| `ADD r5, r4, r5`   | R-Type | `0000000_00101_00100_000_00101_0110011`     | `0x005202B3`               |
| `SUB r5, r5, r4`   | R-Type | `0100000_00100_00101_000_00101_0110011`     | `0x404282B3`               |
| `AND r4, r5, r5`   | R-Type | `0000000_00101_00101_111_00100_0110011`     | `0x0052F233`               |
| `OR r8, r4, r5`    | R-Type | `0000000_00101_00100_110_01000_0110011`     | `0x00526433`               |
| `XOR r8, r5, r4`   | R-Type | `0000000_00100_00101_100_01000_0110011`     | `0x0042C433`               |
| `SLT r10, r2, r4`  | R-Type | `0000000_00100_00010_010_01010_0110011`     | `0x00412533`               |
| `ADDI r12, r3, 5`  | I-Type | `000000000101_00011_000_01100_0010011`      | `0x00518613`               |
| `SW r3, r1, 4`     | S-Type | `0000000_00011_00001_010_00100_0100011`     | `0x0030A223`               |
| `SRL r16, r11, r2` | R-Type | `0000000_00010_01011_101_10000_0110011`     | `0x0025D833`               |
| `BNE r0, r1, 20`   | B-Type | `0_000001_00001_00000_001_0100_0_1100011`     | `0x02101463`               |
| `BEQ r0, r0, 15`   | B-Type | `0_000000_00000_00000_000_1111_0_1100011`     | `0x00000F63`               |
| `LW r13, r11, 2`   | I-Type | `000000000010_01011_010_01101_0000011`      | `0x0025A683`               |
| `SLL r15, r11, r2` | R-Type | `0000000_00010_01011_001_01111_0110011`     | `0x002597B3`               |


</details>

---

<details>
  <summary><strong> Lab 4:Results with GTKWave</strong></summary>
  
#  Lab 4:Visualizing Functional Simulation Results with GTKWave
In the provided Verilog code, the RISC-V instructions are represented with some variations compared to the standard RISC-V ISA. Specifically, each instruction type is assigned a unique opcode in the Verilog implementation. The `func3` and `func7` values, which are used to identify the specific operation, also differ from the standard RISC-V ISA. Notably, `func7` is employed to differentiate between operations involving immediate values and other arithmetic functions; if `func7` is not required for this distinction, it is set to 0 in the Verilog code. The table below illustrates how the 32-bit instruction patterns are hardcoded using these opcodes, `func3`, and `func7` values as defined in the Verilog code.<br>

## Hardcoded table based on the provided Verilog code
| Instruction     | Hardcoded 32bit pattern | Hardcoded hexadecimal pattern| 32bit pattern   | Hexadecimal pattern |
|-----------------|-------------------------|------------------------------|---------------------|---------------|
| ADD r5, r4, r5  | 0000001_00101_00100_000_00101_0000000 | 0x02520280 | 0000000_00101_00100_000_00101_0110011  | 0x005202B3 |
| SUB r5, r5, r4  | 0000001_00100_00101_001_00101_0000000 | 0x02429280  | 0100000_00100_00101_000_00101_0110011  | 0x404282B3      |
| AND r4, r5, r5  | 0000001_00101_00101_010_00100_0000000 | 0x0252A200 |0000000_00101_00101_111_00100_0110011  | 0x0052F233     |
| OR r8, r4, r5  | 0000001_00101_00100_011_01000_0000000  | 0x02523400 |0000000_00101_00100_110_01000_0110011  | 0x00526433      |
| XOR r8, r5, r4  | 0000001_00100_00101_100_01000_0000000 | 0x0242C400 |0000000_00100_00101_100_01000_0110011  | 0x0042C433      |
| SLT r10, r2, r4  | 0000001_00100_00010_101_01010_0000000| 0x02415500 | 0000000_00100_00010_010_01010_0110011  | 0x00412533      |
| ADDI r12, r3, 5  | 000000000101_00011_000_01100_0000000 | 0x00518600 |000000000101_00011_000_01100_0010011  | 0x00518613      |
| SW r3, r1, 4  | 0000000_00011_00001_001_00100_0000001   | 0X00309201| 0000000_00011_00001_010_00100_0100011  | 0x0030A223     |
| LW r13, r11, 2  | 000000000010_01011_000_01101_0000001   | 0x0258681 |000000000010_01011_010_01101_0000011  | 0x0025A683      |
| BEQ r0, r0, 15  | 0_000000_00000_00000_000_1111_0_1100011   | 0X00f00002 |0_000000_00000_00000_000_1111_0_1100011  | 0x00000F63      |
| SRL r16, r11, r2  | 0000000_00010_01011_001_10000_0000011 |0x00259803  | 0000000_00010_01011_101_10000_0110011 | 0x0025D833      |

## Output Waveforms for the instructions provided in the verilog code:

| Operation          | Standard RISCV ISA | Hardcoded ISA |
|--------------------|---------------------|---------------|
| ADD R6, R1, R2     | 0x00110333        | 0x02208300  |
| SUB R7, R1, R2     | 0x402083b3        | 0x02209380  |
| AND R8, R1, R3     | 0x0030f433        | 0x0230a400  |
| OR R9, R2, R5      | 0x005164b3        | 0x02513480  |
| XOR R10, R1, R4    | 0x0040c533        | 0x0240c500  |
| SLT R11, R2, R4     | 0x0045a0b3        | 0x02415580  |
| ADDI R12, R4, 5    | 0x004120b3        | 0x00520600  |
| BEQ R0, R0, 15     | 0x00000f63        | 0x00f00002  |
| SW R3, R1, 2       | 0x0030a123        | 0x00209181  |
| LW R13, R1, 2      | 0x0020a683        | 0x00208681  |
| ADD R14, R2, R2    | 0x00210733         | 0x00210700  |

### Wave forms
``` ADD R6,R1,R2 ```<br>

![Screenshot 2024-08-12 190747](https://github.com/user-attachments/assets/65b65e0f-c0a6-47c9-bc7c-2764d2083987)

``` SUB R7,R1,R2```<br>

![Screenshot 2024-08-12 191520](https://github.com/user-attachments/assets/e21346eb-6dd0-41d3-b0f0-0912873312cd)

```AND R8,R1,R3```<br>

![Screenshot 2024-08-12 191918](https://github.com/user-attachments/assets/b3105bb2-ebf6-4e55-8625-19ecf0829432)


``` OR R9,R2,R5```<br>

![Screenshot 2024-08-12 192010](https://github.com/user-attachments/assets/f208c33c-d457-4cc8-8c42-25492ba113ee)


``` XOR R10,R1,R4```<br>

![Screenshot 2024-08-12 192041](https://github.com/user-attachments/assets/82d42570-0a06-4e38-b036-2e86a75ba284)


```SLT R11,R2,R4```<br>
![Screenshot 2024-08-12 192105](https://github.com/user-attachments/assets/fda0c504-de9a-4ffd-9165-551b6147a055)

```ADDI R12,R4,5```<br>

![Screenshot 2024-08-12 192136](https://github.com/user-attachments/assets/125fa7b9-0683-4aba-afd4-17b2415318f4)


```BEQ R0,R0,15```<br>
![Screenshot 2024-08-12 192202](https://github.com/user-attachments/assets/c89e8614-962d-4514-ba2e-aac9573dc578)


``` SW R3,R1,2```<br>

![Screenshot 2024-08-12 192259](https://github.com/user-attachments/assets/5227f230-3623-457a-8591-d1acae01da30)


```LW R13, R1, 2 ```<br>

![Screenshot 2024-08-12 192407](https://github.com/user-attachments/assets/9197cc14-8ce6-464a-93f4-62b6b9514cc8)


```ADD R14, R2, R2```<br>

![Screenshot 2024-08-12 192457](https://github.com/user-attachments/assets/80c63b58-e584-4539-81c2-d202864b357a)


Output form:<br>

![Screenshot 2024-08-12 192601](https://github.com/user-attachments/assets/964f03ae-ccbd-4a26-a117-703cae7b548f)


</details>

---


<details>
  <summary><strong> Lab 5: RISC-V GCC and GCC Compiler</strong></summary>
  
# Comparing Output Consistency Between RISC-V GCC and GCC Compiler

The code provided is a Palindrome Checker where the user inputs an integer, and the program checks whether the number is a palindrome. The program reverses the digits of the input number and compares the reversed number with the original. If both are identical, the number is identified as a palindrome; otherwise, it is not.<br>
<br>
![Screenshot 2024-08-14 203937](https://github.com/user-attachments/assets/0aed22de-b6cb-4551-becb-32197dc06697)

The image below displays the output produced when the C code is executed using a standard GCC compiler:<br>

![Screenshot 2024-08-14 204553](https://github.com/user-attachments/assets/440881db-fab0-4e59-86e2-4da259a753c5)

The image below displays the output generated when the C code is executed using a RISC-V GCC compiler:<br>

![Screenshot 2024-08-14 205024](https://github.com/user-attachments/assets/f13f862e-de61-4c15-9491-d080ffb1710c)


By examining the images above, we can observe that the output is identical when using both the GCC and RISC-V GCC compilers. This consistency indicates that the code behaves as expected across different compiler architectures, ensuring reliability and compatibility in various development environments. This demonstrates that the program's logic is platform-independent and confirms the accuracy of the compilation process on both compilers.


  
</details>

---

<details>
  <summary><strong>Lab 6: 5 Stage pipelined RISC-V processor  </strong></summary>

  <details>
  <summary><strong>Day 3</strong></summary>

# Designing Digital Logic with TL-Verilog using Makerchip

### Logic Gates
Logic gates are the fundamental building blocks of digital circuits, executing vital logical operations on binary inputs. These gates are crucial for designing intricate systems such as processors, memory units, and controllers. In digital circuits, logic gates work with binary signals, where "0" represents low voltage and "1" represents high voltage. They process one or more input signals to generate an output signal according to defined logical functions.<br>

![Screenshot 2024-08-21 093753](https://github.com/user-attachments/assets/28ddbce8-c199-4daa-93f3-fc8d0773913e)<br>

### Makerchip
Makerchip IDE is a robust tool for digital design, providing an all-in-one environment for coding, simulating, and testing HDL designs. It supports languages such as TL-Verilog, SystemVerilog, Verilog, and VHDL, offering a visual platform for real-time construction and simulation of digital systems. With its user-friendly interface and comprehensive features, Makerchip is suitable for both beginners and seasoned designers. Makerchip enables efficient prototyping, debugging, and refinement of digital designs, ensuring that circuits perform correctly before transitioning to hardware implementation.<br>


### Transaction Level (TL) - Verilog:
TL Verilog is a contemporary extension of traditional Verilog, developed by Redwood EDA to streamline hardware modeling and design. It offers a more abstract and efficient syntax while maintaining compatibility with standard Verilog. TL-Verilog facilitates transaction-level modeling, simplifying the management of complex microarchitectures. In this method, a transaction progresses through the architecture, interacting with components such as pipelines, arbiters, and queues. TL-Verilog is especially effective in minimizing bugs and optimizing design, particularly when used with tools like Makerchip.<br>


## Some Basic Combinational circuits:
### Name of clock signal is clr_asr
### 1. Inverter:
   The resulting block diagram and waveforms are presented as depicted:<br>
   ![Screenshot 2024-08-21 152754](https://github.com/user-attachments/assets/2867695f-706b-4047-9662-dc6c65b36a31)

### 2. 2- input AND gate:
   The resulting block diagram and waveforms are presented as depicted:<br>
   ![Screenshot 2024-08-21 153033](https://github.com/user-attachments/assets/d44bf330-ce4f-4b21-bf7b-43d63f1891f2)

### 3. 2-input OR gate:
   The resulting block diagram and waveforms are presented as depicted:<br>
   ![Screenshot 2024-08-21 153131](https://github.com/user-attachments/assets/50edfc0a-c23a-4d43-94b4-7e091aa27586)

### 4. 2:1 MUX
   The resulting block diagram and waveforms are presented as depicted:<br>
   ![Screenshot 2024-08-21 154614](https://github.com/user-attachments/assets/41df9ee3-0116-4e27-a1bd-6d7e5cb972f9)

### 5. Implementation of a Combinational Calculator in TL-Verilog
Overview of the Calculator: This section showcases a simple combinational calculator created using TL-Verilog on the Makerchip platform. The calculator performs the four basic arithmetic operations: addition, subtraction, multiplication, and division.<br>
The resulting block diagram and waveforms are presented as depicted:<br>

![image](https://github.com/user-attachments/assets/8036afeb-76f3-486c-b4f6-52f5c8793583)

In this code snippet, two random 4-bit values, `$rand1[3:0]` and `$rand2[3:0]`, are assigned to the 32-bit variables `$val1[31:0]` and `$val2[31:0]`, respectively. The calculator then performs four arithmetic operations on these values.<br>

A multiplexer (MUX), controlled by the selection bits `$sel[1:0]`, chooses the result of one of these operations. The selected output is then assigned to `$out[31:0]`.<br>

![Screenshot 2024-08-21 160425](https://github.com/user-attachments/assets/0ed3f8e0-eee7-45b9-b140-5f991597dff0)

## SEquential Circuits

A sequential circuit is a type of digital circuit that utilizes memory elements to store data, enabling it to produce outputs based on both current inputs and the circuit’s prior state. In contrast to combinational circuits, which rely solely on present inputs, sequential circuits incorporate feedback loops and storage components like flip-flops or registers to monitor their internal state. This internal state, combined with the current inputs, dictates the circuit’s functionality, making it capable of performing tasks that require a history of inputs, such as counting, data storage, or event sequencing.<br>

### 1.Counter Series:

The block diagram and waveforms generated are displayed below:<br>
![Screenshot 2024-08-21 161052](https://github.com/user-attachments/assets/85cff099-3dfd-4bc9-b474-a9d22589224a) <br>

![Screenshot 2024-08-21 161219](https://github.com/user-attachments/assets/2cf54660-8876-4055-8120-956a6acbc705)

### 2. Fibbonacci Series:

The block diagram and waveforms generated are displayed below:<br>

![Screenshot 2024-08-21 161435](https://github.com/user-attachments/assets/2779d46b-a43d-49b2-bb97-be76abd6b9ce) <br>


![image](https://github.com/user-attachments/assets/4b490f01-0945-4a28-bdc6-7237da52e88e)

### 3. Sequential Calculator:

This design is similar to the previous combinational calculator but simulates a real-world scenario where the result of the previous operation is used as one of the inputs for the next operation. When the circuit is reset, the result is cleared to zero.<br>

![Screenshot 2024-08-21 161837](https://github.com/user-attachments/assets/0f901d7a-5ff6-4560-b804-d19da54cc1a4)<br>

![Screenshot 2024-08-21 161920](https://github.com/user-attachments/assets/d90fe0a2-c3d3-4b1e-8262-f388e9f63960) <br>

![Screenshot 2024-08-21 161805](https://github.com/user-attachments/assets/6192171d-ed81-4b7e-be3f-6d11441192c2) <br>


## Pipelined Logic
In Transaction-Level Verilog (TL-Verilog), pipelined logic is effectively modeled using pipeline constructs that represent data movement through various stages, with each stage corresponding to a clock cycle. This method streamlines the modeling of sequential logic by managing state transitions automatically and providing clear, concise representations of complex multi-stage operations. This enhances both the clarity and maintainability of the design.<br>

### 1. Recreating the Design

![Screenshot 2024-08-21 162218](https://github.com/user-attachments/assets/71aff8b9-aa48-4c88-8c09-5ec86ce791fb) <br>


![Screenshot 2024-08-21 162446](https://github.com/user-attachments/assets/82066fc0-54a3-4944-bf7e-e13f830e1cb6) <br>

![Screenshot 2024-08-21 162521](https://github.com/user-attachments/assets/c86b3a8f-1412-45fd-a76a-52fa833d1d7f) <br>

Therefore, it can be observed that the given pipeline design and the recreated design are identical.<br>


### 2. Pipelined Calculator
This design is similar to the previous Sequential Calculator but incorporates a pipelined architecture and utilizes `$valid` to clear alternate values.<br>

![Screenshot 2024-08-21 182420](https://github.com/user-attachments/assets/d3d77f6a-a429-4047-a25c-72c2ff87646e) <br>

![Screenshot 2024-08-21 163012](https://github.com/user-attachments/assets/d3d5a167-51a3-4bc5-9c55-51469a5d321a) <br>

### 3. Cycle Calculator with validity
We introduce `$valid_or_reset = $valid || $reset;` as a condition for triggering calculations, replacing the previous method of setting `$out` to zero.<br>

![Screenshot 2024-08-21 175517](https://github.com/user-attachments/assets/e1cf5b8d-fb89-4e1e-ac2d-cb1ace330c50) <br>

  </details>

<details>
  <summary><strong> Day 4</strong></summary>

# Fundamentals of RISC-V CPU Micro-architecture
This section will discuss the implementation of a basic 3-stage RISC-V Core/CPU. The three stages include: Fetch, Decode, and Execute. The diagram below illustrates the fundamental block diagram of the CPU core:<br>

### Name of the clock signal is clc_asr

![Screenshot 2024-08-21 180115](https://github.com/user-attachments/assets/8d26c27f-ed72-4cbb-abbd-53ab154c5dcc) <br>

### Implementation plan:
![Screenshot 2024-08-21 180155](https://github.com/user-attachments/assets/d1e368ee-b8de-4819-b25e-11794e32706d) <br>

### 1. Program counter

The Program Counter, also known as the Instruction Pointer, is a component that holds the address of the next instruction to be executed. Typically, the program counter increments by 4 to fetch the subsequent instruction from memory. If a reset occurs, the program counter is reinitialized to zero for the next instruction, after which it resumes normal operation.<br>

The diagram below illustrates the functioning of the program counter.<br>

![Screenshot 2024-08-21 180439](https://github.com/user-attachments/assets/7e2f298d-8e19-47f5-9315-9fbcebadc888)<br>

![Screenshot 2024-08-21 182158](https://github.com/user-attachments/assets/9fb85acd-7ddd-439d-98e1-505473fb965d)  <br>

Code:<br>
``` $pc[31:0] = >>1$reset ? 0 : ( >>1$pc + 31'h4 ); ```

### 2. Adding the instruction memory

![Screenshot 2024-08-21 181059](https://github.com/user-attachments/assets/9ecf6c22-9838-4fec-88dc-c3eeef8ffad6) <br>

![Screenshot 2024-08-21 181120](https://github.com/user-attachments/assets/1b07fa46-04bc-4358-96a4-6ce66fa87e05) <br>

The output of the Program Counter (PC) is fed into the instruction memory, which then outputs the instruction to be executed. The program counter increments by 4 with each valid iteration. This incremented output is used to fetch the next instruction from the instruction memory.<br>

The instruction memory provides a 32-bit instruction based on the input address. During the Fetch Stage, the processor retrieves the instruction from the instruction memory (IM) at the address specified by the PC.<br>

![image](https://github.com/user-attachments/assets/e08019d4-8349-4d62-a832-9e33b6fb0fdd) <br>

Code:<br>
```
     @0
         $reset = *reset;
         $clc_asr = *clk;
         $pc[31:0] = >>1$reset ? 0 : ( >>1$pc + 31'h4 );
         $imem_rd_en = >>1$reset ? 0 : 1;
         $imem_rd_addr[31:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
      @1
         $instr[31:0] = $imem_rd_data[31:0];
```
### 3. Instruction Decoding 
The 32-bit fetched instruction must be decoded to determine the operation to be performed as well as the source and destination addresses. There are six types of instructions:<br>

- **R-type**: Register
- **I-type**: Immediate
- **S-type**: Store
- **B-type**: Branch (Conditional Jump)
- **U-type**: Upper Immediate
- **J-type**: Jump (Unconditional Jump)


The instruction format includes the opcode, immediate value, source address, and destination address. During the Decode Stage, the processor interprets the instruction according to its format and type.<br>
Typically, the RISC-V ISA features 32 registers, each with a width of XLEN (e.g., XLEN = 32 for RV32). The register file used in this architecture supports two simultaneous read operations and one write operation.<br>

![image](https://github.com/user-attachments/assets/a848f05e-fc69-4842-823b-b976a3b95dc1) <br>

![image](https://github.com/user-attachments/assets/b7074567-7940-4153-9c39-08cf97f0b7e6) <br>

Code:<br>
```
      @0
         $reset = *reset;
         $clc_asr = *clk;
         $pc[31:0] = >>1$reset ? 0 : ( >>1$pc + 31'h4 );
         $imem_rd_en = >>1$reset ? 0 : 1;
         $imem_rd_addr[31:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
      @1
         $instr[31:0] = $imem_rd_data[31:0];
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
              $instr[6:2] ==? 5'b001x0 ||
              $instr[6:2] ==? 5'b11001;
         $is_r_instr = $instr[6:2] ==? 5'b01011 ||
              $instr[6:2] ==? 5'b011x0 ||
              $instr[6:2] ==? 5'b10100;
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         $is_b_instr = $instr[6:2] ==? 5'b11000;
         $is_j_instr = $instr[6:2] ==? 5'b11011;
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
```
#### 3a. Immediate Decode Logic
![image](https://github.com/user-attachments/assets/5a7406fb-6ce1-485a-b395-17a629fe94ef) <br>

Code:<br>

```
             $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
             $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
             $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0} :
             $is_u_instr ? {$instr[31:12], 12'b0} :
             $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} : 32'b0;
````

#### 3b. Decoding logic for the other fields like rs1,rs2,funct3,funct7
In addition to the immediate field, several other fields also require decoding. The code for this process is as follows:<br>
Code:
```
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
            
         $rs1_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         
         $funct3_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
            
         $funct7_valid = $is_r_instr ;
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
            
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         ?$rd_valid
            $rd[4:0] = $instr[11:7];

         $opcode[6:0] = $instr[6:0];
```
At any given moment, only one instruction is decoded, and it may belong to any of the six instruction types. Therefore, it is crucial to validate the instruction to ensure it matches its specific category, thereby avoiding conflicts between different instruction types.<br>

![image](https://github.com/user-attachments/assets/1bd0370e-a6c6-4816-9e56-b85517fce671)


#### 3c. Individual Instructions Coding
![image](https://github.com/user-attachments/assets/f4b9df4c-7a78-4de5-b5ba-2d3cdbfcc8eb)

To decode the individual instructions outlined above, use the following code:<br>
```
$dec_bits [10:0] = {$funct7[5], $funct3, $opcode};
$is_beq = $dec_bits ==? 11'bx_000_1100011;
$is_bne = $dec_bits ==? 11'bx_001_1100011;
$is_blt = $dec_bits ==? 11'bx_100_1100011;
$is_bge = $dec_bits ==? 11'bx_101_1100011;
$is_bltu = $dec_bits ==? 11'bx_110_1100011;
$is_bgeu = $dec_bits ==? 11'bx_111_1100011;
$is_addi = $dec_bits ==? 11'bx_000_0010011;
$is_add = $dec_bits ==? 11'b0_000_0110011;
```

We also need to update the program counter to handle branch instructions.<br>
```
$pc[31:0] = >>1$reset ? 32'b0 :
            >>1$taken_branch ? >>1$br_target_pc :
            >>1$pc + 32'd4;
```
output:
![image](https://github.com/user-attachments/assets/a236b2b3-4f98-40e1-8fb1-c1b32f54e47a)

### 4. Register File Read and Enable
In this setup, instructions are fetched from the instruction memory and stored in registers. Two register slots are used to read these instructions, which are then sent to the ALU for processing.<br>

![image](https://github.com/user-attachments/assets/4ec7b570-6887-418e-a20d-95f1790a4ad9) <br>

![image](https://github.com/user-attachments/assets/69643cfa-bdb7-496a-bec6-42f567241580)

Code:<br>
```

$rf_rd_en1 = $rs1_valid;
$rf_rd_en2 = $rs2_valid;
$rf_rd_index1[4:0] = $rs1;
$rf_rd_index2[4:0] = $rs2;
$src1_value[31:0] = $rf_rd_data1;
$src2_value[31:0] = $rf_rd_data2;
```

### 5. Arithmetic and Logic unit
![image](https://github.com/user-attachments/assets/faf1bbb4-2261-4693-8bdd-dcb163bf01af)<br>

Used to execute arithmetic operations on the values stored in the registers. The code for this is as follows:<br>
![image](https://github.com/user-attachments/assets/57cd558b-85cb-4ff5-b927-228621ab9f23)
Code:
```
$result[31:0] = $is_addi ? $src1_value + $imm :
                $is_add ? $src1_value + $src2_value :
                32'bx ;
```

### 6. Register File write
![image](https://github.com/user-attachments/assets/016f9e12-9066-4434-bb66-7588924687bf)

After the ALU performs operations on the values stored in the registers, we may need to write the results back into the registers. This is done using the register file write operation. Additionally, we must ensure that no values are written to the destination register if it is x0, as it is designed to always remain zero. The code for this process is as follows:<br>

![image](https://github.com/user-attachments/assets/1d1301e1-2b73-45be-b4d0-29f37755ef35)
Code:<br>
```
$rf_wr_en = $rd_valid && $rd != 5'b0;
$rf_wr_index[4:0] = $rd;
$rf_wr_data[31:0] = $result;
```

### 7. Branch Instructions
![image](https://github.com/user-attachments/assets/53e9d344-03a9-439c-b89f-3e9b9799c223)

Based on the control input, we might need to jump to a different address after executing a specific instruction, depending on conditions generated at runtime. This is managed using branch instructions. The code for this operation is as follows:
Output:
![image](https://github.com/user-attachments/assets/a09d5618-5fc1-431b-8d0f-83848c677e4e)

Code:<br>
```

$taken_branch = $is_beq ? ($src1_value == $src2_value):
                $is_bne ? ($src1_value != $src2_value):
                $is_blt ? (($src1_value < $src2_value) ^ ($src1_value[31] != $src2_value[31])):
                $is_bge ? (($src1_value >= $src2_value) ^ ($src1_value[31] != $src2_value[31])):
                $is_bltu ? ($src1_value < $src2_value):
                $is_bgeu ? ($src1_value >= $src2_value):1'b0;

$br_target_pc[31:0] = $pc +$imm;
```

## Testbench

To verify the correctness of the code, we use a testbench to check the implementation over the first five cycles.<br>
Code:<br>
```
*passed = |cpu/xreg[10]>>5$value == (1+2+3+4+5+6+7+8+9) ;
```
Upon checking the log file we get the following result:

![Screenshot 2024-08-21 223921](https://github.com/user-attachments/assets/bd2be7a0-7c87-4a59-961f-2035042c4038)

Results:<br>
![Screenshot 2024-08-21 235038](https://github.com/user-attachments/assets/1d352e7e-fd23-45f5-b451-2a1f5e9fa0c1) <br>

![Screenshot 2024-08-21 235131](https://github.com/user-attachments/assets/e6fe4b2f-6dc7-4b1e-94e7-ef4d3998c4a2) <br>

![Screenshot 2024-08-21 235202](https://github.com/user-attachments/assets/3291db9d-016d-4674-90c8-6034b8ac6d3a) <br>

</details>

<details>
  <summary><strong>Day 5</strong></summary>
  
## Complete Pipelined RISC-V CPU Micro-architecture
The CPU core is pipelined to facilitate easier retiming and significantly reduce functional bugs. Pipelining is achieved by adding stages such as @1, @2, and so on. In TL-Verilog, there's no strict requirement for defining pipelines in a systematic order, which is an advantage of this approach.<br>

However, pipelining introduces certain hazards, particularly the "branch instruction hazard" or "branch penalty." This arises because branch instructions can alter the execution sequence, leading to uncertainties. The types of hazards include:<br>

- **Structural Hazards:** Conflicts over shared resources, such as execution units, can cause pipeline stalls until the resource contention is resolved.
- **Data Hazards:** Dependencies on results from previous instructions may lead to incorrect outcomes if the required data is not yet available.
- **Control Hazards (Branch Hazards):** Uncertainties in branch outcomes can delay the confirmation of the correct instruction path, potentially resulting in incorrect instruction fetches and performance degradation due to pipeline flushing.

### Valid signal for Pipelined Logic:
The TL-Verilog code to incorporate the valid signal for pipelined logic is provided below:<br>
```
$start = >>1$reset && !$reset;
$valid = $reset ? 1'b0 : ($start || >>3$valid);
$valid_or_reset = $valid || $reset;
$rs1_or_funct3_valid    = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
$rs2_valid              = $is_r_instr || $is_s_instr || $is_b_instr;
$rd_valid               = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
$funct7_valid           = $is_r_instr;
```

### Handling Data Hazards in Register File with Bypassing:

```
$src1_value[31:0] = $rs1_bypass ? >>1$result[31:0] : $rf_rd_data1[31:0];
$src2_value[31:0] = $rs2_bypass ? >>1$result[31:0] : $rf_rd_data2[31:0];
```

### Correcting branch target path:
```
   //Current instruction is valid if one of the previous 2 instructions were not (taken_branch or load or jump)
   $valid = ~(>>1$valid_taken_br || >>2$valid_taken_br || >>1$is_load || >>2$is_load || >>2$jump_valid 	|| >>1$jump_valid);
         
   //Current instruction is valid & is a taken branch
   $valid_taken_br = $valid && $taken_br;
         
   //Current instruction is valid & is a load
   $valid_load = $valid && $is_load;
         
   //Current instruction is valid & is jump
   $jump_valid = $valid && $is_jump;
   $jal_valid  = $valid && $is_jal;
   $jalr_valid = $valid && $is_jalr;
    
    *passed = |cpu/xreg[14]>>5$value == (1+2+3+4+5+6+7+8+9+10);
```

#### Final Logic for 5-Stage Pipelining:
```
\m4_TLV_version 1d: tl-x.org
\SV
   // Template code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   
   //  Sum 0 to 9 Program 
   //
   // Add 0,1,2,3,...,9
   //
   // Registers:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   m4_asm(SW, r0, r10, 10000)           // Store r10 result in dmem
   m4_asm(LW, r17, r0, 10000)           // Load contents of dmem to r17
   m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clc_asr = *clk;
         
         //PC fetch - branch, jumps and loads introduce 2 cycle bubbles in this pipeline
         $pc[31:0] = >>1$reset ? '0 : (>>3$valid_taken_br ? >>3$br_tgt_pc :
                                       >>3$valid_load     ? >>3$inc_pc[31:0] :
                                       >>3$jal_valid      ? >>3$br_tgt_pc :
                                       >>3$jalr_valid     ? >>3$jalr_tgt_pc :
                                                     (>>1$inc_pc[31:0]));
         // Access instruction memory using PC
         $imem_rd_en = ~ $reset;
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         
         
      @1
         //Getting instruction from IMem
         $instr[31:0] = $imem_rd_data[31:0];
         
         //Increment PC
         $inc_pc[31:0] = $pc[31:0] + 32'h4;
         
         //Decoding I,R,S,U,B,J type of instructions based on opcode [6:0]
         //Only [6:2] is used here because this implementation is for RV64I which does not use [1:0]
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] == 5'b11001;
         
         $is_r_instr = $instr[6:2] == 5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] == 5'b10100;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
         
         $is_b_instr = $instr[6:2] == 5'b11000;
         
         $is_j_instr = $instr[6:2] == 5'b11011;
         
         //Immediate value decode
         $imm[31:0] = $is_i_instr ? { {21{$instr[31]}} , $instr[30:20]} :
                      $is_s_instr ? { {21{$instr[31]}} , $instr[30:25] , $instr[11:8] , $instr[7]} :
                      $is_b_instr ? { {20{$instr[31]}} , $instr[7] , $instr[30:25] , $instr[11:8] , 1'b0} :
                      $is_u_instr ? { $instr[31] , $instr[30:12] , { 12{1'b0}} } :
                      $is_j_instr ? { {12{$instr[31]}} , $instr[19:12] , $instr[20] , $instr[30:21] , 1'b0} :
                      >>1$imm[31:0];
         
         //Generate valid signals for each instruction fields
         $rs1_or_funct3_valid    = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         $rs2_valid              = $is_r_instr || $is_s_instr || $is_b_instr;
         $rd_valid               = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         $funct7_valid           = $is_r_instr;
         
         //Decode other fields of instruction - source and destination registers, funct, opcode
         ?$rs1_or_funct3_valid
            $rs1[4:0]    = $instr[19:15];
            $funct3[2:0] = $instr[14:12];
         
         ?$rs2_valid
            $rs2[4:0]    = $instr[24:20];
         
         ?$rd_valid
            $rd[4:0]     = $instr[11:7];
         
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
         
         $opcode[6:0] = $instr[6:0];
         
         //Decode instruction in subset of base instruction set based on RISC-V 32I
         $dec_bits[10:0] = {$funct7[5],$funct3,$opcode};
         
         //Branch instructions
         $is_beq   = $dec_bits ==? 11'bx_000_1100011;
         $is_bne   = $dec_bits ==? 11'bx_001_1100011;
         $is_blt   = $dec_bits ==? 11'bx_100_1100011;
         $is_bge   = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu  = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu  = $dec_bits ==? 11'bx_111_1100011;
         
         //Jump instructions
         $is_auipc = $dec_bits ==? 11'bx_xxx_0010111;
         $is_jal   = $dec_bits ==? 11'bx_xxx_1101111;
         $is_jalr  = $dec_bits ==? 11'bx_000_1100111;
         
         //Arithmetic instructions
         $is_addi  = $dec_bits ==? 11'bx_000_0010011;
         $is_add   = $dec_bits ==  11'b0_000_0110011;
         $is_lui   = $dec_bits ==? 11'bx_xxx_0110111;
         $is_slti  = $dec_bits ==? 11'bx_010_0010011;
         $is_sltiu = $dec_bits ==? 11'bx_011_0010011;
         $is_xori  = $dec_bits ==? 11'bx_100_0010011;
         $is_ori   = $dec_bits ==? 11'bx_110_0010011;
         $is_andi  = $dec_bits ==? 11'bx_111_0010011;
         $is_slli  = $dec_bits ==? 11'b0_001_0010011;
         $is_srli  = $dec_bits ==? 11'b0_101_0010011;
         $is_srai  = $dec_bits ==? 11'b1_101_0010011;
         $is_sub   = $dec_bits ==? 11'b1_000_0110011;
         $is_sll   = $dec_bits ==? 11'b0_001_0110011;
         $is_slt   = $dec_bits ==? 11'b0_010_0110011;
         $is_sltu  = $dec_bits ==? 11'b0_011_0110011;
         $is_xor   = $dec_bits ==? 11'b0_100_0110011;
         $is_srl   = $dec_bits ==? 11'b0_101_0110011;
         $is_sra   = $dec_bits ==? 11'b1_101_0110011;
         $is_or    = $dec_bits ==? 11'b0_110_0110011;
         $is_and   = $dec_bits ==? 11'b0_111_0110011;
         
         //Store instructions
         $is_sb    = $dec_bits ==? 11'bx_000_0100011;
         $is_sh    = $dec_bits ==? 11'bx_001_0100011;
         $is_sw    = $dec_bits ==? 11'bx_010_0100011;
         
         //Load instructions - support only 4 byte load
         $is_load  = $dec_bits ==? 11'bx_xxx_0000011;
         
         $is_jump = $is_jal || $is_jalr;
         
      @2
         //Get Source register values from reg file
         $rf_rd_en1 = $rs1_or_funct3_valid;
         $rf_rd_en2 = $rs2_valid;
         
         $rf_rd_index1[4:0] = $rs1[4:0];
         $rf_rd_index2[4:0] = $rs2[4:0];
         
         //Register file bypass logic - data forwarding from ALU to resolve RAW dependence
         $src1_value[31:0] = $rs1_bypass ? >>1$result[31:0] : $rf_rd_data1[31:0];
         $src2_value[31:0] = $rs2_bypass ? >>1$result[31:0] : $rf_rd_data2[31:0];
         
         //Branch target PC computation for branches and JAL
         $br_tgt_pc[31:0] = $imm[31:0] + $pc[31:0];
         
         //RAW dependence check for ALU data forwarding
         //If previous instruction was writing to reg file, and current instruction is reading from same register
         $rs1_bypass = >>1$rf_wr_en && (>>1$rd == $rs1);
         $rs2_bypass = >>1$rf_wr_en && (>>1$rd == $rs2);
         
      @3
         //ALU
         $result[31:0] = $is_addi  ? $src1_value +  $imm :
                         $is_add   ? $src1_value +  $src2_value :
                         $is_andi  ? $src1_value &  $imm :
                         $is_ori   ? $src1_value |  $imm :
                         $is_xori  ? $src1_value ^  $imm :
                         $is_slli  ? $src1_value << $imm[5:0]:
                         $is_srli  ? $src1_value >> $imm[5:0]:
                         $is_and   ? $src1_value &  $src2_value:
                         $is_or    ? $src1_value |  $src2_value:
                         $is_xor   ? $src1_value ^  $src2_value:
                         $is_sub   ? $src1_value -  $src2_value:
                         $is_sll   ? $src1_value << $src2_value:
                         $is_srl   ? $src1_value >> $src2_value:
                         $is_sltu  ? $sltu_rslt[31:0]:
                         $is_sltiu ? $sltiu_rslt[31:0]:
                         $is_lui   ? {$imm[31:12], 12'b0}:
                         $is_auipc ? $pc + $imm:
                         $is_jal   ? $pc + 4:
                         $is_jalr  ? $pc + 4:
                         $is_srai  ? ({ {32{$src1_value[31]}} , $src1_value} >> $imm[4:0]) :
                         $is_slt   ? (($src1_value[31] == $src2_value[31]) ? $sltu_rslt : {31'b0, $src1_value[31]}):
                         $is_slti  ? (($src1_value[31] == $imm[31]) ? $sltiu_rslt : {31'b0, $src1_value[31]}) :
                         $is_sra   ? ({ {32{$src1_value[31]}}, $src1_value} >> $src2_value[4:0]) :
                         $is_load  ? $src1_value +  $imm :
                         $is_s_instr ? $src1_value + $imm :
                                    32'bx;
         
         $sltu_rslt[31:0]  = $src1_value <  $src2_value;
         $sltiu_rslt[31:0] = $src1_value <  $imm;
         
         //Jump instruction target PC computation
         $jalr_tgt_pc[31:0] = $imm[31:0] + $src1_value[31:0]; 
         
         //Branch resolution
         $taken_br = $is_beq ? ($src1_value == $src2_value) :
                     $is_bne ? ($src1_value != $src2_value) :
                     $is_blt ? (($src1_value < $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bge ? (($src1_value >= $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bltu ? ($src1_value < $src2_value) :
                     $is_bgeu ? ($src1_value >= $src2_value) :
                     1'b0;
         
         //Current instruction is valid if one of the previous 2 instructions were not (taken_branch or load or jump)
         $valid = ~(>>1$valid_taken_br || >>2$valid_taken_br || >>1$is_load || >>2$is_load || >>2$jump_valid || >>1$jump_valid);
         
         //Current instruction is valid & is a taken branch
         $valid_taken_br = $valid && $taken_br;
         
         //Current instruction is valid & is a load
         $valid_load = $valid && $is_load;
         
         //Current instruction is valid & is jump
         $jump_valid = $valid && $is_jump;
         $jal_valid  = $valid && $is_jal;
         $jalr_valid = $valid && $is_jalr;
         
         //Destination register update - ALU result or load result depending on instruction
         $rf_wr_en = (($rd != '0) && $rd_valid && $valid) || >>2$valid_load;
         $rf_wr_index[4:0] = $valid ? $rd[4:0] : >>2$rd[4:0];
         $rf_wr_data[31:0] = $valid ? $result[31:0] : >>2$ld_data[31:0];
         
      @4
         //Data memory access for load, store
         $dmem_addr[3:0]     =  $result[5:2];
         $dmem_wr_en         =  $valid && $is_s_instr;
         $dmem_wr_data[31:0] =  $src2_value[31:0];
         $dmem_rd_en         =  $valid_load;
         
      
         //Write back data read from load instruction to register
         $ld_data[31:0]      =  $dmem_rd_data[31:0];
         
      
      

      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   //Checks if sum of numbers from 1 to 9 is obtained in reg[17] and runs 10 cycles extra after this is met
   *passed = |cpu/xreg[17]>>10$value == (1+2+3+4+5+6+7+8+9);
   //Run for 200 cycles without any checks
   //*passed = *cyc_cnt > 200;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@2, @3)  // Args: (read stage, write stage) - if equal, no register bypass is required
      m4+dmem(@4)    // Args: (read/write stage)
   
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic
                       // @4 would work for all labs
\SV
   endmodule

```

#### Block diagram:
![Screenshot 2024-08-22 004302](https://github.com/user-attachments/assets/e45d29b4-74f7-4f05-97f7-fc4a9bbce3de)

#### VIZ Table:
![Screenshot 2024-08-22 004311](https://github.com/user-attachments/assets/209562c3-724e-4fe4-8408-8808657ce5ea)

#### Waveforms:
Clock:
![Screenshot 2024-08-22 004337](https://github.com/user-attachments/assets/8b7b9452-158e-44fb-8466-a5e19e6b0e67)

Reset:
![Screenshot 2024-08-22 004433](https://github.com/user-attachments/assets/c1f8aadf-a727-4675-8534-50a6274c83aa)

#### Incrementing the output gradually from 0 (0x00) to  45(0x2d).

![Screenshot 2024-08-22 004456](https://github.com/user-attachments/assets/2cf0e278-68f0-419b-a346-2d426d79f503)

#### Simulation status

![Screenshot 2024-08-22 004532](https://github.com/user-attachments/assets/32e518b1-8c78-472f-a2cb-00e4a4384506)

</details>
</details>

---

<details>
  
  <summary><strong>Lab 7: Comparing GTK wave and makerchip output<strong></summary>

# Evaluating RISC-V Pre-Synthesis Simulation Outputs with Iverilog, GTKwave, and Makerchip
The RISC-V processor was initially designed in TL-Verilog using the Makerchip IDE. For FPGA implementation, it was converted to Verilog through the Sandpiper-SaaS compiler. Pre-synthesis simulations were subsequently conducted using the GTKWave simulator.<br>

### Step 1:
Execute these commands to set up a development environment for working with simulation and synthesis tools, specifically for tasks involving Verilog and RISC-V.
```
sudo apt install make python python3 python3-pip git iverilog gtkwave

cd ~

sudo apt-get install python3-venv

python3 -m venv .venv

source ~/.venv/bin/activate

pip3 install pyyaml click sandpiper-saas
```
![Screenshot 2024-08-26 202210](https://github.com/user-attachments/assets/c5d756aa-d923-4523-9b6a-7154029d3a09)




### Step 2:
To install the required packages, run these commands within a virtual environment:
```
sudo apt install make python python3 python3-pip git iverilog gtkwave docker.io

sudo chmod 666 /var/run/docker.sock

cd ~

pip3 install pyyaml click sandpiper-saas
```
![Screenshot 2024-08-26 202242](https://github.com/user-attachments/assets/d27fb5f0-48a5-4a34-8074-9e2f7f59792d)



### Step 3:
Next, clone the repository into the home directory and create a `pre_synth_sim` directory to store the output.
```
cd ~

git clone https://github.com/manili/VSDBabySoC.git

cd /home/vsduser/VSDBabySoC

make pre_synth_sim
```


### Step 4:
Replace the `rvmyth.tlv` file in the `VSDBabySoC/src/module` folder with your RISC-V design from the Makerchip `.tlv` file that you want to convert to Verilog. Also, update the testbench to match your Makerchip code.<br>

To translate the `.tlv` definition of RISC-V into a `.v` Verilog file, use the following code:
```
sandpiper-saas -i ./src/module/rvmyth.tlv -o rvmyth.v --bestsv --noline -p verilog --outdir ./src/module/
```

### Step 5:
Now to compile and simulate RISC-V design run the following code
```
iverilog -o output/pre_synth_sim.out -DPRE_SYNTH_SIM src/module/testbench.v -I src/include -I src/module
```

### Step 6:
The simulation result, `pre_synth_sim.vcd`, will be saved in the `output/pre_synth_sim` directory.<br>
```
cd output

./pre_synth_sim.out
```

### Step 7:
To open the `.vcd` simulation file using the GTKWave simulation tool, use the following command:
```
$ gtkwave pre_synth_sim.vcd
```
![Screenshot 2024-08-26 202325](https://github.com/user-attachments/assets/ca90e2c3-2382-424c-a362-ae5ed6cc67d3)

### Pre-synthesis Simulation results:
- **clc_asr**: Clock input for the RISC-V core.
- **reset**: This is the input reset signal to the RISC-V core.
- **OUT[9:0]**: This represents the 10-bit output [9:0] port of the RISC-V core. It originates from RISC-V register #14.

### GTKWave Simulation waveforms:
#### Reset:

![Screenshot 2024-08-26 185036](https://github.com/user-attachments/assets/aa605e54-a595-4157-aaa7-4d1cc7bc8cb5)

#### Clock:

 ![Screenshot 2024-08-26 185025](https://github.com/user-attachments/assets/f198bf08-1161-4dac-af41-3ac6e98aeea4)

#### Out[9:0]:

![Screenshot 2024-08-26 185047](https://github.com/user-attachments/assets/fdcb1212-b967-45f7-8149-48e279bf3370)

### Makerchip Simulation waveforms:
#### Reset:

![Screenshot 2024-08-22 004433](https://github.com/user-attachments/assets/fbedc275-7a1a-4ed2-871e-8da5182236a7)

#### Clock:

![Screenshot 2024-08-22 004337](https://github.com/user-attachments/assets/1c16c26d-24d3-4c3b-a909-8642e063b52a)

#### Out[9:0]:

![Screenshot 2024-08-22 004456](https://github.com/user-attachments/assets/a020679d-8a50-49f0-8721-470693ab9c91)

</details>

---

<details>
  
  <summary><strong>Lab 8:</strong></summary>

# Integrating and Validating a Custom RISC-V Processor (rvmyth) within the BabySoC Platform

The goal is to integrate the custom RISC-V processor, known as rvmyth, into the BabySoC platform and validate its functionality using advanced digital design and simulation tools. This process involves generating DAC (Digital-to-Analog Converter) and PLL (Phase-Locked Loop) waveforms for the RISC-V processor to ensure proper performance and accuracy.<br>

### Phase-Locked Loop(PLL)

A Phase-Locked Loop (PLL) is an electronic control system designed to generate an output signal that maintains phase alignment with an input signal. Commonly employed in telecommunications, radio, and computing, PLLs are crucial for tasks such as signal synchronization, frequency stabilization, and clock generation in digital circuits.<br>

### Acquire and Set Up Project Files

You can download all the files for BabySoC using the following command.
```it clone https://github.com/manili/VSDBabySoC.git```

![image](https://github.com/user-attachments/assets/f6db64f9-0b0b-4a37-a277-505600d4c550)

### Verilog Code:
![image](https://github.com/user-attachments/assets/6b3ef4d5-6a5d-4ed3-bcea-585c28fb63c3)


### Changing top level verlog code:
### Simulation procedure:
You can execute a functional simulation by using the following command:
```
cd BabySoC_Simulation
iverilog -o ./pre_synth_sim.out -DPRE_SYNTH_SIM src/module/testbench.v -I src/include -I src/module/
./pre_synth_sim.out
gtkwave pre_synth_sim.vcd
```
### Final Results:
#### Waveforms:
Final Result waveform (with PLL output signal, rvmyth 10-bit output signal, DAC output analog waveform):<br>

![Screenshot from 2024-09-02 23-46-35](https://github.com/user-attachments/assets/b1a5eb2e-ef4b-46d6-aff4-40915ece677a)

Reset Waveform:
![Screenshot from 2024-09-02 23-46-24](https://github.com/user-attachments/assets/9af14ba2-c427-4318-a43d-f59700740dc2)

Clock waveform as clk_asr along with PLL clk:
![Screenshot from 2024-09-02 23-45-45](https://github.com/user-attachments/assets/a527488e-86f7-454f-81da-7e9dd399d619)


  
</details>

---

<details>
  
  <summary><strong>Lab 9:RTL Design using Verilog with Sky130 Technology</strong></summary>

<details>
  
  <summary><strong>Day 1:Introduction to Verilog RTL design and Synthesis.</strong></summary>

## Introduction to iverilog
#### RTL Design and Simulation with Icarus Verilog

In digital circuit design, **Register-Transfer Level (RTL)** is an abstraction used to model synchronous digital circuits by describing the flow of data between hardware registers and the logic operations applied to these signals. This RTL abstraction is expressed using **HDL (Hardware Description Language)** to create high-level models, which are later transformed into lower-level representations and, ultimately, the physical hardware design.

#### Simulator

A tool used to verify the circuit design. In this workshop, we use the **Icarus Verilog (iverilog)** tool. Simulation involves creating models that mimic the behavior of the target device (simulation models) and using test models to validate the device (test benches). RTL design is typically composed of one or more Verilog files that specify the design’s functionality and requirements.

#### Test Bench

A setup that delivers stimulus (test vectors) to the design, verifying its behavior and ensuring it meets the required specifications.

### HOW SIMULATOR WORKS

A **Simulator** monitors changes in input signals and evaluates the output based on those changes. If an input changes, the output is recalculated; otherwise, the simulator does not perform any output evaluation.

![image](https://github.com/user-attachments/assets/689de58b-fc93-4d8e-ab7e-ed6140ef3738)

The **Design** can include one or more primary inputs and outputs, while the **testbench** does not have primary inputs or outputs.

### Simulation flow
![image](https://github.com/user-attachments/assets/d2ed9c58-161d-4143-8981-3b17af233854)

## Labs Introduction
### ENVIRONMENT SETUP

Set up the tool flow using the below commands:

```
mkdir VLSI

cd VLSI

git clone https://github.com/kunalg123/vsdflow.git

git clone https://github.com/kunalg123/sky130RTLDesignAndSynthesisWorkshop.git

cd sky130RTLDesignAndSynthesisWorkshop
```

![image](https://github.com/user-attachments/assets/b631a0f1-6975-45e0-a1ed-74e1618f4dae)

The `sky130RTLDesignAndSynthesisWorkshop` directory contains the `My_Lib` folder, which includes all necessary library files. The `lib` folder provides the standard cell libraries required for synthesis, while the `verilog_model` folder contains the Verilog models for the standard cells in the library. The `verilog_files` folder holds all lab session experiments, featuring both the Verilog code and the corresponding testbench files.

## Labs using iverilog & gtkwave
### Simulation using iverilog simulator - 2:1 multiplexer rtl design

#### VERILOG FILE OF A SIMPLE 2:1 MUX

To compile the verilog and testbench file use the following commands which will generate an executable file and will dump the waveform to view it using the gtkwave

```
iverilog good_mux.v tb_good_mux.v

./a.out

gtkwave tb_good_mux.vcd
```

We can view the waveform of a simple 2:1 mux which selects the input based on the select line
![image](https://github.com/user-attachments/assets/2ef0bf56-6924-495b-8c37-eda3e3780063)

#### Access Module Files
To view the contents of the **good_mux** file run the following command
```
 vim tb_good_mux.v -o good_mux.v 
```
![image](https://github.com/user-attachments/assets/1b12fabf-9473-46bb-9991-7edec85ba2ce)

## Introduction to Yosys & Logic Synthesis

**Synthesizer** is a tool for converting the **RTL** to Netlist and here we are using the **Yosys** Synthesizer.

### Yosys SETUP

![image](https://github.com/user-attachments/assets/9116e680-2c02-46af-a578-4a6c9cb1cd05)
### Verifying the Synthesis
![image](https://github.com/user-attachments/assets/2f6a6d15-3ca7-4cd0-9575-689a3cdbc990)
**Note**:- The set of Primary inputs / primary outputs will remain the same between the RTL design and Synthesis so we can use the same testbench.

## Logic Synthesis

**RTL Design** represents the behavioral specification using HDL (Hardware Description Language).

### Synthesis

Synthesis involves translating the RTL design into a gate-level representation. The design is converted into gates with appropriate connections, producing a file called the **netlist**.

### Liberty (.lib)

The **Liberty (.lib)** file contains a set of logical modules, including various logic gates such as AND, OR, and NOT, with multiple configurations like 2-input, 3-input, and 4-input versions. It also offers different speed options, such as slow, medium, and fast cells. Fast cells cater to high-performance requirements but may increase area and power usage, potentially causing hold time violations. Conversely, relying too heavily on slower cells can reduce performance. The synthesis process aims to select the optimal cells based on constraints to achieve a balance between area, power, and timing.

![image](https://github.com/user-attachments/assets/53f846e8-049d-433c-9e49-6691e6d7fdd5)

### Faster Cells and Slower Cells

The delay of a cell in a digital circuit is affected by the load, which is determined by the capacitance. Faster charging or discharging of this capacitance results in a lower cell delay.

To accelerate the charging/discharging process, wider transistors are used, as they provide more current, thus reducing cell delay. However, using wider transistors also increases power consumption and occupies more area. Conversely, narrower transistors help save area and reduce power consumption but result in higher cell delay. Therefore, minimizing cell delay requires balancing the trade-off between area, power, and performance.
![image](https://github.com/user-attachments/assets/65b42fd9-9720-4dc9-ba70-1702ff2d245c)
## Yosys flow

**1.**  start yosys.
          
```
yosys
```
![image](https://github.com/user-attachments/assets/98fcf243-64b2-4b6a-be45-7ddeabe8398e)
**2.** load the sky130 standard library.
```
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog good_mux.v
```
![image](https://github.com/user-attachments/assets/c92c6ba6-2320-4179-a63a-bc04582e61cc)
**3.** Synthesize the top level module
```
synth -top good_mux
```
![image](https://github.com/user-attachments/assets/c537abb3-a9f3-4705-80da-5fcd45fbcb57)
**4.** Map to the standard library
```
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
```
![image](https://github.com/user-attachments/assets/16ee2bb3-18ee-4023-b44e-207212bac215)
**6.** Two view the result as a graphich use the show command.
```
show
```
![image](https://github.com/user-attachments/assets/b7219fac-8013-45f7-98f3-930a41647f8f)
**7.** To write the result netlist to a file use the write_veriog command. This will output the netlist to a file in the current directory.
```
write_verilog -noattr good_mux_netlist.v
```
![image](https://github.com/user-attachments/assets/1a67427e-169b-4fba-ab14-27bfd22e5842)


</details>

<details>
  
  <summary><strong>Day 2:</strong>Timing libs, hierarchical vs flat synthesis and efficient flop coding styles.</strong></summary>
## Introduction to timing labs

Run the following commands to view the contents inside the .lib file:

```
cd VLSI/sky130RTLDesignAndSynthesisWorkshop/lib/

vim sky130_fd_sc_hd__tt_025C_1v80.lib

```
![image](https://github.com/user-attachments/assets/ee7228b4-511e-4c2f-b593-7e47401c0856)
#  Cell library
 A standard cell library is a collection of characterized logic gates that can be used to implement digital circuits. The Liberty (.lib) files contain PVT parameters (Process, Voltage, Temperature) that can significantly impact circuit performance. Variations in manufacturing, changes in voltage, and fluctuations in temperature all play a role in affecting how the circuit functions.
![image](https://github.com/user-attachments/assets/5f97291a-365c-481d-b403-27f8cfc836b1)<br>

We can also find various flavours of AND gate<br>
![image](https://github.com/user-attachments/assets/94bedc7f-a3ee-4dfb-9f0b-06da6385831a)<br>
![image](https://github.com/user-attachments/assets/025b64b5-7541-4a0e-b052-6cdf864c7020)<br>
![image](https://github.com/user-attachments/assets/27c4fe75-0ded-450f-99b2-1b33da878033)<br>
We can observe that:
* and2_0 -- takes the least area, more delay and low power.
* and2_1 -- takes more area, less delay and high power.
* and2_2 -- takes the largest area, larger delay and highest power.

## Hierarchial synthesis vs Flat synthesis 

Hierarchical synthesis involves breaking down a complex design into various sub-modules, each of which is synthesized separately to produce gate-level netlists before being integrated. This approach enhances organization, allows for module reuse, and enables incremental design changes without impacting the entire system. In contrast, flat synthesis treats the entire design as a single unit during the synthesis process, resulting in a single netlist regardless of any hierarchical relationships. While flat synthesis can optimize certain designs, it becomes difficult to maintain, analyze, and modify the design due to its absence of structural modularity.

### Hierarchial synthesis  

Consider the verilog file ```multiple_modules.v``` which is given in the verilog_files directory
```
module sub_module2 (input a, input b, output y);
    assign y = a | b;
endmodule

module sub_module1 (input a, input b, output y);
    assign y = a&b;
endmodule


module multiple_modules (input a, input b, input c , output y);
    wire net1;
    sub_module1 u1(.a(a),.b(b),.y(net1));  //net1 = a&b
    sub_module2 u2(.a(net1),.b(c),.y(y));  //y = net1|c ,ie y = a&b + c;
endmodule
```
To perform hierarchical synthesis on the ```multiple_modules.v ``` file use the following commands:
```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog multiple_modules.v

synth -top multiple_modules

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show multiple_modules

write_verilog -noattr multiple_modules_hier.v

!vim multiple_modules_hier.v

```
When you do synth -top 'topmodulename' in yosys, it does an hierarchical synthesis. ie the different hierarchies between modules are preserved.
![image](https://github.com/user-attachments/assets/bbc25345-5b46-4aff-96c0-7782b249a9b8)

### Statistics of multiple modules:
![image](https://github.com/user-attachments/assets/f7c794af-8e0c-40a8-8532-12a1f7396a1c)

### Realization of logic:
![image](https://github.com/user-attachments/assets/ad4367db-e277-41fb-bf6f-015ed462c4eb)
### Map to the standard library:
![image](https://github.com/user-attachments/assets/1abd7ffe-5620-402c-931b-5c1488b01f9e)
### Netlist file:
![image](https://github.com/user-attachments/assets/42c970b2-c97e-4188-9303-5aae4048b008)

#### Flat synthesis  
Merges all hierarchical modules in the design into a single module to create a flat netlist. To perform flat synthesis on the ```multiple_modules.v``` file type the following commands:
```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog multiple_modules.v

synth -top multiple_modules

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

flatten

show

write_verilog -noattr multiple_modules_flat.v

!vim multiple_modules_flat.v
```

![image](https://github.com/user-attachments/assets/3cd803ee-13a4-4013-b5d0-044d5fcbd460)<br>

### Realization logic:
![image](https://github.com/user-attachments/assets/5d6b7ba3-2c49-48bf-a1f2-3f59e7646dfd) <br>

### Netlist file
![image](https://github.com/user-attachments/assets/98561a8f-c365-49d4-86ff-35076a95a34b)
### Sub Module Level Synthesis
This method is preferred when multiple instances of same module are used. The synthesis is carried out once and is replicate multiple times, and the multiple instances of the same module are stitched together in the top module. This method is helpful when making use of divide and conquer algorithm


 ```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog multiple_modules.v

synth -top sub_module1

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show
```
![image](https://github.com/user-attachments/assets/79532c31-04f6-43e6-8475-562a54727dd0)<br>
### Realization of the logic
![image](https://github.com/user-attachments/assets/94572252-bf2c-42cc-894b-1e1b006e593c) <br>

## Flop coding styles and optimization

Flip-Flops are an essential part of sequential logic in a circuit and here we explore the design and synthesis of various types of flip-flops. To prevent glitches in digital circuits, we use flip-flops to store intermediate values. This ensures that combinational circuit inputs remain stable until the clock edge, avoiding glitches and maintaining correct operation:

### Asynchronous Reset/set:

**Verilog Code for Asynchronous Reset:**

```
module dff_asyncres ( input clk ,  input async_reset , input d , output reg q );
always @ (posedge clk , posedge async_reset)
begin
	if(async_reset)
		q <= 1'b0;
	else	
		q <= d;
end
endmodule
```
**Verilog Code Asynchronous Set:**

```
module dff_async_set ( input clk ,  input async_set , input d , output reg q );
always @ (posedge clk , posedge async_set)
begin
	if(async_set)
		q <= 1'b1;
	else	
		q <= d;
end
endmodule
```

In this design, the `always` block is triggered by changes in the clock or the reset signal. The circuit is sensitive to the positive edge of the clock. When the reset/set signal goes low or high, the signal on the `q` line changes accordingly. Therefore, the behavior associated with the reset/set occurs immediately and does not wait for the positive edge of the clock.

### Synchronous Reset:

```
module dff_syncres ( input clk , input async_reset , input sync_reset , input d , output reg q );
always @ (posedge clk )
begin
	if (sync_reset)
		q <= 1'b0;
	else	
		q <= d;
end
endmodule
```

#### FLIP FLOP SIMULATION

```
iverilog dff_asyncres.v tb_dff_asyncres.v 

ls

./a.out

gtkwave tb_dff_asyncres.vcd
```
![image](https://github.com/user-attachments/assets/99392de5-3452-4fb0-aa51-12e6d6bec1ee) <br>

### GTK WAVE OF ASYNCHRONOUS RESET:<br>
![image](https://github.com/user-attachments/assets/58fa8659-6a19-4e2f-b18a-83158a431184) <br>

### GTK WAVE OF ASYNCHRONOUS SET<br>
![image](https://github.com/user-attachments/assets/20269f6c-3bbd-476c-bcaa-d1dc960560ed)<br>


### GTK WAVE OF SYNCHRONOUS RESET<br>
![image](https://github.com/user-attachments/assets/cbffec19-9f5c-49db-a690-7b5358b6662d) <br>

#### FLIP FLOP SYNTHESIS

```

yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog dff_asyncres.v

synth -top dff_asyncres

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show 
```
**Statistics of D FLipflop with Asynchronous Reset**
![image](https://github.com/user-attachments/assets/60b98e53-17bd-4b91-aad6-4b43dc976551) <br>

![image](https://github.com/user-attachments/assets/bfd8dfa5-cf05-4c10-84c1-da1d3ebfe97d) <br>

**Realization of Logic**
![image](https://github.com/user-attachments/assets/1769272a-142f-4dea-942b-e53cd5151b8f) <br>

**Statistics of D FLipflop with Asynchronous set**\
Follow the same steps as given above just the file name changes to dff_async_set.v<br>

![image](https://github.com/user-attachments/assets/0ebe0be9-3a62-426e-b9d6-dcd2d62aae04)<br>
![image](https://github.com/user-attachments/assets/9c974ced-9522-4410-ab2a-ecbce6f7fe4a)<br>


### Realization Logic:
![image](https://github.com/user-attachments/assets/c4f0a4b6-405d-415d-bee6-276b4b929713)<br>

**Statistics of D FLipflop with Synchronous Reset**

![image](https://github.com/user-attachments/assets/57fa0386-4d90-4fcb-960a-7924959edcb0) <br>
![image](https://github.com/user-attachments/assets/cdfd385c-594e-4592-ba28-07064fa50010) <br>


### Realization logic:
![image](https://github.com/user-attachments/assets/0f9b2165-070b-4411-8a2b-85bf532f7872)<br>


## Optimizations

### Example 1: mult_2.v 

**verilog code**

```
module mul2 (input [2:0] a, output [3:0] y);
assign y = a * 2;
endmodule
```

**truth table**

![image](https://github.com/user-attachments/assets/d6fe75f5-2a8b-4466-a50d-3b723d32d12b) <br>
We can see the multiplication of a number by 2 doesnt really need any extra hardware we just need to append the LSB's with zeroes and the remaining bits are the input bits of same, It can be realised by grouding the LSB's and wiring the input properly to the output.

Run the below code to view the netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog mult_2.v

synth -top mult2

abc -liberty ../my_lib/lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show 

write_verilog -noattr mult_2_net.v

!vim mult_2_net.v
```
**Statistics**


### Realization logic:
![image](https://github.com/user-attachments/assets/e8906ab2-a50b-4a0e-8c36-b024bd875c1f)<br>

### Netlist:
![image](https://github.com/user-attachments/assets/db991512-2850-4f44-baa0-9e434137804f)<br>

### Example 2: mult_8.v

**verilog code**

```
module mult8 (input [2:0] a , output [5:0] y);
	assign y = a * 9;
endmodule
```

**logic behaviour**
![image](https://github.com/user-attachments/assets/b23f4794-c024-4b5b-be27-54359e6b1521) <br>

In this design the 3-bit input number "a" is multiplied by 9 i.e (a9) which can be re-written as (a8) + a . The term (a8) is nothing but a left shifting the number a by three bits. Consider that a = a2 a1 a0. (a8) results in a2 a1 a0 0 0 0. (a9)=(a8)+a = a2 a1 a0 a2 a1 a0 = aa(in 6 bit format). Hence in this case no hardware realization is required. The synthesized netlist of this design is shown below:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog mult_8.v

synth -top mult8

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr mult_8_net.v

```

**Statestics**
![image](https://github.com/user-attachments/assets/9b2fcb4a-bb33-408b-aaaa-d11855b1d980)


**Realization logic**
![image](https://github.com/user-attachments/assets/fb3d927b-3d7d-4b98-9d52-090d1d533e64)

**Netlist**
![image](https://github.com/user-attachments/assets/d3a4552a-2ef6-4397-8d19-0a8d2ebe410a)


  
</details>

<details>

 <summary><strong>Day 3:Introduction to Combinational and sequential optimizations.</strong></summary>

##  Introduction to Combinational Logic Optimization and sequential Optimization
There are two types of optimisations: Combinational and Sequential optimisations. These optimisations are done inorder to achieve designs that are efficient in terms of area, power, and performance.

**Combinational Optimization**

The techiniques used are:

- Constant Propagation (Direct Optimisation)
- Boolean Logic Optimisation (using K-Map or Quine McCluskey method)

**Constant Propagation:**

Consider the below circuit:<br>
![image](https://github.com/user-attachments/assets/41613684-804c-4202-b6e1-417ec4dfe02f) <br>

The top circuit uses 6 transistors (3 NMOS and 3 PMOS), while the bottom circuit uses 2 transistors (1 NMOS and 1 PMOS) when input A is set to zero, turning the logic into an inverter.

**Boolean Logic Optimisation:**

Consider the below verilog code:

```assign y = a?(b?c:(c?a:0)):(!c)```

The ternary operator (?:) will make the circuit behave like a mux upon synthesis as shown below.<br>

![image](https://github.com/user-attachments/assets/d32a85cd-d117-457d-ad6b-b4a7c18a0a7a) <br>

The circuit can be optimised as follows:<br>
![image](https://github.com/user-attachments/assets/e643fe2d-2c79-4cdb-8e55-a747ea81161f) <br>

**Example 1:**

Verilog code:

```
module opt_check (input a , input b , output y);
	assign y = a?b:0;
endmodule
```

The above code infers a multiplexer and since one of the inputs of the multiplexer is always connected to the ground it will infer an AND gate on optimisation.

Run the following commands for netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog opt_check.v

synth -top opt_check

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr opt_check_net.v

!vim opt_ckeck_net.v
```
### Realization logic:
![image](https://github.com/user-attachments/assets/6afa61c9-8423-4087-82ee-4d5f98ac7ecc) <br>

### Netlist:<br>
![image](https://github.com/user-attachments/assets/0bbe5fc3-fea1-49a2-90d9-ac3211d6805a)

**Example 2:**

Verilog code:

```
module opt_check2 (input a , input b , output y);
	assign y = a?1:b;
endmodule
```

Since one of the inputs of the multiplexer is always connected to the logic 1 it will infer an OR gate on optimisation.The OR gate will be NAND implementation since NOR gate has stacked pmos while NAND implementation has stacked nmos.

Run the below code for netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog opt_check2.v

synth -top opt_check2

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr opt_check2_net.v

!vim opt_ckeck2_net.v
```
![image](https://github.com/user-attachments/assets/99cf0c0f-7c17-4899-8656-d4f02e609856) <br>

![image](https://github.com/user-attachments/assets/b4336216-bde9-4e58-8338-5dadd1ba50bc) <br>

**Example 3:**

Verilog code:

```
module opt_check3 (input a , input b, input c , output y);
	assign y = a?(c?b:0):0;
endmodule
```

On optimisation the above design becomes a 3 input AND gate.

Run the below code for netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog opt_check3.v

synth -top opt_check3

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr opt_check3_net.v

!vim opt_ckeck3_net.v
```

![image](https://github.com/user-attachments/assets/e517b643-27c3-4e31-920a-2a34672a1671) <br>

![image](https://github.com/user-attachments/assets/6407abf8-0e7b-4f8a-af78-3ad422436b39) <br>

**Example 4:**

Verilog code:

```
module opt_check4 (input a , input b, input c , output y);
	assign y = a?(c?b:0):0;
endmodule
```

On optimisation the above design becomes a 2 input XNOR gate.

Run the below code for netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog opt_check4.v

synth -top opt_check4

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr opt_check4_net.v

!vim opt_ckeck4_net.v
```

![image](https://github.com/user-attachments/assets/57cf9621-f604-45d5-8ecd-5c131cb43a5b) <br>

![image](https://github.com/user-attachments/assets/1b8c0d4f-fedc-4a9a-97f4-bff527f45cde) <br>

**Example 5:**

Verilog code:

```
module sub_module1(input a , input b , output y);
 assign y = a & b;
endmodule

module sub_module2(input a , input b , output y);
 assign y = a^b;
endmodule

module multiple_module_opt(input a , input b , input c , input d , output y);
wire n1,n2,n3;

sub_module1 U1 (.a(a) , .b(1'b1) , .y(n1));
sub_module2 U2 (.a(n1), .b(1'b0) , .y(n2));
sub_module2 U3 (.a(b), .b(d) , .y(n3));

assign y = c | (b & n1); 

endmodule
```

On optimisation the above design becomes a AND OR gate

Run the below code for netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog multiple_module_opt.v

synth -top multiple_module_opt

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

flatten

show

write_verilog -noattr multiple_module_opt_net.v

!vim multiple_module_opt_net.v
```
![image](https://github.com/user-attachments/assets/51b4651c-3c03-4b1b-99be-88e552097e13)<br>

![image](https://github.com/user-attachments/assets/9be634ac-37bc-4d9c-8a85-e6cb7df15f70) <br>

**Example 6:**

Verilog code:

```
module sub_module(input a , input b , output y);
	assign y = a & b;
endmodule

module multiple_module_opt2(input a , input b , input c , input d , output y);
		wire n1,n2,n3;
	sub_module U1 (.a(a) , .b(1'b0) , .y(n1));
	sub_module U2 (.a(b), .b(c) , .y(n2));
	sub_module U3 (.a(n2), .b(d) , .y(n3));
	sub_module U4 (.a(n3), .b(n1) , .y(y));
endmodule
```

On optimisation the above design becomes Y=0 

Run the below code for netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog multiple_module_opt2.v

synth -top multiple_module_opt2

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

flatten

show

write_verilog -noattr multiple_module_opt2_net.v

!vim multiple_module_opt_net2.v
```

![image](https://github.com/user-attachments/assets/d59918dd-ef65-4aed-9c51-949b14dd5323) <br>

![image](https://github.com/user-attachments/assets/c079cea2-d20c-4024-b63b-77b4404ba28e) <br>



## Sequential Logic Optimizations

**Example 1:**

Verilog code:

```
module dff_const1(input clk, input reset, output reg q);
always @(posedge clk, posedge reset)
begin
	if(reset)
		q <= 1'b0;
	else
		q <= 1'b1;
end
endmodule
```

Run the below code for netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog dff_const1.v

synth -top dff_const1

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr dff_const1_net.v

!vim dff_const1_net.v
```

![image](https://github.com/user-attachments/assets/21083494-712e-4f90-a45e-0e28af4a6cc7) <br>

![image](https://github.com/user-attachments/assets/ff9b80be-db8c-414d-9d90-05e61b234e62) <br>

GTKWave Output:

```
iverilog dff_const1.v tb_dff_const1.v

./a.out

gtkwave tb_dff_const1.vcd

```

![image](https://github.com/user-attachments/assets/12d92a44-fc85-4bb4-9387-5af636e37165) <br>

**Example 2:**

Verilog code:

```
module dff_const2(input clk, input reset, output reg q);
always @(posedge clk, posedge reset)
begin
	if(reset)
		q <= 1'b1;
	else
		q <= 1'b1;
end
endmodule
```

Run the below code for netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog dff_const2.v

synth -top dff_const2

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr dff_const2_net.v

!vim dff_const2_net.v
```
![image](https://github.com/user-attachments/assets/e63b82a2-7acf-488f-a1c4-5bb0abc49851)<br>
![image](https://github.com/user-attachments/assets/9aab9bd0-5166-4d81-9aa9-b26136f9f9f5)<br>


GTKWave Output:

```
iverilog dff_const2.v tb_dff_const2.v

./a.out

gtkwave tb_dff_const2.vcd
```

![image](https://github.com/user-attachments/assets/f9b1918e-c301-47e5-956e-491ea018266c) <br>

**Example 3:**

Verilog code:

```
module dff_const3(input clk, input reset, output reg q);
reg q1;

always @(posedge clk, posedge reset)
begin
	if(reset)
	begin
		q <= 1'b1;
		q1 <= 1'b0;
	end
	else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end
endmodule
```

Run the below code for netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog dff_const3.v

synth -top dff_const3

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr dff_const3_net.v
```
![image](https://github.com/user-attachments/assets/6ab05acd-7804-4747-a8e5-5f6dd445cd0f) <br>
![image](https://github.com/user-attachments/assets/2ccb1385-fe02-486f-826a-dd1258d6fdb6) <br>


GTKWave Output:

```
iverilog dff_const3.v tb_dff_const3.v

./a.out

gtkwave tb_dff_const3.vcd
```
![image](https://github.com/user-attachments/assets/eeff10a5-2baa-49ef-b639-1cd6198445c4)<br>

**Example 4:**

Verilog code:

```
module dff_const4(input clk, input reset, output reg q);
reg q1;

always @(posedge clk, posedge reset)
begin
	if(reset)
	begin
		q <= 1'b1;
		q1 <= 1'b1;
	end
else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end
endmodule
```

Run the below code for netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog dff_const4.v

synth -top dff_const4

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr dff_const4_net.v
```

![image](https://github.com/user-attachments/assets/36eab097-2ac4-4d7c-8b69-fd8c953362e2) <br>
![image](https://github.com/user-attachments/assets/a2d85b49-e968-421c-b16a-c15fb132cd1a) <br>


 
GTKWave Output:

```
iverilog dff_const4.v tb_dff_const4.v

./a.out

gtkwave tb_dff_const4.vcd
```
![image](https://github.com/user-attachments/assets/855ed3fc-da16-4a13-adf5-9fc3cb303b6c) <br>

**Example 5:**

Verilog code:

```
module dff_const5(input clk, input reset, output reg q);
reg q1;
always @(posedge clk, posedge reset)
	begin
		if(reset)
		begin
			q <= 1'b0;
			q1 <= 1'b0;
		end
	else
		begin
			q1 <= 1'b1;
			q <= q1;
		end
	end
endmodule
```

Run the below code for netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog dff_const5.v

synth -top dff_const5

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr dff_const5_net.v
```
![image](https://github.com/user-attachments/assets/3252450a-1435-448d-b21e-87edf5bc05cf) <br>
![image](https://github.com/user-attachments/assets/2e1c56d9-752f-4d9e-baa3-64c8c07662e0) <br>


GTKWave Output:

```
iverilog dff_const5.v tb_dff_const5.v

./a.out

gtkwave tb_dff_const5.vcd
```

![image](https://github.com/user-attachments/assets/6902ac4a-f792-452c-be73-23f1916b54a9) <br>


**Sequential Logic Optimizations for unused outputs**

**Example 1:**

Verilog code:

```
module counter_opt (input clk , input reset , output q);
reg [2:0] count;
assign q = count[0];
always @(posedge clk ,posedge reset)
begin
	if(reset)
		count <= 3'b000;
	else
		count <= count + 1;
end
endmodule
```

Run the below code for netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog counter_opt.v

synth -top counter_opt

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr counter_opt_net.v
```
![image](https://github.com/user-attachments/assets/84229380-c453-449e-b560-2404b746d241)<br>
![image](https://github.com/user-attachments/assets/3061662e-430b-40bc-baba-5e6a75def8e5)<br>


GTKWave Output:

```
iverilog counter_opt.v tb_counter_opt.v

./a.out

gtkwave tb_counter_opt.vcd
```
![image](https://github.com/user-attachments/assets/6d3d342c-0d1d-45c0-9bdc-14f827df54d1) <br>


Modified counter logic:

Verilog code:

```
module counter_opt (input clk , input reset , output q);
reg [2:0] count;
assign q = {count[2:0]==3'b100};
always @(posedge clk ,posedge reset)
begin
if(reset)
	count <= 3'b000;
else
	count <= count + 1;
end
endmodule
```
Run the below code for netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog counter_opt.v

synth -top counter_opt

dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr counter_opt_net.v

```
![image](https://github.com/user-attachments/assets/9f695ebc-ce33-4cfb-856f-8fa5ac0b1ddb) <br>
![image](https://github.com/user-attachments/assets/3579f806-62b0-4270-aaa8-8bb3bd974e73) <br>



GTKWave Output:

```
iverilog counter_opt.v tb_counter_opt.v

./a.out

gtkwave tb_counter_opt.vcd
```

![image](https://github.com/user-attachments/assets/7c6a699d-615b-4d35-92cf-9df3bbe24b5e) <br>


</details>

<details>
	
	<summary><strong>Day 4:</strong> GLS, blocking vs non-blocking and Synthesis-Simulation mismatch.</strong></summary>
 
## Introduction to GLS and Synthesis-Simulation mismatch

Gate Level Simulation (GLS) is an important step in verifying digital circuits. It simulates the synthesized netlist, a lower-level representation of the design, using a testbench to check its logical accuracy and timing behavior. By comparing the simulation outputs with expected results, GLS ensures the synthesis process hasn't introduced any errors and that the design meets performance requirements.

Sensitivity lists are key for ensuring correct circuit behavior. An incomplete sensitivity list can result in unintended latches. Blocking and non-blocking assignments in `always` blocks behave differently, and improper use of blocking assignments can inadvertently create latches, leading to mismatches between synthesis and simulation. To prevent this, it's crucial to carefully review the circuit behavior and ensure the sensitivity list and assignments match the intended functionality.

![image](https://github.com/user-attachments/assets/42f9c6df-5016-474c-85ab-23bcefaee7b8)

**Example 1:**

Verilog code:

```
module ternary_operator_mux (input i0 , input i1 , input sel , output y);
assign y = sel?i1:i0;
endmodule
```

Simulation:

```
iverilog ternary_operator_mux.v tb_ternary_operator_mux.v

./a.out

gtkwave tb_ternary_operator_mux.vcd

```
![image](https://github.com/user-attachments/assets/8a3fbf82-569c-49e4-81e7-6df6827eaf01)

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog ternary_operator_mux.v

synth -top ternary_operator_mux

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr ternary_operator_mux_net.v

```
![image](https://github.com/user-attachments/assets/bba1f99b-0b45-43df-99e4-7cd4e9bc83bd) <br>
![image](https://github.com/user-attachments/assets/eb2b5876-abbe-41c4-b01f-409e5e14e936) <br>
![image](https://github.com/user-attachments/assets/4ce23e72-7bf6-401d-b159-bf89656d79c9) <br>

LS:

```
iverilog ../my_lib/verilog_model/primitives.v ../my_lib/verilog_model/sky130_fd_sc_hd.v ternary_operator_mux_net.v tb_ternary_operator_mux.v

./a.out

gtkwave tb_ternary_operator_mux.vcd
```
![image](https://github.com/user-attachments/assets/02f518d7-257f-43bc-964d-d563f95d7084) <br>

In this case there is no mismatch between the waveforms before and after synthesis.

**Example 2:**

Verilog code:

```
module bad_mux (input i0 , input i1 , input sel , output reg y);
always @ (sel)
begin
	if(sel)
		y <= i1;
	else 
		y <= i0;
end
endmodule
```

Simulation:

```
iverilog bad_mux.v tb_bad_mux.v

./a.out

gtkwave tb_bad_mux.vcd
```
![image](https://github.com/user-attachments/assets/ce260cb7-9a03-4887-971f-81a09ed8a0ef)



Netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog bad_mux.v

synth -top bad_mux

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr bad_mux_net.v

```
![image](https://github.com/user-attachments/assets/a02528c3-6ae3-4881-a64e-42c03d98c579)<br>
![image](https://github.com/user-attachments/assets/db013b4f-e4bc-462f-b9cc-8ee53f55870d)<br>
![image](https://github.com/user-attachments/assets/781bd660-5eba-4aa7-92ec-c7279e7f3146)<br>


GLS:

```
iverilog ../my_lib/verilog_model/primitives.v ../my_lib/verilog_model/sky130_fd_sc_hd.v bad_mux_net.v tb_bad_mux.v

./a.out

gtkwave tb_bad_mux.vcd
```
![image](https://github.com/user-attachments/assets/6994a8b4-4c4c-4902-9c4a-e83b30874bc3)


In this case there is a synthesis and simulation mismatch. While performing synthesis yosys has corrected the sensitivity list error.
**Labs on Synthesis-Simulation mismatch for blocking statements**

Verilog code:

```
module blocking_caveat (input a , input b , input  c, output reg d); 
reg x;
always @ (*)
begin
d = x & c;
x = a | b;
end
endmodule
```

Simulation:

```
iverilog blocking_caveat.v tb_blocking_caveat.v

./a.out

gtkwave tb_blocking_caveat.vcd
```
![image](https://github.com/user-attachments/assets/4a316f28-6246-4e81-b34a-6f3498b84965)


Netlist:

```
yosys

read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

read_verilog blocking_caveat.v

synth -top blocking_caveat

abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

show

write_verilog -noattr blocking_caveat_net.v
```
![image](https://github.com/user-attachments/assets/d755dc5d-4d6d-4963-97df-a94f0f62ded0) <br>
![image](https://github.com/user-attachments/assets/0a10123d-f2b5-4d28-ac82-22ab964ffe56) <br>
![image](https://github.com/user-attachments/assets/05525a75-de34-43d6-a178-6bae07128d30) <br>


GLS:

```
iverilog ../my_lib/verilog_model/primitives.v ../my_lib/verilog_model/sky130_fd_sc_hd.v blocking_caveat_net.v tb_blocking_caveat.v

./a.out

gtkwave tb_blocking_caveat.vcd
```
![image](https://github.com/user-attachments/assets/5e955b83-c5b4-4e26-9918-104c3afccefe) <br>


In this case there is a synthesis and simulation mismatch. While performing synthesis yosys has corrected the latch error.

</details>

</details>
---
